// 
// Decompiled by Procyon v0.5.30
// 

package jogamp.opengl.gl4;

import com.jogamp.common.nio.Buffers;
import com.jogamp.common.nio.PointerBuffer;
import com.jogamp.opengl.*;
import com.jogamp.opengl.util.GLBuffers;
import jogamp.opengl.GLBufferObjectTracker;
import jogamp.opengl.GLBufferStateTracker;
import jogamp.opengl.GLContextImpl;
import jogamp.opengl.GLStateTracker;

import java.nio.*;

public class GL4bcImpl implements GLBase, GL, GL2ES1, GL2ES2, GL2ES3, GL3ES3, GL4ES3, GL2GL3, GL2, GL3, GL3bc, GL4, GL4bc
{
    private static final int params_offset = 0;
    private final GLProfile glProfile;
    private final GLContextImpl _context;
    private final GLStateTracker glStateTracker;
    private final GLBufferObjectTracker bufferObjectTracker;
    private final GLBufferStateTracker bufferStateTracker;
    private final GLBufferObjectTracker.CreateStorageDispatch glBufferDataDispatch;
    private final GLBufferObjectTracker.UnmapBufferDispatch glUnmapBufferDispatch;
    private final GLBufferObjectTracker.MapBufferAllDispatch glMapBufferDispatch;
    private final GLBufferObjectTracker.MapBufferRangeDispatch glMapBufferRangeDispatch;
    private final GL4bcProcAddressTable _pat;
    private boolean inBeginEndPair;
    private int[] imageSizeTemp;
    private boolean haveARBPixelBufferObject;
    private boolean haveEXTPixelBufferObject;
    private boolean haveGL15;
    private boolean haveGL21;
    private boolean haveARBVertexBufferObject;
    private boolean haveARBVertexArrayObject;
    private final GLBufferObjectTracker.CreateStorageDispatch glNamedBufferDataDispatch;
    private final GLBufferObjectTracker.CreateStorageDispatch glNamedBufferDataEXTDispatch;
    private final GLBufferObjectTracker.CreateStorageDispatch glBufferStorageDispatch;
    private final GLBufferObjectTracker.CreateStorageDispatch glNamedBufferStorageDispatch;
    private final GLBufferObjectTracker.CreateStorageDispatch glNamedBufferStorageEXTDispatch;
    private final GLBufferObjectTracker.UnmapBufferDispatch glUnmapNamedBufferDispatch;
    private final GLBufferObjectTracker.MapBufferAllDispatch glMapNamedBufferDispatch;
    private final GLBufferObjectTracker.MapBufferAllDispatch glMapNamedBufferEXTDispatch;
    private final GLBufferObjectTracker.MapBufferRangeDispatch glMapNamedBufferRangeDispatch;
    private final GLBufferObjectTracker.MapBufferRangeDispatch glMapNamedBufferRangeEXTDispatch;
    
    @Override
    public void glClearIndex(final float n) {
        final long addressof_glClearIndex = this._pat._addressof_glClearIndex;
        if (addressof_glClearIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearIndex"));
        }
        this.dispatch_glClearIndex1(n, addressof_glClearIndex);
    }
    
    private native void dispatch_glClearIndex1(final float p0, final long p1);
    
    @Override
    public void glClearColor(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glClearColor = this._pat._addressof_glClearColor;
        if (addressof_glClearColor == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearColor"));
        }
        this.dispatch_glClearColor1(n, n2, n3, n4, addressof_glClearColor);
    }
    
    private native void dispatch_glClearColor1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glClear(final int n) {
        final long addressof_glClear = this._pat._addressof_glClear;
        if (addressof_glClear == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClear"));
        }
        this.dispatch_glClear1(n, addressof_glClear);
    }
    
    private native void dispatch_glClear1(final int p0, final long p1);
    
    @Override
    public void glIndexMask(final int n) {
        final long addressof_glIndexMask = this._pat._addressof_glIndexMask;
        if (addressof_glIndexMask == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexMask"));
        }
        this.dispatch_glIndexMask1(n, addressof_glIndexMask);
    }
    
    private native void dispatch_glIndexMask1(final int p0, final long p1);
    
    @Override
    public void glColorMask(final boolean b, final boolean b2, final boolean b3, final boolean b4) {
        final long addressof_glColorMask = this._pat._addressof_glColorMask;
        if (addressof_glColorMask == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorMask"));
        }
        this.dispatch_glColorMask1(b, b2, b3, b4, addressof_glColorMask);
    }
    
    private native void dispatch_glColorMask1(final boolean p0, final boolean p1, final boolean p2, final boolean p3, final long p4);
    
    @Override
    public void glAlphaFunc(final int n, final float n2) {
        final long addressof_glAlphaFunc = this._pat._addressof_glAlphaFunc;
        if (addressof_glAlphaFunc == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glAlphaFunc"));
        }
        this.dispatch_glAlphaFunc1(n, n2, addressof_glAlphaFunc);
    }
    
    private native void dispatch_glAlphaFunc1(final int p0, final float p1, final long p2);
    
    @Override
    public void glBlendFunc(final int n, final int n2) {
        final long addressof_glBlendFunc = this._pat._addressof_glBlendFunc;
        if (addressof_glBlendFunc == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendFunc"));
        }
        this.dispatch_glBlendFunc1(n, n2, addressof_glBlendFunc);
    }
    
    private native void dispatch_glBlendFunc1(final int p0, final int p1, final long p2);
    
    @Override
    public void glLogicOp(final int n) {
        final long addressof_glLogicOp = this._pat._addressof_glLogicOp;
        if (addressof_glLogicOp == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLogicOp"));
        }
        this.dispatch_glLogicOp1(n, addressof_glLogicOp);
    }
    
    private native void dispatch_glLogicOp1(final int p0, final long p1);
    
    @Override
    public void glCullFace(final int n) {
        final long addressof_glCullFace = this._pat._addressof_glCullFace;
        if (addressof_glCullFace == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCullFace"));
        }
        this.dispatch_glCullFace1(n, addressof_glCullFace);
    }
    
    private native void dispatch_glCullFace1(final int p0, final long p1);
    
    @Override
    public void glFrontFace(final int n) {
        final long addressof_glFrontFace = this._pat._addressof_glFrontFace;
        if (addressof_glFrontFace == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFrontFace"));
        }
        this.dispatch_glFrontFace1(n, addressof_glFrontFace);
    }
    
    private native void dispatch_glFrontFace1(final int p0, final long p1);
    
    @Override
    public void glPointSize(final float n) {
        final long addressof_glPointSize = this._pat._addressof_glPointSize;
        if (addressof_glPointSize == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPointSize"));
        }
        this.dispatch_glPointSize1(n, addressof_glPointSize);
    }
    
    private native void dispatch_glPointSize1(final float p0, final long p1);
    
    @Override
    public void glLineWidth(final float n) {
        final long addressof_glLineWidth = this._pat._addressof_glLineWidth;
        if (addressof_glLineWidth == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLineWidth"));
        }
        this.dispatch_glLineWidth1(n, addressof_glLineWidth);
    }
    
    private native void dispatch_glLineWidth1(final float p0, final long p1);
    
    @Override
    public void glLineStipple(final int n, final short n2) {
        final long addressof_glLineStipple = this._pat._addressof_glLineStipple;
        if (addressof_glLineStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLineStipple"));
        }
        this.dispatch_glLineStipple1(n, n2, addressof_glLineStipple);
    }
    
    private native void dispatch_glLineStipple1(final int p0, final short p1, final long p2);
    
    @Override
    public void glPolygonMode(final int n, final int n2) {
        final long addressof_glPolygonMode = this._pat._addressof_glPolygonMode;
        if (addressof_glPolygonMode == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPolygonMode"));
        }
        this.dispatch_glPolygonMode1(n, n2, addressof_glPolygonMode);
    }
    
    private native void dispatch_glPolygonMode1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPolygonOffset(final float n, final float n2) {
        final long addressof_glPolygonOffset = this._pat._addressof_glPolygonOffset;
        if (addressof_glPolygonOffset == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffset"));
        }
        this.dispatch_glPolygonOffset1(n, n2, addressof_glPolygonOffset);
    }
    
    private native void dispatch_glPolygonOffset1(final float p0, final float p1, final long p2);
    
    @Override
    public void glPolygonStipple(final ByteBuffer byteBuffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glPolygonStipple = this._pat._addressof_glPolygonStipple;
        if (addressof_glPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPolygonStipple"));
        }
        this.dispatch_glPolygonStipple1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glPolygonStipple);
    }
    
    private native void dispatch_glPolygonStipple1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glPolygonStipple(final byte[] array, final int n) {
        this.checkUnpackPBOUnbound(true);
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"mask_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPolygonStipple = this._pat._addressof_glPolygonStipple;
        if (addressof_glPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPolygonStipple"));
        }
        this.dispatch_glPolygonStipple1(array, n, false, addressof_glPolygonStipple);
    }
    
    @Override
    public void glPolygonStipple(final long n) {
        this.checkUnpackPBOBound(true);
        final long addressof_glPolygonStipple = this._pat._addressof_glPolygonStipple;
        if (addressof_glPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPolygonStipple"));
        }
        this.dispatch_glPolygonStipple1(n, addressof_glPolygonStipple);
    }
    
    private native void dispatch_glPolygonStipple1(final long p0, final long p1);
    
    @Override
    public void glGetPolygonStipple(final ByteBuffer byteBuffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetPolygonStipple = this._pat._addressof_glGetPolygonStipple;
        if (addressof_glGetPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPolygonStipple"));
        }
        this.dispatch_glGetPolygonStipple1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetPolygonStipple);
    }
    
    private native void dispatch_glGetPolygonStipple1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glGetPolygonStipple(final byte[] array, final int n) {
        this.checkPackPBOUnbound(true);
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"mask_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetPolygonStipple = this._pat._addressof_glGetPolygonStipple;
        if (addressof_glGetPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPolygonStipple"));
        }
        this.dispatch_glGetPolygonStipple1(array, n, false, addressof_glGetPolygonStipple);
    }
    
    @Override
    public void glGetPolygonStipple(final long n) {
        this.checkPackPBOBound(true);
        final long addressof_glGetPolygonStipple = this._pat._addressof_glGetPolygonStipple;
        if (addressof_glGetPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPolygonStipple"));
        }
        this.dispatch_glGetPolygonStipple1(n, addressof_glGetPolygonStipple);
    }
    
    private native void dispatch_glGetPolygonStipple1(final long p0, final long p1);
    
    @Override
    public void glEdgeFlag(final boolean b) {
        final long addressof_glEdgeFlag = this._pat._addressof_glEdgeFlag;
        if (addressof_glEdgeFlag == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlag"));
        }
        this.dispatch_glEdgeFlag1(b, addressof_glEdgeFlag);
    }
    
    private native void dispatch_glEdgeFlag1(final boolean p0, final long p1);
    
    @Override
    public void glEdgeFlagv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glEdgeFlagv = this._pat._addressof_glEdgeFlagv;
        if (addressof_glEdgeFlagv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagv"));
        }
        this.dispatch_glEdgeFlagv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glEdgeFlagv);
    }
    
    private native void dispatch_glEdgeFlagv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glEdgeFlagv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"flag_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glEdgeFlagv = this._pat._addressof_glEdgeFlagv;
        if (addressof_glEdgeFlagv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagv"));
        }
        this.dispatch_glEdgeFlagv1(array, n, false, addressof_glEdgeFlagv);
    }
    
    @Override
    public void glScissor(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glScissor = this._pat._addressof_glScissor;
        if (addressof_glScissor == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScissor"));
        }
        this.dispatch_glScissor1(n, n2, n3, n4, addressof_glScissor);
    }
    
    private native void dispatch_glScissor1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glClipPlane(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glClipPlane = this._pat._addressof_glClipPlane;
        if (addressof_glClipPlane == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClipPlane"));
        }
        this.dispatch_glClipPlane1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glClipPlane);
    }
    
    private native void dispatch_glClipPlane1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glClipPlane(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"equation_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClipPlane = this._pat._addressof_glClipPlane;
        if (addressof_glClipPlane == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClipPlane"));
        }
        this.dispatch_glClipPlane1(n, array, 8 * n2, false, addressof_glClipPlane);
    }
    
    @Override
    public void glGetClipPlane(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetClipPlane = this._pat._addressof_glGetClipPlane;
        if (addressof_glGetClipPlane == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlane"));
        }
        this.dispatch_glGetClipPlane1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetClipPlane);
    }
    
    private native void dispatch_glGetClipPlane1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetClipPlane(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"equation_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetClipPlane = this._pat._addressof_glGetClipPlane;
        if (addressof_glGetClipPlane == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlane"));
        }
        this.dispatch_glGetClipPlane1(n, array, 8 * n2, false, addressof_glGetClipPlane);
    }
    
    @Override
    public void glDrawBuffer(final int n) {
        final long addressof_glDrawBuffer = this._pat._addressof_glDrawBuffer;
        if (addressof_glDrawBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffer"));
        }
        this.dispatch_glDrawBuffer1(n, addressof_glDrawBuffer);
    }
    
    private native void dispatch_glDrawBuffer1(final int p0, final long p1);
    
    @Override
    public void glReadBuffer(final int n) {
        final long addressof_glReadBuffer = this._pat._addressof_glReadBuffer;
        if (addressof_glReadBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glReadBuffer"));
        }
        this.dispatch_glReadBuffer1(n, addressof_glReadBuffer);
    }
    
    private native void dispatch_glReadBuffer1(final int p0, final long p1);
    
    @Override
    public void glEnable(final int n) {
        final long addressof_glEnable = this._pat._addressof_glEnable;
        if (addressof_glEnable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnable"));
        }
        this.dispatch_glEnable1(n, addressof_glEnable);
    }
    
    private native void dispatch_glEnable1(final int p0, final long p1);
    
    @Override
    public void glDisable(final int n) {
        final long addressof_glDisable = this._pat._addressof_glDisable;
        if (addressof_glDisable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisable"));
        }
        this.dispatch_glDisable1(n, addressof_glDisable);
    }
    
    private native void dispatch_glDisable1(final int p0, final long p1);
    
    @Override
    public boolean glIsEnabled(final int n) {
        final long addressof_glIsEnabled = this._pat._addressof_glIsEnabled;
        if (addressof_glIsEnabled == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsEnabled"));
        }
        return this.dispatch_glIsEnabled1(n, addressof_glIsEnabled);
    }
    
    private native boolean dispatch_glIsEnabled1(final int p0, final long p1);
    
    @Override
    public void glGetBooleanv(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetBooleanv = this._pat._addressof_glGetBooleanv;
        if (addressof_glGetBooleanv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
        }
        this.dispatch_glGetBooleanv1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetBooleanv);
    }
    
    private native void dispatch_glGetBooleanv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetBooleanv(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetBooleanv = this._pat._addressof_glGetBooleanv;
        if (addressof_glGetBooleanv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
        }
        this.dispatch_glGetBooleanv1(n, array, n2, false, addressof_glGetBooleanv);
    }
    
    @Override
    public void glGetDoublev(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetDoublev = this._pat._addressof_glGetDoublev;
        if (addressof_glGetDoublev == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoublev"));
        }
        this.dispatch_glGetDoublev1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetDoublev);
    }
    
    private native void dispatch_glGetDoublev1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetDoublev(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetDoublev = this._pat._addressof_glGetDoublev;
        if (addressof_glGetDoublev == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoublev"));
        }
        this.dispatch_glGetDoublev1(n, array, 8 * n2, false, addressof_glGetDoublev);
    }
    
    @Override
    public void glGetFloatv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetFloatv = this._pat._addressof_glGetFloatv;
        if (addressof_glGetFloatv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
        }
        this.dispatch_glGetFloatv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetFloatv);
    }
    
    private native void dispatch_glGetFloatv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetFloatv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFloatv = this._pat._addressof_glGetFloatv;
        if (addressof_glGetFloatv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
        }
        this.dispatch_glGetFloatv1(n, array, 4 * n2, false, addressof_glGetFloatv);
    }
    
    @Override
    public void glGetIntegerv(final int n, final IntBuffer intBuffer) {
        if (this.glStateTracker.getInt(n, intBuffer, 0)) {
            return;
        }
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetIntegerv = this._pat._addressof_glGetIntegerv;
        if (addressof_glGetIntegerv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
        }
        this.dispatch_glGetIntegerv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetIntegerv);
    }
    
    private native void dispatch_glGetIntegerv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetIntegerv(final int n, final int[] array, final int n2) {
        if (this.glStateTracker.getInt(n, array, n2)) {
            return;
        }
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetIntegerv = this._pat._addressof_glGetIntegerv;
        if (addressof_glGetIntegerv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
        }
        this.dispatch_glGetIntegerv1(n, array, 4 * n2, false, addressof_glGetIntegerv);
    }
    
    @Override
    public void glPushAttrib(final int n) {
        final long addressof_glPushAttrib = this._pat._addressof_glPushAttrib;
        if (addressof_glPushAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPushAttrib"));
        }
        this.dispatch_glPushAttrib1(n, addressof_glPushAttrib);
    }
    
    private native void dispatch_glPushAttrib1(final int p0, final long p1);
    
    @Override
    public void glPopAttrib() {
        final long addressof_glPopAttrib = this._pat._addressof_glPopAttrib;
        if (addressof_glPopAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPopAttrib"));
        }
        this.dispatch_glPopAttrib1(addressof_glPopAttrib);
    }
    
    private native void dispatch_glPopAttrib1(final long p0);
    
    @Override
    public int glRenderMode(final int n) {
        final long addressof_glRenderMode = this._pat._addressof_glRenderMode;
        if (addressof_glRenderMode == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRenderMode"));
        }
        return this.dispatch_glRenderMode1(n, addressof_glRenderMode);
    }
    
    private native int dispatch_glRenderMode1(final int p0, final long p1);
    
    @Override
    public int glGetError() {
        final long addressof_glGetError = this._pat._addressof_glGetError;
        if (addressof_glGetError == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetError"));
        }
        return this.dispatch_glGetError1(addressof_glGetError);
    }
    
    private native int dispatch_glGetError1(final long p0);
    
    @Override
    public String glGetString(final int n) {
        if (this._context.isExtensionCacheInitialized() && 7939 == n) {
            return this._context.getGLExtensionsString();
        }
        final long addressof_glGetString = this._pat._addressof_glGetString;
        if (addressof_glGetString == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetString"));
        }
        return this.dispatch_glGetString1(n, addressof_glGetString);
    }
    
    private native String dispatch_glGetString1(final int p0, final long p1);
    
    @Override
    public void glFinish() {
        final long addressof_glFinish = this._pat._addressof_glFinish;
        if (addressof_glFinish == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFinish"));
        }
        this.dispatch_glFinish1(addressof_glFinish);
    }
    
    private native void dispatch_glFinish1(final long p0);
    
    @Override
    public void glFlush() {
        final long addressof_glFlush = this._pat._addressof_glFlush;
        if (addressof_glFlush == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFlush"));
        }
        this.dispatch_glFlush1(addressof_glFlush);
    }
    
    private native void dispatch_glFlush1(final long p0);
    
    @Override
    public void glHint(final int n, final int n2) {
        final long addressof_glHint = this._pat._addressof_glHint;
        if (addressof_glHint == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glHint"));
        }
        this.dispatch_glHint1(n, n2, addressof_glHint);
    }
    
    private native void dispatch_glHint1(final int p0, final int p1, final long p2);
    
    @Override
    public void glClearDepth(final double n) {
        final long addressof_glClearDepth = this._pat._addressof_glClearDepth;
        if (addressof_glClearDepth == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearDepth"));
        }
        this.dispatch_glClearDepth1(n, addressof_glClearDepth);
    }
    
    private native void dispatch_glClearDepth1(final double p0, final long p1);
    
    @Override
    public void glDepthFunc(final int n) {
        final long addressof_glDepthFunc = this._pat._addressof_glDepthFunc;
        if (addressof_glDepthFunc == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthFunc"));
        }
        this.dispatch_glDepthFunc1(n, addressof_glDepthFunc);
    }
    
    private native void dispatch_glDepthFunc1(final int p0, final long p1);
    
    @Override
    public void glDepthMask(final boolean b) {
        final long addressof_glDepthMask = this._pat._addressof_glDepthMask;
        if (addressof_glDepthMask == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthMask"));
        }
        this.dispatch_glDepthMask1(b, addressof_glDepthMask);
    }
    
    private native void dispatch_glDepthMask1(final boolean p0, final long p1);
    
    @Override
    public void glDepthRange(final double n, final double n2) {
        final long addressof_glDepthRange = this._pat._addressof_glDepthRange;
        if (addressof_glDepthRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthRange"));
        }
        this.dispatch_glDepthRange1(n, n2, addressof_glDepthRange);
    }
    
    private native void dispatch_glDepthRange1(final double p0, final double p1, final long p2);
    
    @Override
    public void glClearAccum(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glClearAccum = this._pat._addressof_glClearAccum;
        if (addressof_glClearAccum == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearAccum"));
        }
        this.dispatch_glClearAccum1(n, n2, n3, n4, addressof_glClearAccum);
    }
    
    private native void dispatch_glClearAccum1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glAccum(final int n, final float n2) {
        final long addressof_glAccum = this._pat._addressof_glAccum;
        if (addressof_glAccum == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glAccum"));
        }
        this.dispatch_glAccum1(n, n2, addressof_glAccum);
    }
    
    private native void dispatch_glAccum1(final int p0, final float p1, final long p2);
    
    @Override
    public void glMatrixMode(final int n) {
        final long addressof_glMatrixMode = this._pat._addressof_glMatrixMode;
        if (addressof_glMatrixMode == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMode"));
        }
        this.dispatch_glMatrixMode1(n, addressof_glMatrixMode);
    }
    
    private native void dispatch_glMatrixMode1(final int p0, final long p1);
    
    @Override
    public void glOrtho(final double n, final double n2, final double n3, final double n4, final double n5, final double n6) {
        final long addressof_glOrtho = this._pat._addressof_glOrtho;
        if (addressof_glOrtho == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glOrtho"));
        }
        this.dispatch_glOrtho1(n, n2, n3, n4, n5, n6, addressof_glOrtho);
    }
    
    private native void dispatch_glOrtho1(final double p0, final double p1, final double p2, final double p3, final double p4, final double p5, final long p6);
    
    @Override
    public void glFrustum(final double n, final double n2, final double n3, final double n4, final double n5, final double n6) {
        final long addressof_glFrustum = this._pat._addressof_glFrustum;
        if (addressof_glFrustum == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFrustum"));
        }
        this.dispatch_glFrustum1(n, n2, n3, n4, n5, n6, addressof_glFrustum);
    }
    
    private native void dispatch_glFrustum1(final double p0, final double p1, final double p2, final double p3, final double p4, final double p5, final long p6);
    
    @Override
    public void glViewport(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glViewport = this._pat._addressof_glViewport;
        if (addressof_glViewport == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glViewport"));
        }
        this.dispatch_glViewport1(n, n2, n3, n4, addressof_glViewport);
    }
    
    private native void dispatch_glViewport1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glPushMatrix() {
        final long addressof_glPushMatrix = this._pat._addressof_glPushMatrix;
        if (addressof_glPushMatrix == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPushMatrix"));
        }
        this.dispatch_glPushMatrix1(addressof_glPushMatrix);
    }
    
    private native void dispatch_glPushMatrix1(final long p0);
    
    @Override
    public void glPopMatrix() {
        final long addressof_glPopMatrix = this._pat._addressof_glPopMatrix;
        if (addressof_glPopMatrix == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPopMatrix"));
        }
        this.dispatch_glPopMatrix1(addressof_glPopMatrix);
    }
    
    private native void dispatch_glPopMatrix1(final long p0);
    
    @Override
    public void glLoadIdentity() {
        final long addressof_glLoadIdentity = this._pat._addressof_glLoadIdentity;
        if (addressof_glLoadIdentity == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadIdentity"));
        }
        this.dispatch_glLoadIdentity1(addressof_glLoadIdentity);
    }
    
    private native void dispatch_glLoadIdentity1(final long p0);
    
    @Override
    public void glLoadMatrixd(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glLoadMatrixd = this._pat._addressof_glLoadMatrixd;
        if (addressof_glLoadMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixd"));
        }
        this.dispatch_glLoadMatrixd1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glLoadMatrixd);
    }
    
    private native void dispatch_glLoadMatrixd1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glLoadMatrixd(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLoadMatrixd = this._pat._addressof_glLoadMatrixd;
        if (addressof_glLoadMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixd"));
        }
        this.dispatch_glLoadMatrixd1(array, 8 * n, false, addressof_glLoadMatrixd);
    }
    
    @Override
    public void glLoadMatrixf(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glLoadMatrixf = this._pat._addressof_glLoadMatrixf;
        if (addressof_glLoadMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixf"));
        }
        this.dispatch_glLoadMatrixf1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glLoadMatrixf);
    }
    
    private native void dispatch_glLoadMatrixf1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glLoadMatrixf(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLoadMatrixf = this._pat._addressof_glLoadMatrixf;
        if (addressof_glLoadMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixf"));
        }
        this.dispatch_glLoadMatrixf1(array, 4 * n, false, addressof_glLoadMatrixf);
    }
    
    @Override
    public void glMultMatrixd(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMultMatrixd = this._pat._addressof_glMultMatrixd;
        if (addressof_glMultMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixd"));
        }
        this.dispatch_glMultMatrixd1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMultMatrixd);
    }
    
    private native void dispatch_glMultMatrixd1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glMultMatrixd(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultMatrixd = this._pat._addressof_glMultMatrixd;
        if (addressof_glMultMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixd"));
        }
        this.dispatch_glMultMatrixd1(array, 8 * n, false, addressof_glMultMatrixd);
    }
    
    @Override
    public void glMultMatrixf(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultMatrixf = this._pat._addressof_glMultMatrixf;
        if (addressof_glMultMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixf"));
        }
        this.dispatch_glMultMatrixf1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultMatrixf);
    }
    
    private native void dispatch_glMultMatrixf1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glMultMatrixf(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultMatrixf = this._pat._addressof_glMultMatrixf;
        if (addressof_glMultMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixf"));
        }
        this.dispatch_glMultMatrixf1(array, 4 * n, false, addressof_glMultMatrixf);
    }
    
    @Override
    public void glRotated(final double n, final double n2, final double n3, final double n4) {
        final long addressof_glRotated = this._pat._addressof_glRotated;
        if (addressof_glRotated == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRotated"));
        }
        this.dispatch_glRotated1(n, n2, n3, n4, addressof_glRotated);
    }
    
    private native void dispatch_glRotated1(final double p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glRotatef(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glRotatef = this._pat._addressof_glRotatef;
        if (addressof_glRotatef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRotatef"));
        }
        this.dispatch_glRotatef1(n, n2, n3, n4, addressof_glRotatef);
    }
    
    private native void dispatch_glRotatef1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glScaled(final double n, final double n2, final double n3) {
        final long addressof_glScaled = this._pat._addressof_glScaled;
        if (addressof_glScaled == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScaled"));
        }
        this.dispatch_glScaled1(n, n2, n3, addressof_glScaled);
    }
    
    private native void dispatch_glScaled1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glScalef(final float n, final float n2, final float n3) {
        final long addressof_glScalef = this._pat._addressof_glScalef;
        if (addressof_glScalef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScalef"));
        }
        this.dispatch_glScalef1(n, n2, n3, addressof_glScalef);
    }
    
    private native void dispatch_glScalef1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glTranslated(final double n, final double n2, final double n3) {
        final long addressof_glTranslated = this._pat._addressof_glTranslated;
        if (addressof_glTranslated == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTranslated"));
        }
        this.dispatch_glTranslated1(n, n2, n3, addressof_glTranslated);
    }
    
    private native void dispatch_glTranslated1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glTranslatef(final float n, final float n2, final float n3) {
        final long addressof_glTranslatef = this._pat._addressof_glTranslatef;
        if (addressof_glTranslatef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTranslatef"));
        }
        this.dispatch_glTranslatef1(n, n2, n3, addressof_glTranslatef);
    }
    
    private native void dispatch_glTranslatef1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public boolean glIsList(final int n) {
        final long addressof_glIsList = this._pat._addressof_glIsList;
        if (addressof_glIsList == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsList"));
        }
        return this.dispatch_glIsList1(n, addressof_glIsList);
    }
    
    private native boolean dispatch_glIsList1(final int p0, final long p1);
    
    @Override
    public void glDeleteLists(final int n, final int n2) {
        final long addressof_glDeleteLists = this._pat._addressof_glDeleteLists;
        if (addressof_glDeleteLists == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteLists"));
        }
        this.dispatch_glDeleteLists1(n, n2, addressof_glDeleteLists);
    }
    
    private native void dispatch_glDeleteLists1(final int p0, final int p1, final long p2);
    
    @Override
    public int glGenLists(final int n) {
        final long addressof_glGenLists = this._pat._addressof_glGenLists;
        if (addressof_glGenLists == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenLists"));
        }
        return this.dispatch_glGenLists1(n, addressof_glGenLists);
    }
    
    private native int dispatch_glGenLists1(final int p0, final long p1);
    
    @Override
    public void glNewList(final int n, final int n2) {
        final long addressof_glNewList = this._pat._addressof_glNewList;
        if (addressof_glNewList == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNewList"));
        }
        this.dispatch_glNewList1(n, n2, addressof_glNewList);
    }
    
    private native void dispatch_glNewList1(final int p0, final int p1, final long p2);
    
    @Override
    public void glEndList() {
        final long addressof_glEndList = this._pat._addressof_glEndList;
        if (addressof_glEndList == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndList"));
        }
        this.dispatch_glEndList1(addressof_glEndList);
    }
    
    private native void dispatch_glEndList1(final long p0);
    
    @Override
    public void glCallList(final int n) {
        final long addressof_glCallList = this._pat._addressof_glCallList;
        if (addressof_glCallList == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCallList"));
        }
        this.dispatch_glCallList1(n, addressof_glCallList);
    }
    
    private native void dispatch_glCallList1(final int p0, final long p1);
    
    @Override
    public void glCallLists(final int n, final int n2, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCallLists = this._pat._addressof_glCallLists;
        if (addressof_glCallLists == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCallLists"));
        }
        this.dispatch_glCallLists1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCallLists);
    }
    
    private native void dispatch_glCallLists1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glListBase(final int n) {
        final long addressof_glListBase = this._pat._addressof_glListBase;
        if (addressof_glListBase == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glListBase"));
        }
        this.dispatch_glListBase1(n, addressof_glListBase);
    }
    
    private native void dispatch_glListBase1(final int p0, final long p1);
    
    @Override
    public void glBegin(final int n) {
        this.inBeginEndPair = true;
        final long addressof_glBegin = this._pat._addressof_glBegin;
        if (addressof_glBegin == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBegin"));
        }
        this.dispatch_glBegin1(n, addressof_glBegin);
    }
    
    private native void dispatch_glBegin1(final int p0, final long p1);
    
    @Override
    public void glEnd() {
        final long addressof_glEnd = this._pat._addressof_glEnd;
        if (addressof_glEnd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnd"));
        }
        this.dispatch_glEnd1(addressof_glEnd);
        this.inBeginEndPair = false;
    }
    
    private native void dispatch_glEnd1(final long p0);
    
    @Override
    public void glVertex2d(final double n, final double n2) {
        final long addressof_glVertex2d = this._pat._addressof_glVertex2d;
        if (addressof_glVertex2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2d"));
        }
        this.dispatch_glVertex2d1(n, n2, addressof_glVertex2d);
    }
    
    private native void dispatch_glVertex2d1(final double p0, final double p1, final long p2);
    
    @Override
    public void glVertex2f(final float n, final float n2) {
        final long addressof_glVertex2f = this._pat._addressof_glVertex2f;
        if (addressof_glVertex2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2f"));
        }
        this.dispatch_glVertex2f1(n, n2, addressof_glVertex2f);
    }
    
    private native void dispatch_glVertex2f1(final float p0, final float p1, final long p2);
    
    @Override
    public void glVertex2i(final int n, final int n2) {
        final long addressof_glVertex2i = this._pat._addressof_glVertex2i;
        if (addressof_glVertex2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2i"));
        }
        this.dispatch_glVertex2i1(n, n2, addressof_glVertex2i);
    }
    
    private native void dispatch_glVertex2i1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertex2s(final short n, final short n2) {
        final long addressof_glVertex2s = this._pat._addressof_glVertex2s;
        if (addressof_glVertex2s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2s"));
        }
        this.dispatch_glVertex2s1(n, n2, addressof_glVertex2s);
    }
    
    private native void dispatch_glVertex2s1(final short p0, final short p1, final long p2);
    
    @Override
    public void glVertex3d(final double n, final double n2, final double n3) {
        final long addressof_glVertex3d = this._pat._addressof_glVertex3d;
        if (addressof_glVertex3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3d"));
        }
        this.dispatch_glVertex3d1(n, n2, n3, addressof_glVertex3d);
    }
    
    private native void dispatch_glVertex3d1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glVertex3f(final float n, final float n2, final float n3) {
        final long addressof_glVertex3f = this._pat._addressof_glVertex3f;
        if (addressof_glVertex3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3f"));
        }
        this.dispatch_glVertex3f1(n, n2, n3, addressof_glVertex3f);
    }
    
    private native void dispatch_glVertex3f1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glVertex3i(final int n, final int n2, final int n3) {
        final long addressof_glVertex3i = this._pat._addressof_glVertex3i;
        if (addressof_glVertex3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3i"));
        }
        this.dispatch_glVertex3i1(n, n2, n3, addressof_glVertex3i);
    }
    
    private native void dispatch_glVertex3i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertex3s(final short n, final short n2, final short n3) {
        final long addressof_glVertex3s = this._pat._addressof_glVertex3s;
        if (addressof_glVertex3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3s"));
        }
        this.dispatch_glVertex3s1(n, n2, n3, addressof_glVertex3s);
    }
    
    private native void dispatch_glVertex3s1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glVertex4d(final double n, final double n2, final double n3, final double n4) {
        final long addressof_glVertex4d = this._pat._addressof_glVertex4d;
        if (addressof_glVertex4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4d"));
        }
        this.dispatch_glVertex4d1(n, n2, n3, n4, addressof_glVertex4d);
    }
    
    private native void dispatch_glVertex4d1(final double p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glVertex4f(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glVertex4f = this._pat._addressof_glVertex4f;
        if (addressof_glVertex4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4f"));
        }
        this.dispatch_glVertex4f1(n, n2, n3, n4, addressof_glVertex4f);
    }
    
    private native void dispatch_glVertex4f1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glVertex4i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertex4i = this._pat._addressof_glVertex4i;
        if (addressof_glVertex4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4i"));
        }
        this.dispatch_glVertex4i1(n, n2, n3, n4, addressof_glVertex4i);
    }
    
    private native void dispatch_glVertex4i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glVertex4s(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glVertex4s = this._pat._addressof_glVertex4s;
        if (addressof_glVertex4s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4s"));
        }
        this.dispatch_glVertex4s1(n, n2, n3, n4, addressof_glVertex4s);
    }
    
    private native void dispatch_glVertex4s1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glVertex2dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertex2dv = this._pat._addressof_glVertex2dv;
        if (addressof_glVertex2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2dv"));
        }
        this.dispatch_glVertex2dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertex2dv);
    }
    
    private native void dispatch_glVertex2dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex2dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex2dv = this._pat._addressof_glVertex2dv;
        if (addressof_glVertex2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2dv"));
        }
        this.dispatch_glVertex2dv1(array, 8 * n, false, addressof_glVertex2dv);
    }
    
    @Override
    public void glVertex2fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertex2fv = this._pat._addressof_glVertex2fv;
        if (addressof_glVertex2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2fv"));
        }
        this.dispatch_glVertex2fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertex2fv);
    }
    
    private native void dispatch_glVertex2fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex2fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex2fv = this._pat._addressof_glVertex2fv;
        if (addressof_glVertex2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2fv"));
        }
        this.dispatch_glVertex2fv1(array, 4 * n, false, addressof_glVertex2fv);
    }
    
    @Override
    public void glVertex2iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertex2iv = this._pat._addressof_glVertex2iv;
        if (addressof_glVertex2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2iv"));
        }
        this.dispatch_glVertex2iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertex2iv);
    }
    
    private native void dispatch_glVertex2iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex2iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex2iv = this._pat._addressof_glVertex2iv;
        if (addressof_glVertex2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2iv"));
        }
        this.dispatch_glVertex2iv1(array, 4 * n, false, addressof_glVertex2iv);
    }
    
    @Override
    public void glVertex2sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertex2sv = this._pat._addressof_glVertex2sv;
        if (addressof_glVertex2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2sv"));
        }
        this.dispatch_glVertex2sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertex2sv);
    }
    
    private native void dispatch_glVertex2sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex2sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex2sv = this._pat._addressof_glVertex2sv;
        if (addressof_glVertex2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2sv"));
        }
        this.dispatch_glVertex2sv1(array, 2 * n, false, addressof_glVertex2sv);
    }
    
    @Override
    public void glVertex3dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertex3dv = this._pat._addressof_glVertex3dv;
        if (addressof_glVertex3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3dv"));
        }
        this.dispatch_glVertex3dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertex3dv);
    }
    
    private native void dispatch_glVertex3dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex3dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex3dv = this._pat._addressof_glVertex3dv;
        if (addressof_glVertex3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3dv"));
        }
        this.dispatch_glVertex3dv1(array, 8 * n, false, addressof_glVertex3dv);
    }
    
    @Override
    public void glVertex3fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertex3fv = this._pat._addressof_glVertex3fv;
        if (addressof_glVertex3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3fv"));
        }
        this.dispatch_glVertex3fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertex3fv);
    }
    
    private native void dispatch_glVertex3fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex3fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex3fv = this._pat._addressof_glVertex3fv;
        if (addressof_glVertex3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3fv"));
        }
        this.dispatch_glVertex3fv1(array, 4 * n, false, addressof_glVertex3fv);
    }
    
    @Override
    public void glVertex3iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertex3iv = this._pat._addressof_glVertex3iv;
        if (addressof_glVertex3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3iv"));
        }
        this.dispatch_glVertex3iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertex3iv);
    }
    
    private native void dispatch_glVertex3iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex3iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex3iv = this._pat._addressof_glVertex3iv;
        if (addressof_glVertex3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3iv"));
        }
        this.dispatch_glVertex3iv1(array, 4 * n, false, addressof_glVertex3iv);
    }
    
    @Override
    public void glVertex3sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertex3sv = this._pat._addressof_glVertex3sv;
        if (addressof_glVertex3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3sv"));
        }
        this.dispatch_glVertex3sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertex3sv);
    }
    
    private native void dispatch_glVertex3sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex3sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex3sv = this._pat._addressof_glVertex3sv;
        if (addressof_glVertex3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3sv"));
        }
        this.dispatch_glVertex3sv1(array, 2 * n, false, addressof_glVertex3sv);
    }
    
    @Override
    public void glVertex4dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertex4dv = this._pat._addressof_glVertex4dv;
        if (addressof_glVertex4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4dv"));
        }
        this.dispatch_glVertex4dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertex4dv);
    }
    
    private native void dispatch_glVertex4dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex4dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex4dv = this._pat._addressof_glVertex4dv;
        if (addressof_glVertex4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4dv"));
        }
        this.dispatch_glVertex4dv1(array, 8 * n, false, addressof_glVertex4dv);
    }
    
    @Override
    public void glVertex4fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertex4fv = this._pat._addressof_glVertex4fv;
        if (addressof_glVertex4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4fv"));
        }
        this.dispatch_glVertex4fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertex4fv);
    }
    
    private native void dispatch_glVertex4fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex4fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex4fv = this._pat._addressof_glVertex4fv;
        if (addressof_glVertex4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4fv"));
        }
        this.dispatch_glVertex4fv1(array, 4 * n, false, addressof_glVertex4fv);
    }
    
    @Override
    public void glVertex4iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertex4iv = this._pat._addressof_glVertex4iv;
        if (addressof_glVertex4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4iv"));
        }
        this.dispatch_glVertex4iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertex4iv);
    }
    
    private native void dispatch_glVertex4iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex4iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex4iv = this._pat._addressof_glVertex4iv;
        if (addressof_glVertex4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4iv"));
        }
        this.dispatch_glVertex4iv1(array, 4 * n, false, addressof_glVertex4iv);
    }
    
    @Override
    public void glVertex4sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertex4sv = this._pat._addressof_glVertex4sv;
        if (addressof_glVertex4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4sv"));
        }
        this.dispatch_glVertex4sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertex4sv);
    }
    
    private native void dispatch_glVertex4sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex4sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex4sv = this._pat._addressof_glVertex4sv;
        if (addressof_glVertex4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4sv"));
        }
        this.dispatch_glVertex4sv1(array, 2 * n, false, addressof_glVertex4sv);
    }
    
    @Override
    public void glNormal3b(final byte b, final byte b2, final byte b3) {
        final long addressof_glNormal3b = this._pat._addressof_glNormal3b;
        if (addressof_glNormal3b == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3b"));
        }
        this.dispatch_glNormal3b1(b, b2, b3, addressof_glNormal3b);
    }
    
    private native void dispatch_glNormal3b1(final byte p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glNormal3d(final double n, final double n2, final double n3) {
        final long addressof_glNormal3d = this._pat._addressof_glNormal3d;
        if (addressof_glNormal3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3d"));
        }
        this.dispatch_glNormal3d1(n, n2, n3, addressof_glNormal3d);
    }
    
    private native void dispatch_glNormal3d1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glNormal3f(final float n, final float n2, final float n3) {
        final long addressof_glNormal3f = this._pat._addressof_glNormal3f;
        if (addressof_glNormal3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3f"));
        }
        this.dispatch_glNormal3f1(n, n2, n3, addressof_glNormal3f);
    }
    
    private native void dispatch_glNormal3f1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glNormal3i(final int n, final int n2, final int n3) {
        final long addressof_glNormal3i = this._pat._addressof_glNormal3i;
        if (addressof_glNormal3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3i"));
        }
        this.dispatch_glNormal3i1(n, n2, n3, addressof_glNormal3i);
    }
    
    private native void dispatch_glNormal3i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glNormal3s(final short n, final short n2, final short n3) {
        final long addressof_glNormal3s = this._pat._addressof_glNormal3s;
        if (addressof_glNormal3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3s"));
        }
        this.dispatch_glNormal3s1(n, n2, n3, addressof_glNormal3s);
    }
    
    private native void dispatch_glNormal3s1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glNormal3bv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glNormal3bv = this._pat._addressof_glNormal3bv;
        if (addressof_glNormal3bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3bv"));
        }
        this.dispatch_glNormal3bv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glNormal3bv);
    }
    
    private native void dispatch_glNormal3bv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glNormal3bv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNormal3bv = this._pat._addressof_glNormal3bv;
        if (addressof_glNormal3bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3bv"));
        }
        this.dispatch_glNormal3bv1(array, n, false, addressof_glNormal3bv);
    }
    
    @Override
    public void glNormal3dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glNormal3dv = this._pat._addressof_glNormal3dv;
        if (addressof_glNormal3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3dv"));
        }
        this.dispatch_glNormal3dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glNormal3dv);
    }
    
    private native void dispatch_glNormal3dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glNormal3dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNormal3dv = this._pat._addressof_glNormal3dv;
        if (addressof_glNormal3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3dv"));
        }
        this.dispatch_glNormal3dv1(array, 8 * n, false, addressof_glNormal3dv);
    }
    
    @Override
    public void glNormal3fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glNormal3fv = this._pat._addressof_glNormal3fv;
        if (addressof_glNormal3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3fv"));
        }
        this.dispatch_glNormal3fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glNormal3fv);
    }
    
    private native void dispatch_glNormal3fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glNormal3fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNormal3fv = this._pat._addressof_glNormal3fv;
        if (addressof_glNormal3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3fv"));
        }
        this.dispatch_glNormal3fv1(array, 4 * n, false, addressof_glNormal3fv);
    }
    
    @Override
    public void glNormal3iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glNormal3iv = this._pat._addressof_glNormal3iv;
        if (addressof_glNormal3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3iv"));
        }
        this.dispatch_glNormal3iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glNormal3iv);
    }
    
    private native void dispatch_glNormal3iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glNormal3iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNormal3iv = this._pat._addressof_glNormal3iv;
        if (addressof_glNormal3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3iv"));
        }
        this.dispatch_glNormal3iv1(array, 4 * n, false, addressof_glNormal3iv);
    }
    
    @Override
    public void glNormal3sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glNormal3sv = this._pat._addressof_glNormal3sv;
        if (addressof_glNormal3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3sv"));
        }
        this.dispatch_glNormal3sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glNormal3sv);
    }
    
    private native void dispatch_glNormal3sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glNormal3sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNormal3sv = this._pat._addressof_glNormal3sv;
        if (addressof_glNormal3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3sv"));
        }
        this.dispatch_glNormal3sv1(array, 2 * n, false, addressof_glNormal3sv);
    }
    
    @Override
    public void glIndexd(final double n) {
        final long addressof_glIndexd = this._pat._addressof_glIndexd;
        if (addressof_glIndexd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexd"));
        }
        this.dispatch_glIndexd1(n, addressof_glIndexd);
    }
    
    private native void dispatch_glIndexd1(final double p0, final long p1);
    
    @Override
    public void glIndexf(final float n) {
        final long addressof_glIndexf = this._pat._addressof_glIndexf;
        if (addressof_glIndexf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexf"));
        }
        this.dispatch_glIndexf1(n, addressof_glIndexf);
    }
    
    private native void dispatch_glIndexf1(final float p0, final long p1);
    
    @Override
    public void glIndexi(final int n) {
        final long addressof_glIndexi = this._pat._addressof_glIndexi;
        if (addressof_glIndexi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexi"));
        }
        this.dispatch_glIndexi1(n, addressof_glIndexi);
    }
    
    private native void dispatch_glIndexi1(final int p0, final long p1);
    
    @Override
    public void glIndexs(final short n) {
        final long addressof_glIndexs = this._pat._addressof_glIndexs;
        if (addressof_glIndexs == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexs"));
        }
        this.dispatch_glIndexs1(n, addressof_glIndexs);
    }
    
    private native void dispatch_glIndexs1(final short p0, final long p1);
    
    @Override
    public void glIndexdv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glIndexdv = this._pat._addressof_glIndexdv;
        if (addressof_glIndexdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexdv"));
        }
        this.dispatch_glIndexdv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glIndexdv);
    }
    
    private native void dispatch_glIndexdv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glIndexdv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"c_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glIndexdv = this._pat._addressof_glIndexdv;
        if (addressof_glIndexdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexdv"));
        }
        this.dispatch_glIndexdv1(array, 8 * n, false, addressof_glIndexdv);
    }
    
    @Override
    public void glIndexfv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glIndexfv = this._pat._addressof_glIndexfv;
        if (addressof_glIndexfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexfv"));
        }
        this.dispatch_glIndexfv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glIndexfv);
    }
    
    private native void dispatch_glIndexfv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glIndexfv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"c_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glIndexfv = this._pat._addressof_glIndexfv;
        if (addressof_glIndexfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexfv"));
        }
        this.dispatch_glIndexfv1(array, 4 * n, false, addressof_glIndexfv);
    }
    
    @Override
    public void glIndexiv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glIndexiv = this._pat._addressof_glIndexiv;
        if (addressof_glIndexiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexiv"));
        }
        this.dispatch_glIndexiv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glIndexiv);
    }
    
    private native void dispatch_glIndexiv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glIndexiv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"c_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glIndexiv = this._pat._addressof_glIndexiv;
        if (addressof_glIndexiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexiv"));
        }
        this.dispatch_glIndexiv1(array, 4 * n, false, addressof_glIndexiv);
    }
    
    @Override
    public void glIndexsv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glIndexsv = this._pat._addressof_glIndexsv;
        if (addressof_glIndexsv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexsv"));
        }
        this.dispatch_glIndexsv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glIndexsv);
    }
    
    private native void dispatch_glIndexsv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glIndexsv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"c_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glIndexsv = this._pat._addressof_glIndexsv;
        if (addressof_glIndexsv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexsv"));
        }
        this.dispatch_glIndexsv1(array, 2 * n, false, addressof_glIndexsv);
    }
    
    @Override
    public void glColor3b(final byte b, final byte b2, final byte b3) {
        final long addressof_glColor3b = this._pat._addressof_glColor3b;
        if (addressof_glColor3b == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3b"));
        }
        this.dispatch_glColor3b1(b, b2, b3, addressof_glColor3b);
    }
    
    private native void dispatch_glColor3b1(final byte p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glColor3d(final double n, final double n2, final double n3) {
        final long addressof_glColor3d = this._pat._addressof_glColor3d;
        if (addressof_glColor3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3d"));
        }
        this.dispatch_glColor3d1(n, n2, n3, addressof_glColor3d);
    }
    
    private native void dispatch_glColor3d1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glColor3f(final float n, final float n2, final float n3) {
        final long addressof_glColor3f = this._pat._addressof_glColor3f;
        if (addressof_glColor3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3f"));
        }
        this.dispatch_glColor3f1(n, n2, n3, addressof_glColor3f);
    }
    
    private native void dispatch_glColor3f1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glColor3i(final int n, final int n2, final int n3) {
        final long addressof_glColor3i = this._pat._addressof_glColor3i;
        if (addressof_glColor3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3i"));
        }
        this.dispatch_glColor3i1(n, n2, n3, addressof_glColor3i);
    }
    
    private native void dispatch_glColor3i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glColor3s(final short n, final short n2, final short n3) {
        final long addressof_glColor3s = this._pat._addressof_glColor3s;
        if (addressof_glColor3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3s"));
        }
        this.dispatch_glColor3s1(n, n2, n3, addressof_glColor3s);
    }
    
    private native void dispatch_glColor3s1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glColor3ub(final byte b, final byte b2, final byte b3) {
        final long addressof_glColor3ub = this._pat._addressof_glColor3ub;
        if (addressof_glColor3ub == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3ub"));
        }
        this.dispatch_glColor3ub1(b, b2, b3, addressof_glColor3ub);
    }
    
    private native void dispatch_glColor3ub1(final byte p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glColor3ui(final int n, final int n2, final int n3) {
        final long addressof_glColor3ui = this._pat._addressof_glColor3ui;
        if (addressof_glColor3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3ui"));
        }
        this.dispatch_glColor3ui1(n, n2, n3, addressof_glColor3ui);
    }
    
    private native void dispatch_glColor3ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glColor3us(final short n, final short n2, final short n3) {
        final long addressof_glColor3us = this._pat._addressof_glColor3us;
        if (addressof_glColor3us == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3us"));
        }
        this.dispatch_glColor3us1(n, n2, n3, addressof_glColor3us);
    }
    
    private native void dispatch_glColor3us1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glColor4b(final byte b, final byte b2, final byte b3, final byte b4) {
        final long addressof_glColor4b = this._pat._addressof_glColor4b;
        if (addressof_glColor4b == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4b"));
        }
        this.dispatch_glColor4b1(b, b2, b3, b4, addressof_glColor4b);
    }
    
    private native void dispatch_glColor4b1(final byte p0, final byte p1, final byte p2, final byte p3, final long p4);
    
    @Override
    public void glColor4d(final double n, final double n2, final double n3, final double n4) {
        final long addressof_glColor4d = this._pat._addressof_glColor4d;
        if (addressof_glColor4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4d"));
        }
        this.dispatch_glColor4d1(n, n2, n3, n4, addressof_glColor4d);
    }
    
    private native void dispatch_glColor4d1(final double p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glColor4f(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glColor4f = this._pat._addressof_glColor4f;
        if (addressof_glColor4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4f"));
        }
        this.dispatch_glColor4f1(n, n2, n3, n4, addressof_glColor4f);
    }
    
    private native void dispatch_glColor4f1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glColor4i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glColor4i = this._pat._addressof_glColor4i;
        if (addressof_glColor4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4i"));
        }
        this.dispatch_glColor4i1(n, n2, n3, n4, addressof_glColor4i);
    }
    
    private native void dispatch_glColor4i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glColor4s(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glColor4s = this._pat._addressof_glColor4s;
        if (addressof_glColor4s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4s"));
        }
        this.dispatch_glColor4s1(n, n2, n3, n4, addressof_glColor4s);
    }
    
    private native void dispatch_glColor4s1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glColor4ub(final byte b, final byte b2, final byte b3, final byte b4) {
        final long addressof_glColor4ub = this._pat._addressof_glColor4ub;
        if (addressof_glColor4ub == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4ub"));
        }
        this.dispatch_glColor4ub1(b, b2, b3, b4, addressof_glColor4ub);
    }
    
    private native void dispatch_glColor4ub1(final byte p0, final byte p1, final byte p2, final byte p3, final long p4);
    
    @Override
    public void glColor4ui(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glColor4ui = this._pat._addressof_glColor4ui;
        if (addressof_glColor4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4ui"));
        }
        this.dispatch_glColor4ui1(n, n2, n3, n4, addressof_glColor4ui);
    }
    
    private native void dispatch_glColor4ui1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glColor4us(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glColor4us = this._pat._addressof_glColor4us;
        if (addressof_glColor4us == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4us"));
        }
        this.dispatch_glColor4us1(n, n2, n3, n4, addressof_glColor4us);
    }
    
    private native void dispatch_glColor4us1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glColor3bv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glColor3bv = this._pat._addressof_glColor3bv;
        if (addressof_glColor3bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3bv"));
        }
        this.dispatch_glColor3bv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glColor3bv);
    }
    
    private native void dispatch_glColor3bv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3bv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3bv = this._pat._addressof_glColor3bv;
        if (addressof_glColor3bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3bv"));
        }
        this.dispatch_glColor3bv1(array, n, false, addressof_glColor3bv);
    }
    
    @Override
    public void glColor3dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glColor3dv = this._pat._addressof_glColor3dv;
        if (addressof_glColor3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3dv"));
        }
        this.dispatch_glColor3dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glColor3dv);
    }
    
    private native void dispatch_glColor3dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3dv = this._pat._addressof_glColor3dv;
        if (addressof_glColor3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3dv"));
        }
        this.dispatch_glColor3dv1(array, 8 * n, false, addressof_glColor3dv);
    }
    
    @Override
    public void glColor3fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glColor3fv = this._pat._addressof_glColor3fv;
        if (addressof_glColor3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3fv"));
        }
        this.dispatch_glColor3fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glColor3fv);
    }
    
    private native void dispatch_glColor3fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3fv = this._pat._addressof_glColor3fv;
        if (addressof_glColor3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3fv"));
        }
        this.dispatch_glColor3fv1(array, 4 * n, false, addressof_glColor3fv);
    }
    
    @Override
    public void glColor3iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glColor3iv = this._pat._addressof_glColor3iv;
        if (addressof_glColor3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3iv"));
        }
        this.dispatch_glColor3iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glColor3iv);
    }
    
    private native void dispatch_glColor3iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3iv = this._pat._addressof_glColor3iv;
        if (addressof_glColor3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3iv"));
        }
        this.dispatch_glColor3iv1(array, 4 * n, false, addressof_glColor3iv);
    }
    
    @Override
    public void glColor3sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glColor3sv = this._pat._addressof_glColor3sv;
        if (addressof_glColor3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3sv"));
        }
        this.dispatch_glColor3sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glColor3sv);
    }
    
    private native void dispatch_glColor3sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3sv = this._pat._addressof_glColor3sv;
        if (addressof_glColor3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3sv"));
        }
        this.dispatch_glColor3sv1(array, 2 * n, false, addressof_glColor3sv);
    }
    
    @Override
    public void glColor3ubv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glColor3ubv = this._pat._addressof_glColor3ubv;
        if (addressof_glColor3ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3ubv"));
        }
        this.dispatch_glColor3ubv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glColor3ubv);
    }
    
    private native void dispatch_glColor3ubv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3ubv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3ubv = this._pat._addressof_glColor3ubv;
        if (addressof_glColor3ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3ubv"));
        }
        this.dispatch_glColor3ubv1(array, n, false, addressof_glColor3ubv);
    }
    
    @Override
    public void glColor3uiv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glColor3uiv = this._pat._addressof_glColor3uiv;
        if (addressof_glColor3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3uiv"));
        }
        this.dispatch_glColor3uiv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glColor3uiv);
    }
    
    private native void dispatch_glColor3uiv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3uiv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3uiv = this._pat._addressof_glColor3uiv;
        if (addressof_glColor3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3uiv"));
        }
        this.dispatch_glColor3uiv1(array, 4 * n, false, addressof_glColor3uiv);
    }
    
    @Override
    public void glColor3usv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glColor3usv = this._pat._addressof_glColor3usv;
        if (addressof_glColor3usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3usv"));
        }
        this.dispatch_glColor3usv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glColor3usv);
    }
    
    private native void dispatch_glColor3usv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3usv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3usv = this._pat._addressof_glColor3usv;
        if (addressof_glColor3usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3usv"));
        }
        this.dispatch_glColor3usv1(array, 2 * n, false, addressof_glColor3usv);
    }
    
    @Override
    public void glColor4bv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glColor4bv = this._pat._addressof_glColor4bv;
        if (addressof_glColor4bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4bv"));
        }
        this.dispatch_glColor4bv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glColor4bv);
    }
    
    private native void dispatch_glColor4bv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4bv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4bv = this._pat._addressof_glColor4bv;
        if (addressof_glColor4bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4bv"));
        }
        this.dispatch_glColor4bv1(array, n, false, addressof_glColor4bv);
    }
    
    @Override
    public void glColor4dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glColor4dv = this._pat._addressof_glColor4dv;
        if (addressof_glColor4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4dv"));
        }
        this.dispatch_glColor4dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glColor4dv);
    }
    
    private native void dispatch_glColor4dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4dv = this._pat._addressof_glColor4dv;
        if (addressof_glColor4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4dv"));
        }
        this.dispatch_glColor4dv1(array, 8 * n, false, addressof_glColor4dv);
    }
    
    @Override
    public void glColor4fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glColor4fv = this._pat._addressof_glColor4fv;
        if (addressof_glColor4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4fv"));
        }
        this.dispatch_glColor4fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glColor4fv);
    }
    
    private native void dispatch_glColor4fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4fv = this._pat._addressof_glColor4fv;
        if (addressof_glColor4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4fv"));
        }
        this.dispatch_glColor4fv1(array, 4 * n, false, addressof_glColor4fv);
    }
    
    @Override
    public void glColor4iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glColor4iv = this._pat._addressof_glColor4iv;
        if (addressof_glColor4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4iv"));
        }
        this.dispatch_glColor4iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glColor4iv);
    }
    
    private native void dispatch_glColor4iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4iv = this._pat._addressof_glColor4iv;
        if (addressof_glColor4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4iv"));
        }
        this.dispatch_glColor4iv1(array, 4 * n, false, addressof_glColor4iv);
    }
    
    @Override
    public void glColor4sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glColor4sv = this._pat._addressof_glColor4sv;
        if (addressof_glColor4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4sv"));
        }
        this.dispatch_glColor4sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glColor4sv);
    }
    
    private native void dispatch_glColor4sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4sv = this._pat._addressof_glColor4sv;
        if (addressof_glColor4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4sv"));
        }
        this.dispatch_glColor4sv1(array, 2 * n, false, addressof_glColor4sv);
    }
    
    @Override
    public void glColor4ubv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glColor4ubv = this._pat._addressof_glColor4ubv;
        if (addressof_glColor4ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4ubv"));
        }
        this.dispatch_glColor4ubv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glColor4ubv);
    }
    
    private native void dispatch_glColor4ubv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4ubv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4ubv = this._pat._addressof_glColor4ubv;
        if (addressof_glColor4ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4ubv"));
        }
        this.dispatch_glColor4ubv1(array, n, false, addressof_glColor4ubv);
    }
    
    @Override
    public void glColor4uiv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glColor4uiv = this._pat._addressof_glColor4uiv;
        if (addressof_glColor4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4uiv"));
        }
        this.dispatch_glColor4uiv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glColor4uiv);
    }
    
    private native void dispatch_glColor4uiv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4uiv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4uiv = this._pat._addressof_glColor4uiv;
        if (addressof_glColor4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4uiv"));
        }
        this.dispatch_glColor4uiv1(array, 4 * n, false, addressof_glColor4uiv);
    }
    
    @Override
    public void glColor4usv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glColor4usv = this._pat._addressof_glColor4usv;
        if (addressof_glColor4usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4usv"));
        }
        this.dispatch_glColor4usv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glColor4usv);
    }
    
    private native void dispatch_glColor4usv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4usv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4usv = this._pat._addressof_glColor4usv;
        if (addressof_glColor4usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4usv"));
        }
        this.dispatch_glColor4usv1(array, 2 * n, false, addressof_glColor4usv);
    }
    
    @Override
    public void glTexCoord1d(final double n) {
        final long addressof_glTexCoord1d = this._pat._addressof_glTexCoord1d;
        if (addressof_glTexCoord1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1d"));
        }
        this.dispatch_glTexCoord1d1(n, addressof_glTexCoord1d);
    }
    
    private native void dispatch_glTexCoord1d1(final double p0, final long p1);
    
    @Override
    public void glTexCoord1f(final float n) {
        final long addressof_glTexCoord1f = this._pat._addressof_glTexCoord1f;
        if (addressof_glTexCoord1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1f"));
        }
        this.dispatch_glTexCoord1f1(n, addressof_glTexCoord1f);
    }
    
    private native void dispatch_glTexCoord1f1(final float p0, final long p1);
    
    @Override
    public void glTexCoord1i(final int n) {
        final long addressof_glTexCoord1i = this._pat._addressof_glTexCoord1i;
        if (addressof_glTexCoord1i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1i"));
        }
        this.dispatch_glTexCoord1i1(n, addressof_glTexCoord1i);
    }
    
    private native void dispatch_glTexCoord1i1(final int p0, final long p1);
    
    @Override
    public void glTexCoord1s(final short n) {
        final long addressof_glTexCoord1s = this._pat._addressof_glTexCoord1s;
        if (addressof_glTexCoord1s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1s"));
        }
        this.dispatch_glTexCoord1s1(n, addressof_glTexCoord1s);
    }
    
    private native void dispatch_glTexCoord1s1(final short p0, final long p1);
    
    @Override
    public void glTexCoord2d(final double n, final double n2) {
        final long addressof_glTexCoord2d = this._pat._addressof_glTexCoord2d;
        if (addressof_glTexCoord2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2d"));
        }
        this.dispatch_glTexCoord2d1(n, n2, addressof_glTexCoord2d);
    }
    
    private native void dispatch_glTexCoord2d1(final double p0, final double p1, final long p2);
    
    @Override
    public void glTexCoord2f(final float n, final float n2) {
        final long addressof_glTexCoord2f = this._pat._addressof_glTexCoord2f;
        if (addressof_glTexCoord2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2f"));
        }
        this.dispatch_glTexCoord2f1(n, n2, addressof_glTexCoord2f);
    }
    
    private native void dispatch_glTexCoord2f1(final float p0, final float p1, final long p2);
    
    @Override
    public void glTexCoord2i(final int n, final int n2) {
        final long addressof_glTexCoord2i = this._pat._addressof_glTexCoord2i;
        if (addressof_glTexCoord2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2i"));
        }
        this.dispatch_glTexCoord2i1(n, n2, addressof_glTexCoord2i);
    }
    
    private native void dispatch_glTexCoord2i1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTexCoord2s(final short n, final short n2) {
        final long addressof_glTexCoord2s = this._pat._addressof_glTexCoord2s;
        if (addressof_glTexCoord2s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2s"));
        }
        this.dispatch_glTexCoord2s1(n, n2, addressof_glTexCoord2s);
    }
    
    private native void dispatch_glTexCoord2s1(final short p0, final short p1, final long p2);
    
    @Override
    public void glTexCoord3d(final double n, final double n2, final double n3) {
        final long addressof_glTexCoord3d = this._pat._addressof_glTexCoord3d;
        if (addressof_glTexCoord3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3d"));
        }
        this.dispatch_glTexCoord3d1(n, n2, n3, addressof_glTexCoord3d);
    }
    
    private native void dispatch_glTexCoord3d1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glTexCoord3f(final float n, final float n2, final float n3) {
        final long addressof_glTexCoord3f = this._pat._addressof_glTexCoord3f;
        if (addressof_glTexCoord3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3f"));
        }
        this.dispatch_glTexCoord3f1(n, n2, n3, addressof_glTexCoord3f);
    }
    
    private native void dispatch_glTexCoord3f1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glTexCoord3i(final int n, final int n2, final int n3) {
        final long addressof_glTexCoord3i = this._pat._addressof_glTexCoord3i;
        if (addressof_glTexCoord3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3i"));
        }
        this.dispatch_glTexCoord3i1(n, n2, n3, addressof_glTexCoord3i);
    }
    
    private native void dispatch_glTexCoord3i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTexCoord3s(final short n, final short n2, final short n3) {
        final long addressof_glTexCoord3s = this._pat._addressof_glTexCoord3s;
        if (addressof_glTexCoord3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3s"));
        }
        this.dispatch_glTexCoord3s1(n, n2, n3, addressof_glTexCoord3s);
    }
    
    private native void dispatch_glTexCoord3s1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glTexCoord4d(final double n, final double n2, final double n3, final double n4) {
        final long addressof_glTexCoord4d = this._pat._addressof_glTexCoord4d;
        if (addressof_glTexCoord4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4d"));
        }
        this.dispatch_glTexCoord4d1(n, n2, n3, n4, addressof_glTexCoord4d);
    }
    
    private native void dispatch_glTexCoord4d1(final double p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glTexCoord4f(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glTexCoord4f = this._pat._addressof_glTexCoord4f;
        if (addressof_glTexCoord4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4f"));
        }
        this.dispatch_glTexCoord4f1(n, n2, n3, n4, addressof_glTexCoord4f);
    }
    
    private native void dispatch_glTexCoord4f1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glTexCoord4i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glTexCoord4i = this._pat._addressof_glTexCoord4i;
        if (addressof_glTexCoord4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4i"));
        }
        this.dispatch_glTexCoord4i1(n, n2, n3, n4, addressof_glTexCoord4i);
    }
    
    private native void dispatch_glTexCoord4i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glTexCoord4s(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glTexCoord4s = this._pat._addressof_glTexCoord4s;
        if (addressof_glTexCoord4s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4s"));
        }
        this.dispatch_glTexCoord4s1(n, n2, n3, n4, addressof_glTexCoord4s);
    }
    
    private native void dispatch_glTexCoord4s1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glTexCoord1dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glTexCoord1dv = this._pat._addressof_glTexCoord1dv;
        if (addressof_glTexCoord1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1dv"));
        }
        this.dispatch_glTexCoord1dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glTexCoord1dv);
    }
    
    private native void dispatch_glTexCoord1dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord1dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord1dv = this._pat._addressof_glTexCoord1dv;
        if (addressof_glTexCoord1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1dv"));
        }
        this.dispatch_glTexCoord1dv1(array, 8 * n, false, addressof_glTexCoord1dv);
    }
    
    @Override
    public void glTexCoord1fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTexCoord1fv = this._pat._addressof_glTexCoord1fv;
        if (addressof_glTexCoord1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1fv"));
        }
        this.dispatch_glTexCoord1fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTexCoord1fv);
    }
    
    private native void dispatch_glTexCoord1fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord1fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord1fv = this._pat._addressof_glTexCoord1fv;
        if (addressof_glTexCoord1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1fv"));
        }
        this.dispatch_glTexCoord1fv1(array, 4 * n, false, addressof_glTexCoord1fv);
    }
    
    @Override
    public void glTexCoord1iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoord1iv = this._pat._addressof_glTexCoord1iv;
        if (addressof_glTexCoord1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1iv"));
        }
        this.dispatch_glTexCoord1iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoord1iv);
    }
    
    private native void dispatch_glTexCoord1iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord1iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord1iv = this._pat._addressof_glTexCoord1iv;
        if (addressof_glTexCoord1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1iv"));
        }
        this.dispatch_glTexCoord1iv1(array, 4 * n, false, addressof_glTexCoord1iv);
    }
    
    @Override
    public void glTexCoord1sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord1sv = this._pat._addressof_glTexCoord1sv;
        if (addressof_glTexCoord1sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1sv"));
        }
        this.dispatch_glTexCoord1sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord1sv);
    }
    
    private native void dispatch_glTexCoord1sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord1sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord1sv = this._pat._addressof_glTexCoord1sv;
        if (addressof_glTexCoord1sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1sv"));
        }
        this.dispatch_glTexCoord1sv1(array, 2 * n, false, addressof_glTexCoord1sv);
    }
    
    @Override
    public void glTexCoord2dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glTexCoord2dv = this._pat._addressof_glTexCoord2dv;
        if (addressof_glTexCoord2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2dv"));
        }
        this.dispatch_glTexCoord2dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glTexCoord2dv);
    }
    
    private native void dispatch_glTexCoord2dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord2dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord2dv = this._pat._addressof_glTexCoord2dv;
        if (addressof_glTexCoord2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2dv"));
        }
        this.dispatch_glTexCoord2dv1(array, 8 * n, false, addressof_glTexCoord2dv);
    }
    
    @Override
    public void glTexCoord2fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTexCoord2fv = this._pat._addressof_glTexCoord2fv;
        if (addressof_glTexCoord2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2fv"));
        }
        this.dispatch_glTexCoord2fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTexCoord2fv);
    }
    
    private native void dispatch_glTexCoord2fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord2fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord2fv = this._pat._addressof_glTexCoord2fv;
        if (addressof_glTexCoord2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2fv"));
        }
        this.dispatch_glTexCoord2fv1(array, 4 * n, false, addressof_glTexCoord2fv);
    }
    
    @Override
    public void glTexCoord2iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoord2iv = this._pat._addressof_glTexCoord2iv;
        if (addressof_glTexCoord2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2iv"));
        }
        this.dispatch_glTexCoord2iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoord2iv);
    }
    
    private native void dispatch_glTexCoord2iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord2iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord2iv = this._pat._addressof_glTexCoord2iv;
        if (addressof_glTexCoord2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2iv"));
        }
        this.dispatch_glTexCoord2iv1(array, 4 * n, false, addressof_glTexCoord2iv);
    }
    
    @Override
    public void glTexCoord2sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord2sv = this._pat._addressof_glTexCoord2sv;
        if (addressof_glTexCoord2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2sv"));
        }
        this.dispatch_glTexCoord2sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord2sv);
    }
    
    private native void dispatch_glTexCoord2sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord2sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord2sv = this._pat._addressof_glTexCoord2sv;
        if (addressof_glTexCoord2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2sv"));
        }
        this.dispatch_glTexCoord2sv1(array, 2 * n, false, addressof_glTexCoord2sv);
    }
    
    @Override
    public void glTexCoord3dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glTexCoord3dv = this._pat._addressof_glTexCoord3dv;
        if (addressof_glTexCoord3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3dv"));
        }
        this.dispatch_glTexCoord3dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glTexCoord3dv);
    }
    
    private native void dispatch_glTexCoord3dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord3dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord3dv = this._pat._addressof_glTexCoord3dv;
        if (addressof_glTexCoord3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3dv"));
        }
        this.dispatch_glTexCoord3dv1(array, 8 * n, false, addressof_glTexCoord3dv);
    }
    
    @Override
    public void glTexCoord3fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTexCoord3fv = this._pat._addressof_glTexCoord3fv;
        if (addressof_glTexCoord3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3fv"));
        }
        this.dispatch_glTexCoord3fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTexCoord3fv);
    }
    
    private native void dispatch_glTexCoord3fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord3fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord3fv = this._pat._addressof_glTexCoord3fv;
        if (addressof_glTexCoord3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3fv"));
        }
        this.dispatch_glTexCoord3fv1(array, 4 * n, false, addressof_glTexCoord3fv);
    }
    
    @Override
    public void glTexCoord3iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoord3iv = this._pat._addressof_glTexCoord3iv;
        if (addressof_glTexCoord3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3iv"));
        }
        this.dispatch_glTexCoord3iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoord3iv);
    }
    
    private native void dispatch_glTexCoord3iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord3iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord3iv = this._pat._addressof_glTexCoord3iv;
        if (addressof_glTexCoord3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3iv"));
        }
        this.dispatch_glTexCoord3iv1(array, 4 * n, false, addressof_glTexCoord3iv);
    }
    
    @Override
    public void glTexCoord3sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord3sv = this._pat._addressof_glTexCoord3sv;
        if (addressof_glTexCoord3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3sv"));
        }
        this.dispatch_glTexCoord3sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord3sv);
    }
    
    private native void dispatch_glTexCoord3sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord3sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord3sv = this._pat._addressof_glTexCoord3sv;
        if (addressof_glTexCoord3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3sv"));
        }
        this.dispatch_glTexCoord3sv1(array, 2 * n, false, addressof_glTexCoord3sv);
    }
    
    @Override
    public void glTexCoord4dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glTexCoord4dv = this._pat._addressof_glTexCoord4dv;
        if (addressof_glTexCoord4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4dv"));
        }
        this.dispatch_glTexCoord4dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glTexCoord4dv);
    }
    
    private native void dispatch_glTexCoord4dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord4dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord4dv = this._pat._addressof_glTexCoord4dv;
        if (addressof_glTexCoord4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4dv"));
        }
        this.dispatch_glTexCoord4dv1(array, 8 * n, false, addressof_glTexCoord4dv);
    }
    
    @Override
    public void glTexCoord4fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTexCoord4fv = this._pat._addressof_glTexCoord4fv;
        if (addressof_glTexCoord4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4fv"));
        }
        this.dispatch_glTexCoord4fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTexCoord4fv);
    }
    
    private native void dispatch_glTexCoord4fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord4fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord4fv = this._pat._addressof_glTexCoord4fv;
        if (addressof_glTexCoord4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4fv"));
        }
        this.dispatch_glTexCoord4fv1(array, 4 * n, false, addressof_glTexCoord4fv);
    }
    
    @Override
    public void glTexCoord4iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoord4iv = this._pat._addressof_glTexCoord4iv;
        if (addressof_glTexCoord4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4iv"));
        }
        this.dispatch_glTexCoord4iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoord4iv);
    }
    
    private native void dispatch_glTexCoord4iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord4iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord4iv = this._pat._addressof_glTexCoord4iv;
        if (addressof_glTexCoord4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4iv"));
        }
        this.dispatch_glTexCoord4iv1(array, 4 * n, false, addressof_glTexCoord4iv);
    }
    
    @Override
    public void glTexCoord4sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord4sv = this._pat._addressof_glTexCoord4sv;
        if (addressof_glTexCoord4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4sv"));
        }
        this.dispatch_glTexCoord4sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord4sv);
    }
    
    private native void dispatch_glTexCoord4sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord4sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord4sv = this._pat._addressof_glTexCoord4sv;
        if (addressof_glTexCoord4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4sv"));
        }
        this.dispatch_glTexCoord4sv1(array, 2 * n, false, addressof_glTexCoord4sv);
    }
    
    @Override
    public void glRasterPos2d(final double n, final double n2) {
        final long addressof_glRasterPos2d = this._pat._addressof_glRasterPos2d;
        if (addressof_glRasterPos2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2d"));
        }
        this.dispatch_glRasterPos2d1(n, n2, addressof_glRasterPos2d);
    }
    
    private native void dispatch_glRasterPos2d1(final double p0, final double p1, final long p2);
    
    @Override
    public void glRasterPos2f(final float n, final float n2) {
        final long addressof_glRasterPos2f = this._pat._addressof_glRasterPos2f;
        if (addressof_glRasterPos2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2f"));
        }
        this.dispatch_glRasterPos2f1(n, n2, addressof_glRasterPos2f);
    }
    
    private native void dispatch_glRasterPos2f1(final float p0, final float p1, final long p2);
    
    @Override
    public void glRasterPos2i(final int n, final int n2) {
        final long addressof_glRasterPos2i = this._pat._addressof_glRasterPos2i;
        if (addressof_glRasterPos2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2i"));
        }
        this.dispatch_glRasterPos2i1(n, n2, addressof_glRasterPos2i);
    }
    
    private native void dispatch_glRasterPos2i1(final int p0, final int p1, final long p2);
    
    @Override
    public void glRasterPos2s(final short n, final short n2) {
        final long addressof_glRasterPos2s = this._pat._addressof_glRasterPos2s;
        if (addressof_glRasterPos2s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2s"));
        }
        this.dispatch_glRasterPos2s1(n, n2, addressof_glRasterPos2s);
    }
    
    private native void dispatch_glRasterPos2s1(final short p0, final short p1, final long p2);
    
    @Override
    public void glRasterPos3d(final double n, final double n2, final double n3) {
        final long addressof_glRasterPos3d = this._pat._addressof_glRasterPos3d;
        if (addressof_glRasterPos3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3d"));
        }
        this.dispatch_glRasterPos3d1(n, n2, n3, addressof_glRasterPos3d);
    }
    
    private native void dispatch_glRasterPos3d1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glRasterPos3f(final float n, final float n2, final float n3) {
        final long addressof_glRasterPos3f = this._pat._addressof_glRasterPos3f;
        if (addressof_glRasterPos3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3f"));
        }
        this.dispatch_glRasterPos3f1(n, n2, n3, addressof_glRasterPos3f);
    }
    
    private native void dispatch_glRasterPos3f1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glRasterPos3i(final int n, final int n2, final int n3) {
        final long addressof_glRasterPos3i = this._pat._addressof_glRasterPos3i;
        if (addressof_glRasterPos3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3i"));
        }
        this.dispatch_glRasterPos3i1(n, n2, n3, addressof_glRasterPos3i);
    }
    
    private native void dispatch_glRasterPos3i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glRasterPos3s(final short n, final short n2, final short n3) {
        final long addressof_glRasterPos3s = this._pat._addressof_glRasterPos3s;
        if (addressof_glRasterPos3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3s"));
        }
        this.dispatch_glRasterPos3s1(n, n2, n3, addressof_glRasterPos3s);
    }
    
    private native void dispatch_glRasterPos3s1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glRasterPos4d(final double n, final double n2, final double n3, final double n4) {
        final long addressof_glRasterPos4d = this._pat._addressof_glRasterPos4d;
        if (addressof_glRasterPos4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4d"));
        }
        this.dispatch_glRasterPos4d1(n, n2, n3, n4, addressof_glRasterPos4d);
    }
    
    private native void dispatch_glRasterPos4d1(final double p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glRasterPos4f(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glRasterPos4f = this._pat._addressof_glRasterPos4f;
        if (addressof_glRasterPos4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4f"));
        }
        this.dispatch_glRasterPos4f1(n, n2, n3, n4, addressof_glRasterPos4f);
    }
    
    private native void dispatch_glRasterPos4f1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glRasterPos4i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glRasterPos4i = this._pat._addressof_glRasterPos4i;
        if (addressof_glRasterPos4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4i"));
        }
        this.dispatch_glRasterPos4i1(n, n2, n3, n4, addressof_glRasterPos4i);
    }
    
    private native void dispatch_glRasterPos4i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glRasterPos4s(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glRasterPos4s = this._pat._addressof_glRasterPos4s;
        if (addressof_glRasterPos4s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4s"));
        }
        this.dispatch_glRasterPos4s1(n, n2, n3, n4, addressof_glRasterPos4s);
    }
    
    private native void dispatch_glRasterPos4s1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glRasterPos2dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glRasterPos2dv = this._pat._addressof_glRasterPos2dv;
        if (addressof_glRasterPos2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2dv"));
        }
        this.dispatch_glRasterPos2dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glRasterPos2dv);
    }
    
    private native void dispatch_glRasterPos2dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos2dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos2dv = this._pat._addressof_glRasterPos2dv;
        if (addressof_glRasterPos2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2dv"));
        }
        this.dispatch_glRasterPos2dv1(array, 8 * n, false, addressof_glRasterPos2dv);
    }
    
    @Override
    public void glRasterPos2fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glRasterPos2fv = this._pat._addressof_glRasterPos2fv;
        if (addressof_glRasterPos2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2fv"));
        }
        this.dispatch_glRasterPos2fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glRasterPos2fv);
    }
    
    private native void dispatch_glRasterPos2fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos2fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos2fv = this._pat._addressof_glRasterPos2fv;
        if (addressof_glRasterPos2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2fv"));
        }
        this.dispatch_glRasterPos2fv1(array, 4 * n, false, addressof_glRasterPos2fv);
    }
    
    @Override
    public void glRasterPos2iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glRasterPos2iv = this._pat._addressof_glRasterPos2iv;
        if (addressof_glRasterPos2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2iv"));
        }
        this.dispatch_glRasterPos2iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glRasterPos2iv);
    }
    
    private native void dispatch_glRasterPos2iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos2iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos2iv = this._pat._addressof_glRasterPos2iv;
        if (addressof_glRasterPos2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2iv"));
        }
        this.dispatch_glRasterPos2iv1(array, 4 * n, false, addressof_glRasterPos2iv);
    }
    
    @Override
    public void glRasterPos2sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glRasterPos2sv = this._pat._addressof_glRasterPos2sv;
        if (addressof_glRasterPos2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2sv"));
        }
        this.dispatch_glRasterPos2sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glRasterPos2sv);
    }
    
    private native void dispatch_glRasterPos2sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos2sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos2sv = this._pat._addressof_glRasterPos2sv;
        if (addressof_glRasterPos2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2sv"));
        }
        this.dispatch_glRasterPos2sv1(array, 2 * n, false, addressof_glRasterPos2sv);
    }
    
    @Override
    public void glRasterPos3dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glRasterPos3dv = this._pat._addressof_glRasterPos3dv;
        if (addressof_glRasterPos3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3dv"));
        }
        this.dispatch_glRasterPos3dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glRasterPos3dv);
    }
    
    private native void dispatch_glRasterPos3dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos3dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos3dv = this._pat._addressof_glRasterPos3dv;
        if (addressof_glRasterPos3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3dv"));
        }
        this.dispatch_glRasterPos3dv1(array, 8 * n, false, addressof_glRasterPos3dv);
    }
    
    @Override
    public void glRasterPos3fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glRasterPos3fv = this._pat._addressof_glRasterPos3fv;
        if (addressof_glRasterPos3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3fv"));
        }
        this.dispatch_glRasterPos3fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glRasterPos3fv);
    }
    
    private native void dispatch_glRasterPos3fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos3fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos3fv = this._pat._addressof_glRasterPos3fv;
        if (addressof_glRasterPos3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3fv"));
        }
        this.dispatch_glRasterPos3fv1(array, 4 * n, false, addressof_glRasterPos3fv);
    }
    
    @Override
    public void glRasterPos3iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glRasterPos3iv = this._pat._addressof_glRasterPos3iv;
        if (addressof_glRasterPos3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3iv"));
        }
        this.dispatch_glRasterPos3iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glRasterPos3iv);
    }
    
    private native void dispatch_glRasterPos3iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos3iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos3iv = this._pat._addressof_glRasterPos3iv;
        if (addressof_glRasterPos3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3iv"));
        }
        this.dispatch_glRasterPos3iv1(array, 4 * n, false, addressof_glRasterPos3iv);
    }
    
    @Override
    public void glRasterPos3sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glRasterPos3sv = this._pat._addressof_glRasterPos3sv;
        if (addressof_glRasterPos3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3sv"));
        }
        this.dispatch_glRasterPos3sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glRasterPos3sv);
    }
    
    private native void dispatch_glRasterPos3sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos3sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos3sv = this._pat._addressof_glRasterPos3sv;
        if (addressof_glRasterPos3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3sv"));
        }
        this.dispatch_glRasterPos3sv1(array, 2 * n, false, addressof_glRasterPos3sv);
    }
    
    @Override
    public void glRasterPos4dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glRasterPos4dv = this._pat._addressof_glRasterPos4dv;
        if (addressof_glRasterPos4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4dv"));
        }
        this.dispatch_glRasterPos4dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glRasterPos4dv);
    }
    
    private native void dispatch_glRasterPos4dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos4dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos4dv = this._pat._addressof_glRasterPos4dv;
        if (addressof_glRasterPos4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4dv"));
        }
        this.dispatch_glRasterPos4dv1(array, 8 * n, false, addressof_glRasterPos4dv);
    }
    
    @Override
    public void glRasterPos4fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glRasterPos4fv = this._pat._addressof_glRasterPos4fv;
        if (addressof_glRasterPos4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4fv"));
        }
        this.dispatch_glRasterPos4fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glRasterPos4fv);
    }
    
    private native void dispatch_glRasterPos4fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos4fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos4fv = this._pat._addressof_glRasterPos4fv;
        if (addressof_glRasterPos4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4fv"));
        }
        this.dispatch_glRasterPos4fv1(array, 4 * n, false, addressof_glRasterPos4fv);
    }
    
    @Override
    public void glRasterPos4iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glRasterPos4iv = this._pat._addressof_glRasterPos4iv;
        if (addressof_glRasterPos4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4iv"));
        }
        this.dispatch_glRasterPos4iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glRasterPos4iv);
    }
    
    private native void dispatch_glRasterPos4iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos4iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos4iv = this._pat._addressof_glRasterPos4iv;
        if (addressof_glRasterPos4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4iv"));
        }
        this.dispatch_glRasterPos4iv1(array, 4 * n, false, addressof_glRasterPos4iv);
    }
    
    @Override
    public void glRasterPos4sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glRasterPos4sv = this._pat._addressof_glRasterPos4sv;
        if (addressof_glRasterPos4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4sv"));
        }
        this.dispatch_glRasterPos4sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glRasterPos4sv);
    }
    
    private native void dispatch_glRasterPos4sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glRasterPos4sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glRasterPos4sv = this._pat._addressof_glRasterPos4sv;
        if (addressof_glRasterPos4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4sv"));
        }
        this.dispatch_glRasterPos4sv1(array, 2 * n, false, addressof_glRasterPos4sv);
    }
    
    @Override
    public void glRectd(final double n, final double n2, final double n3, final double n4) {
        final long addressof_glRectd = this._pat._addressof_glRectd;
        if (addressof_glRectd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectd"));
        }
        this.dispatch_glRectd1(n, n2, n3, n4, addressof_glRectd);
    }
    
    private native void dispatch_glRectd1(final double p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glRectf(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glRectf = this._pat._addressof_glRectf;
        if (addressof_glRectf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectf"));
        }
        this.dispatch_glRectf1(n, n2, n3, n4, addressof_glRectf);
    }
    
    private native void dispatch_glRectf1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glRecti(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glRecti = this._pat._addressof_glRecti;
        if (addressof_glRecti == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRecti"));
        }
        this.dispatch_glRecti1(n, n2, n3, n4, addressof_glRecti);
    }
    
    private native void dispatch_glRecti1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glRects(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glRects = this._pat._addressof_glRects;
        if (addressof_glRects == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRects"));
        }
        this.dispatch_glRects1(n, n2, n3, n4, addressof_glRects);
    }
    
    private native void dispatch_glRects1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glRectdv(final DoubleBuffer doubleBuffer, final DoubleBuffer doubleBuffer2) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final boolean direct2 = Buffers.isDirect(doubleBuffer2);
        final long addressof_glRectdv = this._pat._addressof_glRectdv;
        if (addressof_glRectdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectdv"));
        }
        this.dispatch_glRectdv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, direct2 ? doubleBuffer2 : Buffers.getArray(doubleBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(doubleBuffer2) : Buffers.getIndirectBufferByteOffset(doubleBuffer2), direct2, addressof_glRectdv);
    }
    
    private native void dispatch_glRectdv1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glRectdv(final double[] array, final int n, final double[] array2, final int n2) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v1_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n2) {
            throw new GLException("array offset argument \"v2_offset\" (" + n2 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glRectdv = this._pat._addressof_glRectdv;
        if (addressof_glRectdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectdv"));
        }
        this.dispatch_glRectdv1(array, 8 * n, false, array2, 8 * n2, false, addressof_glRectdv);
    }
    
    @Override
    public void glRectfv(final FloatBuffer floatBuffer, final FloatBuffer floatBuffer2) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final boolean direct2 = Buffers.isDirect(floatBuffer2);
        final long addressof_glRectfv = this._pat._addressof_glRectfv;
        if (addressof_glRectfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectfv"));
        }
        this.dispatch_glRectfv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, direct2 ? floatBuffer2 : Buffers.getArray(floatBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(floatBuffer2) : Buffers.getIndirectBufferByteOffset(floatBuffer2), direct2, addressof_glRectfv);
    }
    
    private native void dispatch_glRectfv1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glRectfv(final float[] array, final int n, final float[] array2, final int n2) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v1_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n2) {
            throw new GLException("array offset argument \"v2_offset\" (" + n2 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glRectfv = this._pat._addressof_glRectfv;
        if (addressof_glRectfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectfv"));
        }
        this.dispatch_glRectfv1(array, 4 * n, false, array2, 4 * n2, false, addressof_glRectfv);
    }
    
    @Override
    public void glRectiv(final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glRectiv = this._pat._addressof_glRectiv;
        if (addressof_glRectiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectiv"));
        }
        this.dispatch_glRectiv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glRectiv);
    }
    
    private native void dispatch_glRectiv1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glRectiv(final int[] array, final int n, final int[] array2, final int n2) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v1_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n2) {
            throw new GLException("array offset argument \"v2_offset\" (" + n2 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glRectiv = this._pat._addressof_glRectiv;
        if (addressof_glRectiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectiv"));
        }
        this.dispatch_glRectiv1(array, 4 * n, false, array2, 4 * n2, false, addressof_glRectiv);
    }
    
    @Override
    public void glRectsv(final ShortBuffer shortBuffer, final ShortBuffer shortBuffer2) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final boolean direct2 = Buffers.isDirect(shortBuffer2);
        final long addressof_glRectsv = this._pat._addressof_glRectsv;
        if (addressof_glRectsv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectsv"));
        }
        this.dispatch_glRectsv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, direct2 ? shortBuffer2 : Buffers.getArray(shortBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(shortBuffer2) : Buffers.getIndirectBufferByteOffset(shortBuffer2), direct2, addressof_glRectsv);
    }
    
    private native void dispatch_glRectsv1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glRectsv(final short[] array, final int n, final short[] array2, final int n2) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v1_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n2) {
            throw new GLException("array offset argument \"v2_offset\" (" + n2 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glRectsv = this._pat._addressof_glRectsv;
        if (addressof_glRectsv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRectsv"));
        }
        this.dispatch_glRectsv1(array, 2 * n, false, array2, 2 * n2, false, addressof_glRectsv);
    }
    
    @Override
    public void glShadeModel(final int n) {
        final long addressof_glShadeModel = this._pat._addressof_glShadeModel;
        if (addressof_glShadeModel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShadeModel"));
        }
        this.dispatch_glShadeModel1(n, addressof_glShadeModel);
    }
    
    private native void dispatch_glShadeModel1(final int p0, final long p1);
    
    @Override
    public void glLightf(final int n, final int n2, final float n3) {
        final long addressof_glLightf = this._pat._addressof_glLightf;
        if (addressof_glLightf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightf"));
        }
        this.dispatch_glLightf1(n, n2, n3, addressof_glLightf);
    }
    
    private native void dispatch_glLightf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glLighti(final int n, final int n2, final int n3) {
        final long addressof_glLighti = this._pat._addressof_glLighti;
        if (addressof_glLighti == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLighti"));
        }
        this.dispatch_glLighti1(n, n2, n3, addressof_glLighti);
    }
    
    private native void dispatch_glLighti1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glLightfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glLightfv = this._pat._addressof_glLightfv;
        if (addressof_glLightfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightfv"));
        }
        this.dispatch_glLightfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glLightfv);
    }
    
    private native void dispatch_glLightfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glLightfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLightfv = this._pat._addressof_glLightfv;
        if (addressof_glLightfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightfv"));
        }
        this.dispatch_glLightfv1(n, n2, array, 4 * n3, false, addressof_glLightfv);
    }
    
    @Override
    public void glLightiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glLightiv = this._pat._addressof_glLightiv;
        if (addressof_glLightiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightiv"));
        }
        this.dispatch_glLightiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glLightiv);
    }
    
    private native void dispatch_glLightiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glLightiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLightiv = this._pat._addressof_glLightiv;
        if (addressof_glLightiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightiv"));
        }
        this.dispatch_glLightiv1(n, n2, array, 4 * n3, false, addressof_glLightiv);
    }
    
    @Override
    public void glGetLightfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetLightfv = this._pat._addressof_glGetLightfv;
        if (addressof_glGetLightfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLightfv"));
        }
        this.dispatch_glGetLightfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetLightfv);
    }
    
    private native void dispatch_glGetLightfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetLightfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetLightfv = this._pat._addressof_glGetLightfv;
        if (addressof_glGetLightfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLightfv"));
        }
        this.dispatch_glGetLightfv1(n, n2, array, 4 * n3, false, addressof_glGetLightfv);
    }
    
    @Override
    public void glGetLightiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetLightiv = this._pat._addressof_glGetLightiv;
        if (addressof_glGetLightiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLightiv"));
        }
        this.dispatch_glGetLightiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetLightiv);
    }
    
    private native void dispatch_glGetLightiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetLightiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetLightiv = this._pat._addressof_glGetLightiv;
        if (addressof_glGetLightiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLightiv"));
        }
        this.dispatch_glGetLightiv1(n, n2, array, 4 * n3, false, addressof_glGetLightiv);
    }
    
    @Override
    public void glLightModelf(final int n, final float n2) {
        final long addressof_glLightModelf = this._pat._addressof_glLightModelf;
        if (addressof_glLightModelf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightModelf"));
        }
        this.dispatch_glLightModelf1(n, n2, addressof_glLightModelf);
    }
    
    private native void dispatch_glLightModelf1(final int p0, final float p1, final long p2);
    
    @Override
    public void glLightModeli(final int n, final int n2) {
        final long addressof_glLightModeli = this._pat._addressof_glLightModeli;
        if (addressof_glLightModeli == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightModeli"));
        }
        this.dispatch_glLightModeli1(n, n2, addressof_glLightModeli);
    }
    
    private native void dispatch_glLightModeli1(final int p0, final int p1, final long p2);
    
    @Override
    public void glLightModelfv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glLightModelfv = this._pat._addressof_glLightModelfv;
        if (addressof_glLightModelfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightModelfv"));
        }
        this.dispatch_glLightModelfv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glLightModelfv);
    }
    
    private native void dispatch_glLightModelfv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glLightModelfv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLightModelfv = this._pat._addressof_glLightModelfv;
        if (addressof_glLightModelfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightModelfv"));
        }
        this.dispatch_glLightModelfv1(n, array, 4 * n2, false, addressof_glLightModelfv);
    }
    
    @Override
    public void glLightModeliv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glLightModeliv = this._pat._addressof_glLightModeliv;
        if (addressof_glLightModeliv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightModeliv"));
        }
        this.dispatch_glLightModeliv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glLightModeliv);
    }
    
    private native void dispatch_glLightModeliv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glLightModeliv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLightModeliv = this._pat._addressof_glLightModeliv;
        if (addressof_glLightModeliv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLightModeliv"));
        }
        this.dispatch_glLightModeliv1(n, array, 4 * n2, false, addressof_glLightModeliv);
    }
    
    @Override
    public void glMaterialf(final int n, final int n2, final float n3) {
        final long addressof_glMaterialf = this._pat._addressof_glMaterialf;
        if (addressof_glMaterialf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMaterialf"));
        }
        this.dispatch_glMaterialf1(n, n2, n3, addressof_glMaterialf);
    }
    
    private native void dispatch_glMaterialf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glMateriali(final int n, final int n2, final int n3) {
        final long addressof_glMateriali = this._pat._addressof_glMateriali;
        if (addressof_glMateriali == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMateriali"));
        }
        this.dispatch_glMateriali1(n, n2, n3, addressof_glMateriali);
    }
    
    private native void dispatch_glMateriali1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMaterialfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMaterialfv = this._pat._addressof_glMaterialfv;
        if (addressof_glMaterialfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMaterialfv"));
        }
        this.dispatch_glMaterialfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMaterialfv);
    }
    
    private native void dispatch_glMaterialfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMaterialfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMaterialfv = this._pat._addressof_glMaterialfv;
        if (addressof_glMaterialfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMaterialfv"));
        }
        this.dispatch_glMaterialfv1(n, n2, array, 4 * n3, false, addressof_glMaterialfv);
    }
    
    @Override
    public void glMaterialiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMaterialiv = this._pat._addressof_glMaterialiv;
        if (addressof_glMaterialiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMaterialiv"));
        }
        this.dispatch_glMaterialiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMaterialiv);
    }
    
    private native void dispatch_glMaterialiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMaterialiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMaterialiv = this._pat._addressof_glMaterialiv;
        if (addressof_glMaterialiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMaterialiv"));
        }
        this.dispatch_glMaterialiv1(n, n2, array, 4 * n3, false, addressof_glMaterialiv);
    }
    
    @Override
    public void glGetMaterialfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMaterialfv = this._pat._addressof_glGetMaterialfv;
        if (addressof_glGetMaterialfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialfv"));
        }
        this.dispatch_glGetMaterialfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMaterialfv);
    }
    
    private native void dispatch_glGetMaterialfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMaterialfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMaterialfv = this._pat._addressof_glGetMaterialfv;
        if (addressof_glGetMaterialfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialfv"));
        }
        this.dispatch_glGetMaterialfv1(n, n2, array, 4 * n3, false, addressof_glGetMaterialfv);
    }
    
    @Override
    public void glGetMaterialiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMaterialiv = this._pat._addressof_glGetMaterialiv;
        if (addressof_glGetMaterialiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialiv"));
        }
        this.dispatch_glGetMaterialiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMaterialiv);
    }
    
    private native void dispatch_glGetMaterialiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMaterialiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMaterialiv = this._pat._addressof_glGetMaterialiv;
        if (addressof_glGetMaterialiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialiv"));
        }
        this.dispatch_glGetMaterialiv1(n, n2, array, 4 * n3, false, addressof_glGetMaterialiv);
    }
    
    @Override
    public void glColorMaterial(final int n, final int n2) {
        final long addressof_glColorMaterial = this._pat._addressof_glColorMaterial;
        if (addressof_glColorMaterial == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorMaterial"));
        }
        this.dispatch_glColorMaterial1(n, n2, addressof_glColorMaterial);
    }
    
    private native void dispatch_glColorMaterial1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPixelZoom(final float n, final float n2) {
        final long addressof_glPixelZoom = this._pat._addressof_glPixelZoom;
        if (addressof_glPixelZoom == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelZoom"));
        }
        this.dispatch_glPixelZoom1(n, n2, addressof_glPixelZoom);
    }
    
    private native void dispatch_glPixelZoom1(final float p0, final float p1, final long p2);
    
    @Override
    public void glPixelStoref(final int n, final float n2) {
        final long addressof_glPixelStoref = this._pat._addressof_glPixelStoref;
        if (addressof_glPixelStoref == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelStoref"));
        }
        this.dispatch_glPixelStoref1(n, n2, addressof_glPixelStoref);
    }
    
    private native void dispatch_glPixelStoref1(final int p0, final float p1, final long p2);
    
    @Override
    public void glPixelStorei(final int n, final int n2) {
        this.glStateTracker.setInt(n, n2);
        final long addressof_glPixelStorei = this._pat._addressof_glPixelStorei;
        if (addressof_glPixelStorei == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelStorei"));
        }
        this.dispatch_glPixelStorei1(n, n2, addressof_glPixelStorei);
    }
    
    private native void dispatch_glPixelStorei1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPixelTransferf(final int n, final float n2) {
        final long addressof_glPixelTransferf = this._pat._addressof_glPixelTransferf;
        if (addressof_glPixelTransferf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransferf"));
        }
        this.dispatch_glPixelTransferf1(n, n2, addressof_glPixelTransferf);
    }
    
    private native void dispatch_glPixelTransferf1(final int p0, final float p1, final long p2);
    
    @Override
    public void glPixelTransferi(final int n, final int n2) {
        final long addressof_glPixelTransferi = this._pat._addressof_glPixelTransferi;
        if (addressof_glPixelTransferi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransferi"));
        }
        this.dispatch_glPixelTransferi1(n, n2, addressof_glPixelTransferi);
    }
    
    private native void dispatch_glPixelTransferi1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPixelMapfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glPixelMapfv = this._pat._addressof_glPixelMapfv;
        if (addressof_glPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapfv"));
        }
        this.dispatch_glPixelMapfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glPixelMapfv);
    }
    
    private native void dispatch_glPixelMapfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glPixelMapfv(final int n, final int n2, final float[] array, final int n3) {
        this.checkUnpackPBOUnbound(true);
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"values_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPixelMapfv = this._pat._addressof_glPixelMapfv;
        if (addressof_glPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapfv"));
        }
        this.dispatch_glPixelMapfv1(n, n2, array, 4 * n3, false, addressof_glPixelMapfv);
    }
    
    @Override
    public void glPixelMapfv(final int n, final int n2, final long n3) {
        this.checkUnpackPBOBound(true);
        final long addressof_glPixelMapfv = this._pat._addressof_glPixelMapfv;
        if (addressof_glPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapfv"));
        }
        this.dispatch_glPixelMapfv1(n, n2, n3, addressof_glPixelMapfv);
    }
    
    private native void dispatch_glPixelMapfv1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glPixelMapuiv(final int n, final int n2, final IntBuffer intBuffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glPixelMapuiv = this._pat._addressof_glPixelMapuiv;
        if (addressof_glPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapuiv"));
        }
        this.dispatch_glPixelMapuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glPixelMapuiv);
    }
    
    private native void dispatch_glPixelMapuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glPixelMapuiv(final int n, final int n2, final int[] array, final int n3) {
        this.checkUnpackPBOUnbound(true);
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"values_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPixelMapuiv = this._pat._addressof_glPixelMapuiv;
        if (addressof_glPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapuiv"));
        }
        this.dispatch_glPixelMapuiv1(n, n2, array, 4 * n3, false, addressof_glPixelMapuiv);
    }
    
    @Override
    public void glPixelMapuiv(final int n, final int n2, final long n3) {
        this.checkUnpackPBOBound(true);
        final long addressof_glPixelMapuiv = this._pat._addressof_glPixelMapuiv;
        if (addressof_glPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapuiv"));
        }
        this.dispatch_glPixelMapuiv1(n, n2, n3, addressof_glPixelMapuiv);
    }
    
    private native void dispatch_glPixelMapuiv1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glPixelMapusv(final int n, final int n2, final ShortBuffer shortBuffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glPixelMapusv = this._pat._addressof_glPixelMapusv;
        if (addressof_glPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapusv"));
        }
        this.dispatch_glPixelMapusv1(n, n2, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glPixelMapusv);
    }
    
    private native void dispatch_glPixelMapusv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glPixelMapusv(final int n, final int n2, final short[] array, final int n3) {
        this.checkUnpackPBOUnbound(true);
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"values_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPixelMapusv = this._pat._addressof_glPixelMapusv;
        if (addressof_glPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapusv"));
        }
        this.dispatch_glPixelMapusv1(n, n2, array, 2 * n3, false, addressof_glPixelMapusv);
    }
    
    @Override
    public void glPixelMapusv(final int n, final int n2, final long n3) {
        this.checkUnpackPBOBound(true);
        final long addressof_glPixelMapusv = this._pat._addressof_glPixelMapusv;
        if (addressof_glPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelMapusv"));
        }
        this.dispatch_glPixelMapusv1(n, n2, n3, addressof_glPixelMapusv);
    }
    
    private native void dispatch_glPixelMapusv1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glGetPixelMapfv(final int n, final FloatBuffer floatBuffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetPixelMapfv = this._pat._addressof_glGetPixelMapfv;
        if (addressof_glGetPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapfv"));
        }
        this.dispatch_glGetPixelMapfv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetPixelMapfv);
    }
    
    private native void dispatch_glGetPixelMapfv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetPixelMapfv(final int n, final float[] array, final int n2) {
        this.checkPackPBOUnbound(true);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"values_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetPixelMapfv = this._pat._addressof_glGetPixelMapfv;
        if (addressof_glGetPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapfv"));
        }
        this.dispatch_glGetPixelMapfv1(n, array, 4 * n2, false, addressof_glGetPixelMapfv);
    }
    
    @Override
    public void glGetPixelMapfv(final int n, final long n2) {
        this.checkPackPBOBound(true);
        final long addressof_glGetPixelMapfv = this._pat._addressof_glGetPixelMapfv;
        if (addressof_glGetPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapfv"));
        }
        this.dispatch_glGetPixelMapfv1(n, n2, addressof_glGetPixelMapfv);
    }
    
    private native void dispatch_glGetPixelMapfv1(final int p0, final long p1, final long p2);
    
    @Override
    public void glGetPixelMapuiv(final int n, final IntBuffer intBuffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetPixelMapuiv = this._pat._addressof_glGetPixelMapuiv;
        if (addressof_glGetPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapuiv"));
        }
        this.dispatch_glGetPixelMapuiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetPixelMapuiv);
    }
    
    private native void dispatch_glGetPixelMapuiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetPixelMapuiv(final int n, final int[] array, final int n2) {
        this.checkPackPBOUnbound(true);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"values_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetPixelMapuiv = this._pat._addressof_glGetPixelMapuiv;
        if (addressof_glGetPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapuiv"));
        }
        this.dispatch_glGetPixelMapuiv1(n, array, 4 * n2, false, addressof_glGetPixelMapuiv);
    }
    
    @Override
    public void glGetPixelMapuiv(final int n, final long n2) {
        this.checkPackPBOBound(true);
        final long addressof_glGetPixelMapuiv = this._pat._addressof_glGetPixelMapuiv;
        if (addressof_glGetPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapuiv"));
        }
        this.dispatch_glGetPixelMapuiv1(n, n2, addressof_glGetPixelMapuiv);
    }
    
    private native void dispatch_glGetPixelMapuiv1(final int p0, final long p1, final long p2);
    
    @Override
    public void glGetPixelMapusv(final int n, final ShortBuffer shortBuffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glGetPixelMapusv = this._pat._addressof_glGetPixelMapusv;
        if (addressof_glGetPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapusv"));
        }
        this.dispatch_glGetPixelMapusv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glGetPixelMapusv);
    }
    
    private native void dispatch_glGetPixelMapusv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetPixelMapusv(final int n, final short[] array, final int n2) {
        this.checkPackPBOUnbound(true);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"values_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetPixelMapusv = this._pat._addressof_glGetPixelMapusv;
        if (addressof_glGetPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapusv"));
        }
        this.dispatch_glGetPixelMapusv1(n, array, 2 * n2, false, addressof_glGetPixelMapusv);
    }
    
    @Override
    public void glGetPixelMapusv(final int n, final long n2) {
        this.checkPackPBOBound(true);
        final long addressof_glGetPixelMapusv = this._pat._addressof_glGetPixelMapusv;
        if (addressof_glGetPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapusv"));
        }
        this.dispatch_glGetPixelMapusv1(n, n2, addressof_glGetPixelMapusv);
    }
    
    private native void dispatch_glGetPixelMapusv1(final int p0, final long p1, final long p2);
    
    @Override
    public void glBitmap(final int n, final int n2, final float n3, final float n4, final float n5, final float n6, final ByteBuffer byteBuffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glBitmap = this._pat._addressof_glBitmap;
        if (addressof_glBitmap == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBitmap"));
        }
        this.dispatch_glBitmap1(n, n2, n3, n4, n5, n6, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glBitmap);
    }
    
    private native void dispatch_glBitmap1(final int p0, final int p1, final float p2, final float p3, final float p4, final float p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glBitmap(final int n, final int n2, final float n3, final float n4, final float n5, final float n6, final byte[] array, final int n7) {
        this.checkUnpackPBOUnbound(true);
        if (array != null && array.length <= n7) {
            throw new GLException("array offset argument \"bitmap_offset\" (" + n7 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glBitmap = this._pat._addressof_glBitmap;
        if (addressof_glBitmap == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBitmap"));
        }
        this.dispatch_glBitmap1(n, n2, n3, n4, n5, n6, array, n7, false, addressof_glBitmap);
    }
    
    @Override
    public void glBitmap(final int n, final int n2, final float n3, final float n4, final float n5, final float n6, final long n7) {
        this.checkUnpackPBOBound(true);
        final long addressof_glBitmap = this._pat._addressof_glBitmap;
        if (addressof_glBitmap == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBitmap"));
        }
        this.dispatch_glBitmap1(n, n2, n3, n4, n5, n6, n7, addressof_glBitmap);
    }
    
    private native void dispatch_glBitmap1(final int p0, final int p1, final float p2, final float p3, final float p4, final float p5, final long p6, final long p7);
    
    @Override
    public void glReadPixels(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer) {
        this.checkPackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n5, n6, n3, n4, 1, true));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glReadPixels = this._pat._addressof_glReadPixels;
        if (addressof_glReadPixels == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
        }
        this.dispatch_glReadPixels1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glReadPixels);
    }
    
    private native void dispatch_glReadPixels1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glReadPixels(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        this.checkPackPBOBound(true);
        final long addressof_glReadPixels = this._pat._addressof_glReadPixels;
        if (addressof_glReadPixels == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
        }
        this.dispatch_glReadPixels1(n, n2, n3, n4, n5, n6, n7, addressof_glReadPixels);
    }
    
    private native void dispatch_glReadPixels1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glDrawPixels(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n3, n4, n, n2, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawPixels = this._pat._addressof_glDrawPixels;
        if (addressof_glDrawPixels == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawPixels"));
        }
        this.dispatch_glDrawPixels1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glDrawPixels);
    }
    
    private native void dispatch_glDrawPixels1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glDrawPixels(final int n, final int n2, final int n3, final int n4, final long n5) {
        this.checkUnpackPBOBound(true);
        final long addressof_glDrawPixels = this._pat._addressof_glDrawPixels;
        if (addressof_glDrawPixels == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawPixels"));
        }
        this.dispatch_glDrawPixels1(n, n2, n3, n4, n5, addressof_glDrawPixels);
    }
    
    private native void dispatch_glDrawPixels1(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glCopyPixels(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glCopyPixels = this._pat._addressof_glCopyPixels;
        if (addressof_glCopyPixels == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyPixels"));
        }
        this.dispatch_glCopyPixels1(n, n2, n3, n4, n5, addressof_glCopyPixels);
    }
    
    private native void dispatch_glCopyPixels1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glStencilFunc(final int n, final int n2, final int n3) {
        final long addressof_glStencilFunc = this._pat._addressof_glStencilFunc;
        if (addressof_glStencilFunc == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilFunc"));
        }
        this.dispatch_glStencilFunc1(n, n2, n3, addressof_glStencilFunc);
    }
    
    private native void dispatch_glStencilFunc1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glStencilMask(final int n) {
        final long addressof_glStencilMask = this._pat._addressof_glStencilMask;
        if (addressof_glStencilMask == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilMask"));
        }
        this.dispatch_glStencilMask1(n, addressof_glStencilMask);
    }
    
    private native void dispatch_glStencilMask1(final int p0, final long p1);
    
    @Override
    public void glStencilOp(final int n, final int n2, final int n3) {
        final long addressof_glStencilOp = this._pat._addressof_glStencilOp;
        if (addressof_glStencilOp == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilOp"));
        }
        this.dispatch_glStencilOp1(n, n2, n3, addressof_glStencilOp);
    }
    
    private native void dispatch_glStencilOp1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glClearStencil(final int n) {
        final long addressof_glClearStencil = this._pat._addressof_glClearStencil;
        if (addressof_glClearStencil == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearStencil"));
        }
        this.dispatch_glClearStencil1(n, addressof_glClearStencil);
    }
    
    private native void dispatch_glClearStencil1(final int p0, final long p1);
    
    @Override
    public void glTexGend(final int n, final int n2, final double n3) {
        final long addressof_glTexGend = this._pat._addressof_glTexGend;
        if (addressof_glTexGend == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGend"));
        }
        this.dispatch_glTexGend1(n, n2, n3, addressof_glTexGend);
    }
    
    private native void dispatch_glTexGend1(final int p0, final int p1, final double p2, final long p3);
    
    @Override
    public void glTexGenf(final int n, final int n2, final float n3) {
        final long addressof_glTexGenf = this._pat._addressof_glTexGenf;
        if (addressof_glTexGenf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGenf"));
        }
        this.dispatch_glTexGenf1(n, n2, n3, addressof_glTexGenf);
    }
    
    private native void dispatch_glTexGenf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glTexGeni(final int n, final int n2, final int n3) {
        final long addressof_glTexGeni = this._pat._addressof_glTexGeni;
        if (addressof_glTexGeni == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGeni"));
        }
        this.dispatch_glTexGeni1(n, n2, n3, addressof_glTexGeni);
    }
    
    private native void dispatch_glTexGeni1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTexGendv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glTexGendv = this._pat._addressof_glTexGendv;
        if (addressof_glTexGendv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGendv"));
        }
        this.dispatch_glTexGendv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glTexGendv);
    }
    
    private native void dispatch_glTexGendv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexGendv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexGendv = this._pat._addressof_glTexGendv;
        if (addressof_glTexGendv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGendv"));
        }
        this.dispatch_glTexGendv1(n, n2, array, 8 * n3, false, addressof_glTexGendv);
    }
    
    @Override
    public void glTexGenfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTexGenfv = this._pat._addressof_glTexGenfv;
        if (addressof_glTexGenfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGenfv"));
        }
        this.dispatch_glTexGenfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTexGenfv);
    }
    
    private native void dispatch_glTexGenfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexGenfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexGenfv = this._pat._addressof_glTexGenfv;
        if (addressof_glTexGenfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGenfv"));
        }
        this.dispatch_glTexGenfv1(n, n2, array, 4 * n3, false, addressof_glTexGenfv);
    }
    
    @Override
    public void glTexGeniv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexGeniv = this._pat._addressof_glTexGeniv;
        if (addressof_glTexGeniv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGeniv"));
        }
        this.dispatch_glTexGeniv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexGeniv);
    }
    
    private native void dispatch_glTexGeniv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexGeniv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexGeniv = this._pat._addressof_glTexGeniv;
        if (addressof_glTexGeniv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexGeniv"));
        }
        this.dispatch_glTexGeniv1(n, n2, array, 4 * n3, false, addressof_glTexGeniv);
    }
    
    @Override
    public void glGetTexGendv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetTexGendv = this._pat._addressof_glGetTexGendv;
        if (addressof_glGetTexGendv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexGendv"));
        }
        this.dispatch_glGetTexGendv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetTexGendv);
    }
    
    private native void dispatch_glGetTexGendv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexGendv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexGendv = this._pat._addressof_glGetTexGendv;
        if (addressof_glGetTexGendv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexGendv"));
        }
        this.dispatch_glGetTexGendv1(n, n2, array, 8 * n3, false, addressof_glGetTexGendv);
    }
    
    @Override
    public void glGetTexGenfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTexGenfv = this._pat._addressof_glGetTexGenfv;
        if (addressof_glGetTexGenfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenfv"));
        }
        this.dispatch_glGetTexGenfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTexGenfv);
    }
    
    private native void dispatch_glGetTexGenfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexGenfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexGenfv = this._pat._addressof_glGetTexGenfv;
        if (addressof_glGetTexGenfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenfv"));
        }
        this.dispatch_glGetTexGenfv1(n, n2, array, 4 * n3, false, addressof_glGetTexGenfv);
    }
    
    @Override
    public void glGetTexGeniv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTexGeniv = this._pat._addressof_glGetTexGeniv;
        if (addressof_glGetTexGeniv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexGeniv"));
        }
        this.dispatch_glGetTexGeniv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTexGeniv);
    }
    
    private native void dispatch_glGetTexGeniv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexGeniv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexGeniv = this._pat._addressof_glGetTexGeniv;
        if (addressof_glGetTexGeniv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexGeniv"));
        }
        this.dispatch_glGetTexGeniv1(n, n2, array, 4 * n3, false, addressof_glGetTexGeniv);
    }
    
    @Override
    public void glTexEnvf(final int n, final int n2, final float n3) {
        final long addressof_glTexEnvf = this._pat._addressof_glTexEnvf;
        if (addressof_glTexEnvf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexEnvf"));
        }
        this.dispatch_glTexEnvf1(n, n2, n3, addressof_glTexEnvf);
    }
    
    private native void dispatch_glTexEnvf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glTexEnvi(final int n, final int n2, final int n3) {
        final long addressof_glTexEnvi = this._pat._addressof_glTexEnvi;
        if (addressof_glTexEnvi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexEnvi"));
        }
        this.dispatch_glTexEnvi1(n, n2, n3, addressof_glTexEnvi);
    }
    
    private native void dispatch_glTexEnvi1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTexEnvfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTexEnvfv = this._pat._addressof_glTexEnvfv;
        if (addressof_glTexEnvfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexEnvfv"));
        }
        this.dispatch_glTexEnvfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTexEnvfv);
    }
    
    private native void dispatch_glTexEnvfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexEnvfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexEnvfv = this._pat._addressof_glTexEnvfv;
        if (addressof_glTexEnvfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexEnvfv"));
        }
        this.dispatch_glTexEnvfv1(n, n2, array, 4 * n3, false, addressof_glTexEnvfv);
    }
    
    @Override
    public void glTexEnviv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexEnviv = this._pat._addressof_glTexEnviv;
        if (addressof_glTexEnviv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexEnviv"));
        }
        this.dispatch_glTexEnviv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexEnviv);
    }
    
    private native void dispatch_glTexEnviv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexEnviv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexEnviv = this._pat._addressof_glTexEnviv;
        if (addressof_glTexEnviv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexEnviv"));
        }
        this.dispatch_glTexEnviv1(n, n2, array, 4 * n3, false, addressof_glTexEnviv);
    }
    
    @Override
    public void glGetTexEnvfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTexEnvfv = this._pat._addressof_glGetTexEnvfv;
        if (addressof_glGetTexEnvfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvfv"));
        }
        this.dispatch_glGetTexEnvfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTexEnvfv);
    }
    
    private native void dispatch_glGetTexEnvfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexEnvfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexEnvfv = this._pat._addressof_glGetTexEnvfv;
        if (addressof_glGetTexEnvfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvfv"));
        }
        this.dispatch_glGetTexEnvfv1(n, n2, array, 4 * n3, false, addressof_glGetTexEnvfv);
    }
    
    @Override
    public void glGetTexEnviv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTexEnviv = this._pat._addressof_glGetTexEnviv;
        if (addressof_glGetTexEnviv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnviv"));
        }
        this.dispatch_glGetTexEnviv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTexEnviv);
    }
    
    private native void dispatch_glGetTexEnviv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexEnviv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexEnviv = this._pat._addressof_glGetTexEnviv;
        if (addressof_glGetTexEnviv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnviv"));
        }
        this.dispatch_glGetTexEnviv1(n, n2, array, 4 * n3, false, addressof_glGetTexEnviv);
    }
    
    @Override
    public void glTexParameterf(final int n, final int n2, final float n3) {
        final long addressof_glTexParameterf = this._pat._addressof_glTexParameterf;
        if (addressof_glTexParameterf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameterf"));
        }
        this.dispatch_glTexParameterf1(n, n2, n3, addressof_glTexParameterf);
    }
    
    private native void dispatch_glTexParameterf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glTexParameteri(final int n, final int n2, final int n3) {
        final long addressof_glTexParameteri = this._pat._addressof_glTexParameteri;
        if (addressof_glTexParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameteri"));
        }
        this.dispatch_glTexParameteri1(n, n2, n3, addressof_glTexParameteri);
    }
    
    private native void dispatch_glTexParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTexParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTexParameterfv = this._pat._addressof_glTexParameterfv;
        if (addressof_glTexParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
        }
        this.dispatch_glTexParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTexParameterfv);
    }
    
    private native void dispatch_glTexParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexParameterfv = this._pat._addressof_glTexParameterfv;
        if (addressof_glTexParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
        }
        this.dispatch_glTexParameterfv1(n, n2, array, 4 * n3, false, addressof_glTexParameterfv);
    }
    
    @Override
    public void glTexParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexParameteriv = this._pat._addressof_glTexParameteriv;
        if (addressof_glTexParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
        }
        this.dispatch_glTexParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexParameteriv);
    }
    
    private native void dispatch_glTexParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexParameteriv = this._pat._addressof_glTexParameteriv;
        if (addressof_glTexParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
        }
        this.dispatch_glTexParameteriv1(n, n2, array, 4 * n3, false, addressof_glTexParameteriv);
    }
    
    @Override
    public void glGetTexParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTexParameterfv = this._pat._addressof_glGetTexParameterfv;
        if (addressof_glGetTexParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
        }
        this.dispatch_glGetTexParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTexParameterfv);
    }
    
    private native void dispatch_glGetTexParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexParameterfv = this._pat._addressof_glGetTexParameterfv;
        if (addressof_glGetTexParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
        }
        this.dispatch_glGetTexParameterfv1(n, n2, array, 4 * n3, false, addressof_glGetTexParameterfv);
    }
    
    @Override
    public void glGetTexParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTexParameteriv = this._pat._addressof_glGetTexParameteriv;
        if (addressof_glGetTexParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
        }
        this.dispatch_glGetTexParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTexParameteriv);
    }
    
    private native void dispatch_glGetTexParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexParameteriv = this._pat._addressof_glGetTexParameteriv;
        if (addressof_glGetTexParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
        }
        this.dispatch_glGetTexParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetTexParameteriv);
    }
    
    @Override
    public void glGetTexLevelParameterfv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTexLevelParameterfv = this._pat._addressof_glGetTexLevelParameterfv;
        if (addressof_glGetTexLevelParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameterfv"));
        }
        this.dispatch_glGetTexLevelParameterfv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTexLevelParameterfv);
    }
    
    private native void dispatch_glGetTexLevelParameterfv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTexLevelParameterfv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexLevelParameterfv = this._pat._addressof_glGetTexLevelParameterfv;
        if (addressof_glGetTexLevelParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameterfv"));
        }
        this.dispatch_glGetTexLevelParameterfv1(n, n2, n3, array, 4 * n4, false, addressof_glGetTexLevelParameterfv);
    }
    
    @Override
    public void glGetTexLevelParameteriv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTexLevelParameteriv = this._pat._addressof_glGetTexLevelParameteriv;
        if (addressof_glGetTexLevelParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameteriv"));
        }
        this.dispatch_glGetTexLevelParameteriv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTexLevelParameteriv);
    }
    
    private native void dispatch_glGetTexLevelParameteriv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTexLevelParameteriv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexLevelParameteriv = this._pat._addressof_glGetTexLevelParameteriv;
        if (addressof_glGetTexLevelParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameteriv"));
        }
        this.dispatch_glGetTexLevelParameteriv1(n, n2, n3, array, 4 * n4, false, addressof_glGetTexLevelParameteriv);
    }
    
    @Override
    public void glTexImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n6, n7, n4, 1, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTexImage1D = this._pat._addressof_glTexImage1D;
        if (addressof_glTexImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage1D"));
        }
        this.dispatch_glTexImage1D1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTexImage1D);
    }
    
    private native void dispatch_glTexImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glTexImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final long n8) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTexImage1D = this._pat._addressof_glTexImage1D;
        if (addressof_glTexImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage1D"));
        }
        this.dispatch_glTexImage1D1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glTexImage1D);
    }
    
    private native void dispatch_glTexImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7, final long p8);
    
    @Override
    public void glTexImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n7, n8, n4, n5, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTexImage2D = this._pat._addressof_glTexImage2D;
        if (addressof_glTexImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
        }
        this.dispatch_glTexImage2D1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTexImage2D);
    }
    
    private native void dispatch_glTexImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glTexImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final long n9) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTexImage2D = this._pat._addressof_glTexImage2D;
        if (addressof_glTexImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
        }
        this.dispatch_glTexImage2D1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glTexImage2D);
    }
    
    private native void dispatch_glTexImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8, final long p9);
    
    @Override
    public void glGetTexImage(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        this.checkPackPBOUnbound(true);
        int n5 = 1;
        final int[] array = { 0 };
        this.glGetTexLevelParameteriv(n, n2, 4096, array, 0);
        final int n6 = array[0];
        this.glGetTexLevelParameteriv(n, n2, 4097, array, 0);
        final int n7 = array[0];
        if (n == 32879) {
            this.glGetTexLevelParameteriv(n, n2, 32881, array, 0);
            n5 = array[0];
        }
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n3, n4, n6, n7, n5, true));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetTexImage = this._pat._addressof_glGetTexImage;
        if (addressof_glGetTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexImage"));
        }
        this.dispatch_glGetTexImage1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetTexImage);
    }
    
    private native void dispatch_glGetTexImage1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetTexImage(final int n, final int n2, final int n3, final int n4, final long n5) {
        this.checkPackPBOBound(true);
        final int[] array = { 0 };
        this.glGetTexLevelParameteriv(n, n2, 4096, array, 0);
        final int n6 = array[0];
        this.glGetTexLevelParameteriv(n, n2, 4097, array, 0);
        final int n7 = array[0];
        if (n == 32879) {
            this.glGetTexLevelParameteriv(n, n2, 32881, array, 0);
            final int n8 = array[0];
        }
        final long addressof_glGetTexImage = this._pat._addressof_glGetTexImage;
        if (addressof_glGetTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexImage"));
        }
        this.dispatch_glGetTexImage1(n, n2, n3, n4, n5, addressof_glGetTexImage);
    }
    
    private native void dispatch_glGetTexImage1(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glMap1d(final int n, final double n2, final double n3, final int n4, final int n5, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMap1d = this._pat._addressof_glMap1d;
        if (addressof_glMap1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap1d"));
        }
        this.dispatch_glMap1d1(n, n2, n3, n4, n5, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMap1d);
    }
    
    private native void dispatch_glMap1d1(final int p0, final double p1, final double p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glMap1d(final int n, final double n2, final double n3, final int n4, final int n5, final double[] array, final int n6) {
        if (array != null && array.length <= n6) {
            throw new GLException("array offset argument \"points_offset\" (" + n6 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMap1d = this._pat._addressof_glMap1d;
        if (addressof_glMap1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap1d"));
        }
        this.dispatch_glMap1d1(n, n2, n3, n4, n5, array, 8 * n6, false, addressof_glMap1d);
    }
    
    @Override
    public void glMap1f(final int n, final float n2, final float n3, final int n4, final int n5, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMap1f = this._pat._addressof_glMap1f;
        if (addressof_glMap1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap1f"));
        }
        this.dispatch_glMap1f1(n, n2, n3, n4, n5, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMap1f);
    }
    
    private native void dispatch_glMap1f1(final int p0, final float p1, final float p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glMap1f(final int n, final float n2, final float n3, final int n4, final int n5, final float[] array, final int n6) {
        if (array != null && array.length <= n6) {
            throw new GLException("array offset argument \"points_offset\" (" + n6 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMap1f = this._pat._addressof_glMap1f;
        if (addressof_glMap1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap1f"));
        }
        this.dispatch_glMap1f1(n, n2, n3, n4, n5, array, 4 * n6, false, addressof_glMap1f);
    }
    
    @Override
    public void glMap2d(final int n, final double n2, final double n3, final int n4, final int n5, final double n6, final double n7, final int n8, final int n9, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMap2d = this._pat._addressof_glMap2d;
        if (addressof_glMap2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap2d"));
        }
        this.dispatch_glMap2d1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMap2d);
    }
    
    private native void dispatch_glMap2d1(final int p0, final double p1, final double p2, final int p3, final int p4, final double p5, final double p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glMap2d(final int n, final double n2, final double n3, final int n4, final int n5, final double n6, final double n7, final int n8, final int n9, final double[] array, final int n10) {
        if (array != null && array.length <= n10) {
            throw new GLException("array offset argument \"points_offset\" (" + n10 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMap2d = this._pat._addressof_glMap2d;
        if (addressof_glMap2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap2d"));
        }
        this.dispatch_glMap2d1(n, n2, n3, n4, n5, n6, n7, n8, n9, array, 8 * n10, false, addressof_glMap2d);
    }
    
    @Override
    public void glMap2f(final int n, final float n2, final float n3, final int n4, final int n5, final float n6, final float n7, final int n8, final int n9, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMap2f = this._pat._addressof_glMap2f;
        if (addressof_glMap2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap2f"));
        }
        this.dispatch_glMap2f1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMap2f);
    }
    
    private native void dispatch_glMap2f1(final int p0, final float p1, final float p2, final int p3, final int p4, final float p5, final float p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glMap2f(final int n, final float n2, final float n3, final int n4, final int n5, final float n6, final float n7, final int n8, final int n9, final float[] array, final int n10) {
        if (array != null && array.length <= n10) {
            throw new GLException("array offset argument \"points_offset\" (" + n10 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMap2f = this._pat._addressof_glMap2f;
        if (addressof_glMap2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMap2f"));
        }
        this.dispatch_glMap2f1(n, n2, n3, n4, n5, n6, n7, n8, n9, array, 4 * n10, false, addressof_glMap2f);
    }
    
    @Override
    public void glGetMapdv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetMapdv = this._pat._addressof_glGetMapdv;
        if (addressof_glGetMapdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapdv"));
        }
        this.dispatch_glGetMapdv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetMapdv);
    }
    
    private native void dispatch_glGetMapdv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMapdv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMapdv = this._pat._addressof_glGetMapdv;
        if (addressof_glGetMapdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapdv"));
        }
        this.dispatch_glGetMapdv1(n, n2, array, 8 * n3, false, addressof_glGetMapdv);
    }
    
    @Override
    public void glGetMapfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMapfv = this._pat._addressof_glGetMapfv;
        if (addressof_glGetMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapfv"));
        }
        this.dispatch_glGetMapfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMapfv);
    }
    
    private native void dispatch_glGetMapfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMapfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMapfv = this._pat._addressof_glGetMapfv;
        if (addressof_glGetMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapfv"));
        }
        this.dispatch_glGetMapfv1(n, n2, array, 4 * n3, false, addressof_glGetMapfv);
    }
    
    @Override
    public void glGetMapiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMapiv = this._pat._addressof_glGetMapiv;
        if (addressof_glGetMapiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapiv"));
        }
        this.dispatch_glGetMapiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMapiv);
    }
    
    private native void dispatch_glGetMapiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMapiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMapiv = this._pat._addressof_glGetMapiv;
        if (addressof_glGetMapiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapiv"));
        }
        this.dispatch_glGetMapiv1(n, n2, array, 4 * n3, false, addressof_glGetMapiv);
    }
    
    @Override
    public void glEvalCoord1d(final double n) {
        final long addressof_glEvalCoord1d = this._pat._addressof_glEvalCoord1d;
        if (addressof_glEvalCoord1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1d"));
        }
        this.dispatch_glEvalCoord1d1(n, addressof_glEvalCoord1d);
    }
    
    private native void dispatch_glEvalCoord1d1(final double p0, final long p1);
    
    @Override
    public void glEvalCoord1f(final float n) {
        final long addressof_glEvalCoord1f = this._pat._addressof_glEvalCoord1f;
        if (addressof_glEvalCoord1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1f"));
        }
        this.dispatch_glEvalCoord1f1(n, addressof_glEvalCoord1f);
    }
    
    private native void dispatch_glEvalCoord1f1(final float p0, final long p1);
    
    @Override
    public void glEvalCoord1dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glEvalCoord1dv = this._pat._addressof_glEvalCoord1dv;
        if (addressof_glEvalCoord1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1dv"));
        }
        this.dispatch_glEvalCoord1dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glEvalCoord1dv);
    }
    
    private native void dispatch_glEvalCoord1dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glEvalCoord1dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"u_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glEvalCoord1dv = this._pat._addressof_glEvalCoord1dv;
        if (addressof_glEvalCoord1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1dv"));
        }
        this.dispatch_glEvalCoord1dv1(array, 8 * n, false, addressof_glEvalCoord1dv);
    }
    
    @Override
    public void glEvalCoord1fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glEvalCoord1fv = this._pat._addressof_glEvalCoord1fv;
        if (addressof_glEvalCoord1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1fv"));
        }
        this.dispatch_glEvalCoord1fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glEvalCoord1fv);
    }
    
    private native void dispatch_glEvalCoord1fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glEvalCoord1fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"u_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glEvalCoord1fv = this._pat._addressof_glEvalCoord1fv;
        if (addressof_glEvalCoord1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1fv"));
        }
        this.dispatch_glEvalCoord1fv1(array, 4 * n, false, addressof_glEvalCoord1fv);
    }
    
    @Override
    public void glEvalCoord2d(final double n, final double n2) {
        final long addressof_glEvalCoord2d = this._pat._addressof_glEvalCoord2d;
        if (addressof_glEvalCoord2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2d"));
        }
        this.dispatch_glEvalCoord2d1(n, n2, addressof_glEvalCoord2d);
    }
    
    private native void dispatch_glEvalCoord2d1(final double p0, final double p1, final long p2);
    
    @Override
    public void glEvalCoord2f(final float n, final float n2) {
        final long addressof_glEvalCoord2f = this._pat._addressof_glEvalCoord2f;
        if (addressof_glEvalCoord2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2f"));
        }
        this.dispatch_glEvalCoord2f1(n, n2, addressof_glEvalCoord2f);
    }
    
    private native void dispatch_glEvalCoord2f1(final float p0, final float p1, final long p2);
    
    @Override
    public void glEvalCoord2dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glEvalCoord2dv = this._pat._addressof_glEvalCoord2dv;
        if (addressof_glEvalCoord2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2dv"));
        }
        this.dispatch_glEvalCoord2dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glEvalCoord2dv);
    }
    
    private native void dispatch_glEvalCoord2dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glEvalCoord2dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"u_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glEvalCoord2dv = this._pat._addressof_glEvalCoord2dv;
        if (addressof_glEvalCoord2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2dv"));
        }
        this.dispatch_glEvalCoord2dv1(array, 8 * n, false, addressof_glEvalCoord2dv);
    }
    
    @Override
    public void glEvalCoord2fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glEvalCoord2fv = this._pat._addressof_glEvalCoord2fv;
        if (addressof_glEvalCoord2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2fv"));
        }
        this.dispatch_glEvalCoord2fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glEvalCoord2fv);
    }
    
    private native void dispatch_glEvalCoord2fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glEvalCoord2fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"u_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glEvalCoord2fv = this._pat._addressof_glEvalCoord2fv;
        if (addressof_glEvalCoord2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2fv"));
        }
        this.dispatch_glEvalCoord2fv1(array, 4 * n, false, addressof_glEvalCoord2fv);
    }
    
    @Override
    public void glMapGrid1d(final int n, final double n2, final double n3) {
        final long addressof_glMapGrid1d = this._pat._addressof_glMapGrid1d;
        if (addressof_glMapGrid1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapGrid1d"));
        }
        this.dispatch_glMapGrid1d1(n, n2, n3, addressof_glMapGrid1d);
    }
    
    private native void dispatch_glMapGrid1d1(final int p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glMapGrid1f(final int n, final float n2, final float n3) {
        final long addressof_glMapGrid1f = this._pat._addressof_glMapGrid1f;
        if (addressof_glMapGrid1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapGrid1f"));
        }
        this.dispatch_glMapGrid1f1(n, n2, n3, addressof_glMapGrid1f);
    }
    
    private native void dispatch_glMapGrid1f1(final int p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glMapGrid2d(final int n, final double n2, final double n3, final int n4, final double n5, final double n6) {
        final long addressof_glMapGrid2d = this._pat._addressof_glMapGrid2d;
        if (addressof_glMapGrid2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapGrid2d"));
        }
        this.dispatch_glMapGrid2d1(n, n2, n3, n4, n5, n6, addressof_glMapGrid2d);
    }
    
    private native void dispatch_glMapGrid2d1(final int p0, final double p1, final double p2, final int p3, final double p4, final double p5, final long p6);
    
    @Override
    public void glMapGrid2f(final int n, final float n2, final float n3, final int n4, final float n5, final float n6) {
        final long addressof_glMapGrid2f = this._pat._addressof_glMapGrid2f;
        if (addressof_glMapGrid2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapGrid2f"));
        }
        this.dispatch_glMapGrid2f1(n, n2, n3, n4, n5, n6, addressof_glMapGrid2f);
    }
    
    private native void dispatch_glMapGrid2f1(final int p0, final float p1, final float p2, final int p3, final float p4, final float p5, final long p6);
    
    @Override
    public void glEvalPoint1(final int n) {
        final long addressof_glEvalPoint1 = this._pat._addressof_glEvalPoint1;
        if (addressof_glEvalPoint1 == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalPoint1"));
        }
        this.dispatch_glEvalPoint11(n, addressof_glEvalPoint1);
    }
    
    private native void dispatch_glEvalPoint11(final int p0, final long p1);
    
    @Override
    public void glEvalPoint2(final int n, final int n2) {
        final long addressof_glEvalPoint2 = this._pat._addressof_glEvalPoint2;
        if (addressof_glEvalPoint2 == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalPoint2"));
        }
        this.dispatch_glEvalPoint21(n, n2, addressof_glEvalPoint2);
    }
    
    private native void dispatch_glEvalPoint21(final int p0, final int p1, final long p2);
    
    @Override
    public void glEvalMesh1(final int n, final int n2, final int n3) {
        final long addressof_glEvalMesh1 = this._pat._addressof_glEvalMesh1;
        if (addressof_glEvalMesh1 == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalMesh1"));
        }
        this.dispatch_glEvalMesh11(n, n2, n3, addressof_glEvalMesh1);
    }
    
    private native void dispatch_glEvalMesh11(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glEvalMesh2(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glEvalMesh2 = this._pat._addressof_glEvalMesh2;
        if (addressof_glEvalMesh2 == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalMesh2"));
        }
        this.dispatch_glEvalMesh21(n, n2, n3, n4, n5, addressof_glEvalMesh2);
    }
    
    private native void dispatch_glEvalMesh21(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glFogf(final int n, final float n2) {
        final long addressof_glFogf = this._pat._addressof_glFogf;
        if (addressof_glFogf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogf"));
        }
        this.dispatch_glFogf1(n, n2, addressof_glFogf);
    }
    
    private native void dispatch_glFogf1(final int p0, final float p1, final long p2);
    
    @Override
    public void glFogi(final int n, final int n2) {
        final long addressof_glFogi = this._pat._addressof_glFogi;
        if (addressof_glFogi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogi"));
        }
        this.dispatch_glFogi1(n, n2, addressof_glFogi);
    }
    
    private native void dispatch_glFogi1(final int p0, final int p1, final long p2);
    
    @Override
    public void glFogfv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glFogfv = this._pat._addressof_glFogfv;
        if (addressof_glFogfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogfv"));
        }
        this.dispatch_glFogfv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glFogfv);
    }
    
    private native void dispatch_glFogfv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glFogfv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFogfv = this._pat._addressof_glFogfv;
        if (addressof_glFogfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogfv"));
        }
        this.dispatch_glFogfv1(n, array, 4 * n2, false, addressof_glFogfv);
    }
    
    @Override
    public void glFogiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glFogiv = this._pat._addressof_glFogiv;
        if (addressof_glFogiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogiv"));
        }
        this.dispatch_glFogiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glFogiv);
    }
    
    private native void dispatch_glFogiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glFogiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFogiv = this._pat._addressof_glFogiv;
        if (addressof_glFogiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogiv"));
        }
        this.dispatch_glFogiv1(n, array, 4 * n2, false, addressof_glFogiv);
    }
    
    @Override
    public void glFeedbackBuffer(final int n, final int n2, final FloatBuffer floatBuffer) {
        if (!Buffers.isDirect(floatBuffer)) {
            throw new GLException("Argument \"buffer\" is not a direct buffer");
        }
        final long addressof_glFeedbackBuffer = this._pat._addressof_glFeedbackBuffer;
        if (addressof_glFeedbackBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFeedbackBuffer"));
        }
        this.dispatch_glFeedbackBuffer0(n, n2, floatBuffer, Buffers.getDirectBufferByteOffset(floatBuffer), addressof_glFeedbackBuffer);
    }
    
    private native void dispatch_glFeedbackBuffer0(final int p0, final int p1, final Object p2, final int p3, final long p4);
    
    @Override
    public void glPassThrough(final float n) {
        final long addressof_glPassThrough = this._pat._addressof_glPassThrough;
        if (addressof_glPassThrough == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPassThrough"));
        }
        this.dispatch_glPassThrough1(n, addressof_glPassThrough);
    }
    
    private native void dispatch_glPassThrough1(final float p0, final long p1);
    
    @Override
    public void glSelectBuffer(final int n, final IntBuffer intBuffer) {
        if (!Buffers.isDirect(intBuffer)) {
            throw new GLException("Argument \"buffer\" is not a direct buffer");
        }
        final long addressof_glSelectBuffer = this._pat._addressof_glSelectBuffer;
        if (addressof_glSelectBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSelectBuffer"));
        }
        this.dispatch_glSelectBuffer0(n, intBuffer, Buffers.getDirectBufferByteOffset(intBuffer), addressof_glSelectBuffer);
    }
    
    private native void dispatch_glSelectBuffer0(final int p0, final Object p1, final int p2, final long p3);
    
    @Override
    public void glInitNames() {
        final long addressof_glInitNames = this._pat._addressof_glInitNames;
        if (addressof_glInitNames == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInitNames"));
        }
        this.dispatch_glInitNames1(addressof_glInitNames);
    }
    
    private native void dispatch_glInitNames1(final long p0);
    
    @Override
    public void glLoadName(final int n) {
        final long addressof_glLoadName = this._pat._addressof_glLoadName;
        if (addressof_glLoadName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadName"));
        }
        this.dispatch_glLoadName1(n, addressof_glLoadName);
    }
    
    private native void dispatch_glLoadName1(final int p0, final long p1);
    
    @Override
    public void glPushName(final int n) {
        final long addressof_glPushName = this._pat._addressof_glPushName;
        if (addressof_glPushName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPushName"));
        }
        this.dispatch_glPushName1(n, addressof_glPushName);
    }
    
    private native void dispatch_glPushName1(final int p0, final long p1);
    
    @Override
    public void glPopName() {
        final long addressof_glPopName = this._pat._addressof_glPopName;
        if (addressof_glPopName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPopName"));
        }
        this.dispatch_glPopName1(addressof_glPopName);
    }
    
    private native void dispatch_glPopName1(final long p0);
    
    @Override
    public void glIndexub(final byte b) {
        final long addressof_glIndexub = this._pat._addressof_glIndexub;
        if (addressof_glIndexub == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexub"));
        }
        this.dispatch_glIndexub1(b, addressof_glIndexub);
    }
    
    private native void dispatch_glIndexub1(final byte p0, final long p1);
    
    @Override
    public void glIndexubv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glIndexubv = this._pat._addressof_glIndexubv;
        if (addressof_glIndexubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexubv"));
        }
        this.dispatch_glIndexubv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glIndexubv);
    }
    
    private native void dispatch_glIndexubv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glIndexubv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"c_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glIndexubv = this._pat._addressof_glIndexubv;
        if (addressof_glIndexubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexubv"));
        }
        this.dispatch_glIndexubv1(array, n, false, addressof_glIndexubv);
    }
    
    @Override
    public void glPushClientAttrib(final int n) {
        final long addressof_glPushClientAttrib = this._pat._addressof_glPushClientAttrib;
        if (addressof_glPushClientAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPushClientAttrib"));
        }
        this.dispatch_glPushClientAttrib1(n, addressof_glPushClientAttrib);
        this.bufferStateTracker.clear();
        this.glStateTracker.pushAttrib(n);
    }
    
    private native void dispatch_glPushClientAttrib1(final int p0, final long p1);
    
    @Override
    public void glPopClientAttrib() {
        final long addressof_glPopClientAttrib = this._pat._addressof_glPopClientAttrib;
        if (addressof_glPopClientAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPopClientAttrib"));
        }
        this.dispatch_glPopClientAttrib1(addressof_glPopClientAttrib);
        this.bufferStateTracker.clear();
        this.glStateTracker.popAttrib();
    }
    
    private native void dispatch_glPopClientAttrib1(final long p0);
    
    @Override
    public void glEnableClientState(final int n) {
        final long addressof_glEnableClientState = this._pat._addressof_glEnableClientState;
        if (addressof_glEnableClientState == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableClientState"));
        }
        this.dispatch_glEnableClientState1(n, addressof_glEnableClientState);
    }
    
    private native void dispatch_glEnableClientState1(final int p0, final long p1);
    
    @Override
    public void glDisableClientState(final int n) {
        final long addressof_glDisableClientState = this._pat._addressof_glDisableClientState;
        if (addressof_glDisableClientState == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableClientState"));
        }
        this.dispatch_glDisableClientState1(n, addressof_glDisableClientState);
    }
    
    private native void dispatch_glDisableClientState1(final int p0, final long p1);
    
    @Override
    public void glVertexPointer(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"ptr\" is not a direct buffer");
        }
        final long addressof_glVertexPointer = this._pat._addressof_glVertexPointer;
        if (addressof_glVertexPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexPointer"));
        }
        this.dispatch_glVertexPointer0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glVertexPointer);
    }
    
    private native void dispatch_glVertexPointer0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glVertexPointer(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glVertexPointer = this._pat._addressof_glVertexPointer;
        if (addressof_glVertexPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexPointer"));
        }
        this.dispatch_glVertexPointer0(n, n2, n3, n4, addressof_glVertexPointer);
    }
    
    private native void dispatch_glVertexPointer0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glNormalPointer(final int n, final int n2, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"ptr\" is not a direct buffer");
        }
        final long addressof_glNormalPointer = this._pat._addressof_glNormalPointer;
        if (addressof_glNormalPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormalPointer"));
        }
        this.dispatch_glNormalPointer0(n, n2, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glNormalPointer);
    }
    
    private native void dispatch_glNormalPointer0(final int p0, final int p1, final Object p2, final int p3, final long p4);
    
    @Override
    public void glNormalPointer(final int n, final int n2, final long n3) {
        this.checkArrayVBOBound(true);
        final long addressof_glNormalPointer = this._pat._addressof_glNormalPointer;
        if (addressof_glNormalPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormalPointer"));
        }
        this.dispatch_glNormalPointer0(n, n2, n3, addressof_glNormalPointer);
    }
    
    private native void dispatch_glNormalPointer0(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glColorPointer(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"ptr\" is not a direct buffer");
        }
        final long addressof_glColorPointer = this._pat._addressof_glColorPointer;
        if (addressof_glColorPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorPointer"));
        }
        this.dispatch_glColorPointer0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glColorPointer);
    }
    
    private native void dispatch_glColorPointer0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glColorPointer(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glColorPointer = this._pat._addressof_glColorPointer;
        if (addressof_glColorPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorPointer"));
        }
        this.dispatch_glColorPointer0(n, n2, n3, n4, addressof_glColorPointer);
    }
    
    private native void dispatch_glColorPointer0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glIndexPointer(final int n, final int n2, final Buffer buffer) {
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"ptr\" is not a direct buffer");
        }
        final long addressof_glIndexPointer = this._pat._addressof_glIndexPointer;
        if (addressof_glIndexPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexPointer"));
        }
        this.dispatch_glIndexPointer0(n, n2, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glIndexPointer);
    }
    
    private native void dispatch_glIndexPointer0(final int p0, final int p1, final Object p2, final int p3, final long p4);
    
    @Override
    public void glTexCoordPointer(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"ptr\" is not a direct buffer");
        }
        final long addressof_glTexCoordPointer = this._pat._addressof_glTexCoordPointer;
        if (addressof_glTexCoordPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordPointer"));
        }
        this.dispatch_glTexCoordPointer0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glTexCoordPointer);
    }
    
    private native void dispatch_glTexCoordPointer0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glTexCoordPointer(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glTexCoordPointer = this._pat._addressof_glTexCoordPointer;
        if (addressof_glTexCoordPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordPointer"));
        }
        this.dispatch_glTexCoordPointer0(n, n2, n3, n4, addressof_glTexCoordPointer);
    }
    
    private native void dispatch_glTexCoordPointer0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glEdgeFlagPointer(final int n, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"ptr\" is not a direct buffer");
        }
        final long addressof_glEdgeFlagPointer = this._pat._addressof_glEdgeFlagPointer;
        if (addressof_glEdgeFlagPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagPointer"));
        }
        this.dispatch_glEdgeFlagPointer0(n, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glEdgeFlagPointer);
    }
    
    private native void dispatch_glEdgeFlagPointer0(final int p0, final Object p1, final int p2, final long p3);
    
    @Override
    public void glEdgeFlagPointer(final int n, final long n2) {
        this.checkArrayVBOBound(true);
        final long addressof_glEdgeFlagPointer = this._pat._addressof_glEdgeFlagPointer;
        if (addressof_glEdgeFlagPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagPointer"));
        }
        this.dispatch_glEdgeFlagPointer0(n, n2, addressof_glEdgeFlagPointer);
    }
    
    private native void dispatch_glEdgeFlagPointer0(final int p0, final long p1, final long p2);
    
    @Override
    public void glArrayElement(final int n) {
        final long addressof_glArrayElement = this._pat._addressof_glArrayElement;
        if (addressof_glArrayElement == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glArrayElement"));
        }
        this.dispatch_glArrayElement1(n, addressof_glArrayElement);
    }
    
    private native void dispatch_glArrayElement1(final int p0, final long p1);
    
    @Override
    public void glDrawArrays(final int n, final int n2, final int n3) {
        final long addressof_glDrawArrays = this._pat._addressof_glDrawArrays;
        if (addressof_glDrawArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawArrays"));
        }
        this.dispatch_glDrawArrays1(n, n2, n3, addressof_glDrawArrays);
    }
    
    private native void dispatch_glDrawArrays1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glDrawElements(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n2);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawElements = this._pat._addressof_glDrawElements;
        if (addressof_glDrawElements == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
        }
        this.dispatch_glDrawElements1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glDrawElements);
    }
    
    private native void dispatch_glDrawElements1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glDrawElements(final int n, final int n2, final int n3, final long n4) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawElements = this._pat._addressof_glDrawElements;
        if (addressof_glDrawElements == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
        }
        this.dispatch_glDrawElements1(n, n2, n3, n4, addressof_glDrawElements);
    }
    
    private native void dispatch_glDrawElements1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glInterleavedArrays(final int n, final int n2, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glInterleavedArrays = this._pat._addressof_glInterleavedArrays;
        if (addressof_glInterleavedArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInterleavedArrays"));
        }
        this.dispatch_glInterleavedArrays1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glInterleavedArrays);
    }
    
    private native void dispatch_glInterleavedArrays1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glInterleavedArrays(final int n, final int n2, final long n3) {
        this.checkArrayVBOBound(true);
        final long addressof_glInterleavedArrays = this._pat._addressof_glInterleavedArrays;
        if (addressof_glInterleavedArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInterleavedArrays"));
        }
        this.dispatch_glInterleavedArrays1(n, n2, n3, addressof_glInterleavedArrays);
    }
    
    private native void dispatch_glInterleavedArrays1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glGenTextures(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenTextures = this._pat._addressof_glGenTextures;
        if (addressof_glGenTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
        }
        this.dispatch_glGenTextures1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenTextures);
    }
    
    private native void dispatch_glGenTextures1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenTextures(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"textures_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenTextures = this._pat._addressof_glGenTextures;
        if (addressof_glGenTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
        }
        this.dispatch_glGenTextures1(n, array, 4 * n2, false, addressof_glGenTextures);
    }
    
    @Override
    public void glDeleteTextures(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteTextures = this._pat._addressof_glDeleteTextures;
        if (addressof_glDeleteTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
        }
        this.dispatch_glDeleteTextures1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteTextures);
    }
    
    private native void dispatch_glDeleteTextures1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteTextures(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"textures_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteTextures = this._pat._addressof_glDeleteTextures;
        if (addressof_glDeleteTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
        }
        this.dispatch_glDeleteTextures1(n, array, 4 * n2, false, addressof_glDeleteTextures);
    }
    
    @Override
    public void glBindTexture(final int n, final int n2) {
        final long addressof_glBindTexture = this._pat._addressof_glBindTexture;
        if (addressof_glBindTexture == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTexture"));
        }
        this.dispatch_glBindTexture1(n, n2, addressof_glBindTexture);
    }
    
    private native void dispatch_glBindTexture1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPrioritizeTextures(final int n, final IntBuffer intBuffer, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(floatBuffer);
        final long addressof_glPrioritizeTextures = this._pat._addressof_glPrioritizeTextures;
        if (addressof_glPrioritizeTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPrioritizeTextures"));
        }
        this.dispatch_glPrioritizeTextures1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? floatBuffer : Buffers.getArray(floatBuffer), direct2 ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct2, addressof_glPrioritizeTextures);
    }
    
    private native void dispatch_glPrioritizeTextures1(final int p0, final Object p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glPrioritizeTextures(final int n, final int[] array, final int n2, final float[] array2, final int n3) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"textures_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"priorities_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glPrioritizeTextures = this._pat._addressof_glPrioritizeTextures;
        if (addressof_glPrioritizeTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPrioritizeTextures"));
        }
        this.dispatch_glPrioritizeTextures1(n, array, 4 * n2, false, array2, 4 * n3, false, addressof_glPrioritizeTextures);
    }
    
    @Override
    public boolean glAreTexturesResident(final int n, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glAreTexturesResident = this._pat._addressof_glAreTexturesResident;
        if (addressof_glAreTexturesResident == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glAreTexturesResident"));
        }
        return this.dispatch_glAreTexturesResident1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glAreTexturesResident);
    }
    
    private native boolean dispatch_glAreTexturesResident1(final int p0, final Object p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public boolean glAreTexturesResident(final int n, final int[] array, final int n2, final byte[] array2, final int n3) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"textures_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"residences_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glAreTexturesResident = this._pat._addressof_glAreTexturesResident;
        if (addressof_glAreTexturesResident == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glAreTexturesResident"));
        }
        return this.dispatch_glAreTexturesResident1(n, array, 4 * n2, false, array2, n3, false, addressof_glAreTexturesResident);
    }
    
    @Override
    public boolean glIsTexture(final int n) {
        final long addressof_glIsTexture = this._pat._addressof_glIsTexture;
        if (addressof_glIsTexture == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsTexture"));
        }
        return this.dispatch_glIsTexture1(n, addressof_glIsTexture);
    }
    
    private native boolean dispatch_glIsTexture1(final int p0, final long p1);
    
    @Override
    public void glTexSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n5, n6, n4, 1, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTexSubImage1D = this._pat._addressof_glTexSubImage1D;
        if (addressof_glTexSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage1D"));
        }
        this.dispatch_glTexSubImage1D1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTexSubImage1D);
    }
    
    private native void dispatch_glTexSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glTexSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTexSubImage1D = this._pat._addressof_glTexSubImage1D;
        if (addressof_glTexSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage1D"));
        }
        this.dispatch_glTexSubImage1D1(n, n2, n3, n4, n5, n6, n7, addressof_glTexSubImage1D);
    }
    
    private native void dispatch_glTexSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glTexSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n7, n8, n5, n6, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTexSubImage2D = this._pat._addressof_glTexSubImage2D;
        if (addressof_glTexSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
        }
        this.dispatch_glTexSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTexSubImage2D);
    }
    
    private native void dispatch_glTexSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glTexSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final long n9) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTexSubImage2D = this._pat._addressof_glTexSubImage2D;
        if (addressof_glTexSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
        }
        this.dispatch_glTexSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glTexSubImage2D);
    }
    
    private native void dispatch_glTexSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8, final long p9);
    
    @Override
    public void glCopyTexImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7) {
        final long addressof_glCopyTexImage1D = this._pat._addressof_glCopyTexImage1D;
        if (addressof_glCopyTexImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTexImage1D"));
        }
        this.dispatch_glCopyTexImage1D1(n, n2, n3, n4, n5, n6, n7, addressof_glCopyTexImage1D);
    }
    
    private native void dispatch_glCopyTexImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glCopyTexImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glCopyTexImage2D = this._pat._addressof_glCopyTexImage2D;
        if (addressof_glCopyTexImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTexImage2D"));
        }
        this.dispatch_glCopyTexImage2D1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glCopyTexImage2D);
    }
    
    private native void dispatch_glCopyTexImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glCopyTexSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glCopyTexSubImage1D = this._pat._addressof_glCopyTexSubImage1D;
        if (addressof_glCopyTexSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage1D"));
        }
        this.dispatch_glCopyTexSubImage1D1(n, n2, n3, n4, n5, n6, addressof_glCopyTexSubImage1D);
    }
    
    private native void dispatch_glCopyTexSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glCopyTexSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glCopyTexSubImage2D = this._pat._addressof_glCopyTexSubImage2D;
        if (addressof_glCopyTexSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage2D"));
        }
        this.dispatch_glCopyTexSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glCopyTexSubImage2D);
    }
    
    private native void dispatch_glCopyTexSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glTexStorage1D(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glTexStorage1D = this._pat._addressof_glTexStorage1D;
        if (addressof_glTexStorage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexStorage1D"));
        }
        this.dispatch_glTexStorage1D1(n, n2, n3, n4, addressof_glTexStorage1D);
    }
    
    private native void dispatch_glTexStorage1D1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glTexStorage2D(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glTexStorage2D = this._pat._addressof_glTexStorage2D;
        if (addressof_glTexStorage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2D"));
        }
        this.dispatch_glTexStorage2D1(n, n2, n3, n4, n5, addressof_glTexStorage2D);
    }
    
    private native void dispatch_glTexStorage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glTexStorage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glTexStorage3D = this._pat._addressof_glTexStorage3D;
        if (addressof_glTexStorage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3D"));
        }
        this.dispatch_glTexStorage3D1(n, n2, n3, n4, n5, n6, addressof_glTexStorage3D);
    }
    
    private native void dispatch_glTexStorage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glTextureStorage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glTextureStorage1DEXT = this._pat._addressof_glTextureStorage1DEXT;
        if (addressof_glTextureStorage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage1DEXT"));
        }
        this.dispatch_glTextureStorage1DEXT1(n, n2, n3, n4, n5, addressof_glTextureStorage1DEXT);
    }
    
    private native void dispatch_glTextureStorage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glTextureStorage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glTextureStorage2DEXT = this._pat._addressof_glTextureStorage2DEXT;
        if (addressof_glTextureStorage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DEXT"));
        }
        this.dispatch_glTextureStorage2DEXT1(n, n2, n3, n4, n5, n6, addressof_glTextureStorage2DEXT);
    }
    
    private native void dispatch_glTextureStorage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glTextureStorage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7) {
        final long addressof_glTextureStorage3DEXT = this._pat._addressof_glTextureStorage3DEXT;
        if (addressof_glTextureStorage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DEXT"));
        }
        this.dispatch_glTextureStorage3DEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glTextureStorage3DEXT);
    }
    
    private native void dispatch_glTextureStorage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glActiveShaderProgram(final int n, final int n2) {
        final long addressof_glActiveShaderProgram = this._pat._addressof_glActiveShaderProgram;
        if (addressof_glActiveShaderProgram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glActiveShaderProgram"));
        }
        this.dispatch_glActiveShaderProgram1(n, n2, addressof_glActiveShaderProgram);
    }
    
    private native void dispatch_glActiveShaderProgram1(final int p0, final int p1, final long p2);
    
    @Override
    public void glBindProgramPipeline(final int n) {
        final long addressof_glBindProgramPipeline = this._pat._addressof_glBindProgramPipeline;
        if (addressof_glBindProgramPipeline == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindProgramPipeline"));
        }
        this.dispatch_glBindProgramPipeline1(n, addressof_glBindProgramPipeline);
    }
    
    private native void dispatch_glBindProgramPipeline1(final int p0, final long p1);
    
    @Override
    public int glCreateShaderProgramv(final int n, final int n2, final String[] array) {
        final long addressof_glCreateShaderProgramv = this._pat._addressof_glCreateShaderProgramv;
        if (addressof_glCreateShaderProgramv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateShaderProgramv"));
        }
        return this.dispatch_glCreateShaderProgramv1(n, n2, array, addressof_glCreateShaderProgramv);
    }
    
    private native int dispatch_glCreateShaderProgramv1(final int p0, final int p1, final String[] p2, final long p3);
    
    @Override
    public void glDeleteProgramPipelines(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteProgramPipelines = this._pat._addressof_glDeleteProgramPipelines;
        if (addressof_glDeleteProgramPipelines == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramPipelines"));
        }
        this.dispatch_glDeleteProgramPipelines1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteProgramPipelines);
    }
    
    private native void dispatch_glDeleteProgramPipelines1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteProgramPipelines(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"pipelines_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteProgramPipelines = this._pat._addressof_glDeleteProgramPipelines;
        if (addressof_glDeleteProgramPipelines == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramPipelines"));
        }
        this.dispatch_glDeleteProgramPipelines1(n, array, 4 * n2, false, addressof_glDeleteProgramPipelines);
    }
    
    @Override
    public void glGenProgramPipelines(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenProgramPipelines = this._pat._addressof_glGenProgramPipelines;
        if (addressof_glGenProgramPipelines == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenProgramPipelines"));
        }
        this.dispatch_glGenProgramPipelines1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenProgramPipelines);
    }
    
    private native void dispatch_glGenProgramPipelines1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenProgramPipelines(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"pipelines_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenProgramPipelines = this._pat._addressof_glGenProgramPipelines;
        if (addressof_glGenProgramPipelines == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenProgramPipelines"));
        }
        this.dispatch_glGenProgramPipelines1(n, array, 4 * n2, false, addressof_glGenProgramPipelines);
    }
    
    @Override
    public void glGetProgramPipelineInfoLog(final int n, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetProgramPipelineInfoLog = this._pat._addressof_glGetProgramPipelineInfoLog;
        if (addressof_glGetProgramPipelineInfoLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineInfoLog"));
        }
        this.dispatch_glGetProgramPipelineInfoLog1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetProgramPipelineInfoLog);
    }
    
    private native void dispatch_glGetProgramPipelineInfoLog1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetProgramPipelineInfoLog(final int n, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"infoLog_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetProgramPipelineInfoLog = this._pat._addressof_glGetProgramPipelineInfoLog;
        if (addressof_glGetProgramPipelineInfoLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineInfoLog"));
        }
        this.dispatch_glGetProgramPipelineInfoLog1(n, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetProgramPipelineInfoLog);
    }
    
    @Override
    public void glGetProgramPipelineiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramPipelineiv = this._pat._addressof_glGetProgramPipelineiv;
        if (addressof_glGetProgramPipelineiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineiv"));
        }
        this.dispatch_glGetProgramPipelineiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramPipelineiv);
    }
    
    private native void dispatch_glGetProgramPipelineiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramPipelineiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramPipelineiv = this._pat._addressof_glGetProgramPipelineiv;
        if (addressof_glGetProgramPipelineiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineiv"));
        }
        this.dispatch_glGetProgramPipelineiv1(n, n2, array, 4 * n3, false, addressof_glGetProgramPipelineiv);
    }
    
    @Override
    public boolean glIsProgramPipeline(final int n) {
        final long addressof_glIsProgramPipeline = this._pat._addressof_glIsProgramPipeline;
        if (addressof_glIsProgramPipeline == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsProgramPipeline"));
        }
        return this.dispatch_glIsProgramPipeline1(n, addressof_glIsProgramPipeline);
    }
    
    private native boolean dispatch_glIsProgramPipeline1(final int p0, final long p1);
    
    @Override
    public void glProgramParameteri(final int n, final int n2, final int n3) {
        final long addressof_glProgramParameteri = this._pat._addressof_glProgramParameteri;
        if (addressof_glProgramParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramParameteri"));
        }
        this.dispatch_glProgramParameteri1(n, n2, n3, addressof_glProgramParameteri);
    }
    
    private native void dispatch_glProgramParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glProgramUniform1f(final int n, final int n2, final float n3) {
        final long addressof_glProgramUniform1f = this._pat._addressof_glProgramUniform1f;
        if (addressof_glProgramUniform1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1f"));
        }
        this.dispatch_glProgramUniform1f1(n, n2, n3, addressof_glProgramUniform1f);
    }
    
    private native void dispatch_glProgramUniform1f1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glProgramUniform1fv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniform1fv = this._pat._addressof_glProgramUniform1fv;
        if (addressof_glProgramUniform1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1fv"));
        }
        this.dispatch_glProgramUniform1fv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniform1fv);
    }
    
    private native void dispatch_glProgramUniform1fv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1fv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1fv = this._pat._addressof_glProgramUniform1fv;
        if (addressof_glProgramUniform1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1fv"));
        }
        this.dispatch_glProgramUniform1fv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform1fv);
    }
    
    @Override
    public void glProgramUniform1i(final int n, final int n2, final int n3) {
        final long addressof_glProgramUniform1i = this._pat._addressof_glProgramUniform1i;
        if (addressof_glProgramUniform1i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i"));
        }
        this.dispatch_glProgramUniform1i1(n, n2, n3, addressof_glProgramUniform1i);
    }
    
    private native void dispatch_glProgramUniform1i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glProgramUniform1iv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform1iv = this._pat._addressof_glProgramUniform1iv;
        if (addressof_glProgramUniform1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1iv"));
        }
        this.dispatch_glProgramUniform1iv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform1iv);
    }
    
    private native void dispatch_glProgramUniform1iv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1iv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1iv = this._pat._addressof_glProgramUniform1iv;
        if (addressof_glProgramUniform1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1iv"));
        }
        this.dispatch_glProgramUniform1iv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform1iv);
    }
    
    @Override
    public void glProgramUniform2f(final int n, final int n2, final float n3, final float n4) {
        final long addressof_glProgramUniform2f = this._pat._addressof_glProgramUniform2f;
        if (addressof_glProgramUniform2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2f"));
        }
        this.dispatch_glProgramUniform2f1(n, n2, n3, n4, addressof_glProgramUniform2f);
    }
    
    private native void dispatch_glProgramUniform2f1(final int p0, final int p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glProgramUniform2fv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniform2fv = this._pat._addressof_glProgramUniform2fv;
        if (addressof_glProgramUniform2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2fv"));
        }
        this.dispatch_glProgramUniform2fv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniform2fv);
    }
    
    private native void dispatch_glProgramUniform2fv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2fv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2fv = this._pat._addressof_glProgramUniform2fv;
        if (addressof_glProgramUniform2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2fv"));
        }
        this.dispatch_glProgramUniform2fv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform2fv);
    }
    
    @Override
    public void glProgramUniform2i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glProgramUniform2i = this._pat._addressof_glProgramUniform2i;
        if (addressof_glProgramUniform2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i"));
        }
        this.dispatch_glProgramUniform2i1(n, n2, n3, n4, addressof_glProgramUniform2i);
    }
    
    private native void dispatch_glProgramUniform2i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glProgramUniform2iv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform2iv = this._pat._addressof_glProgramUniform2iv;
        if (addressof_glProgramUniform2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2iv"));
        }
        this.dispatch_glProgramUniform2iv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform2iv);
    }
    
    private native void dispatch_glProgramUniform2iv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2iv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2iv = this._pat._addressof_glProgramUniform2iv;
        if (addressof_glProgramUniform2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2iv"));
        }
        this.dispatch_glProgramUniform2iv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform2iv);
    }
    
    @Override
    public void glProgramUniform3f(final int n, final int n2, final float n3, final float n4, final float n5) {
        final long addressof_glProgramUniform3f = this._pat._addressof_glProgramUniform3f;
        if (addressof_glProgramUniform3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3f"));
        }
        this.dispatch_glProgramUniform3f1(n, n2, n3, n4, n5, addressof_glProgramUniform3f);
    }
    
    private native void dispatch_glProgramUniform3f1(final int p0, final int p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glProgramUniform3fv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniform3fv = this._pat._addressof_glProgramUniform3fv;
        if (addressof_glProgramUniform3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3fv"));
        }
        this.dispatch_glProgramUniform3fv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniform3fv);
    }
    
    private native void dispatch_glProgramUniform3fv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3fv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3fv = this._pat._addressof_glProgramUniform3fv;
        if (addressof_glProgramUniform3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3fv"));
        }
        this.dispatch_glProgramUniform3fv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform3fv);
    }
    
    @Override
    public void glProgramUniform3i(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glProgramUniform3i = this._pat._addressof_glProgramUniform3i;
        if (addressof_glProgramUniform3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i"));
        }
        this.dispatch_glProgramUniform3i1(n, n2, n3, n4, n5, addressof_glProgramUniform3i);
    }
    
    private native void dispatch_glProgramUniform3i1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glProgramUniform3iv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform3iv = this._pat._addressof_glProgramUniform3iv;
        if (addressof_glProgramUniform3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3iv"));
        }
        this.dispatch_glProgramUniform3iv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform3iv);
    }
    
    private native void dispatch_glProgramUniform3iv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3iv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3iv = this._pat._addressof_glProgramUniform3iv;
        if (addressof_glProgramUniform3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3iv"));
        }
        this.dispatch_glProgramUniform3iv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform3iv);
    }
    
    @Override
    public void glProgramUniform4f(final int n, final int n2, final float n3, final float n4, final float n5, final float n6) {
        final long addressof_glProgramUniform4f = this._pat._addressof_glProgramUniform4f;
        if (addressof_glProgramUniform4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4f"));
        }
        this.dispatch_glProgramUniform4f1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4f);
    }
    
    private native void dispatch_glProgramUniform4f1(final int p0, final int p1, final float p2, final float p3, final float p4, final float p5, final long p6);
    
    @Override
    public void glProgramUniform4fv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniform4fv = this._pat._addressof_glProgramUniform4fv;
        if (addressof_glProgramUniform4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4fv"));
        }
        this.dispatch_glProgramUniform4fv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniform4fv);
    }
    
    private native void dispatch_glProgramUniform4fv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4fv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4fv = this._pat._addressof_glProgramUniform4fv;
        if (addressof_glProgramUniform4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4fv"));
        }
        this.dispatch_glProgramUniform4fv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform4fv);
    }
    
    @Override
    public void glProgramUniform4i(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glProgramUniform4i = this._pat._addressof_glProgramUniform4i;
        if (addressof_glProgramUniform4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i"));
        }
        this.dispatch_glProgramUniform4i1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4i);
    }
    
    private native void dispatch_glProgramUniform4i1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramUniform4iv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform4iv = this._pat._addressof_glProgramUniform4iv;
        if (addressof_glProgramUniform4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4iv"));
        }
        this.dispatch_glProgramUniform4iv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform4iv);
    }
    
    private native void dispatch_glProgramUniform4iv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4iv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4iv = this._pat._addressof_glProgramUniform4iv;
        if (addressof_glProgramUniform4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4iv"));
        }
        this.dispatch_glProgramUniform4iv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform4iv);
    }
    
    @Override
    public void glProgramUniformMatrix2fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix2fv = this._pat._addressof_glProgramUniformMatrix2fv;
        if (addressof_glProgramUniformMatrix2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2fv"));
        }
        this.dispatch_glProgramUniformMatrix2fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix2fv);
    }
    
    private native void dispatch_glProgramUniformMatrix2fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2fv = this._pat._addressof_glProgramUniformMatrix2fv;
        if (addressof_glProgramUniformMatrix2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2fv"));
        }
        this.dispatch_glProgramUniformMatrix2fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix2fv);
    }
    
    @Override
    public void glProgramUniformMatrix3fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix3fv = this._pat._addressof_glProgramUniformMatrix3fv;
        if (addressof_glProgramUniformMatrix3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3fv"));
        }
        this.dispatch_glProgramUniformMatrix3fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix3fv);
    }
    
    private native void dispatch_glProgramUniformMatrix3fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3fv = this._pat._addressof_glProgramUniformMatrix3fv;
        if (addressof_glProgramUniformMatrix3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3fv"));
        }
        this.dispatch_glProgramUniformMatrix3fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix3fv);
    }
    
    @Override
    public void glProgramUniformMatrix4fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix4fv = this._pat._addressof_glProgramUniformMatrix4fv;
        if (addressof_glProgramUniformMatrix4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4fv"));
        }
        this.dispatch_glProgramUniformMatrix4fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix4fv);
    }
    
    private native void dispatch_glProgramUniformMatrix4fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4fv = this._pat._addressof_glProgramUniformMatrix4fv;
        if (addressof_glProgramUniformMatrix4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4fv"));
        }
        this.dispatch_glProgramUniformMatrix4fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix4fv);
    }
    
    @Override
    public void glUseProgramStages(final int n, final int n2, final int n3) {
        final long addressof_glUseProgramStages = this._pat._addressof_glUseProgramStages;
        if (addressof_glUseProgramStages == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUseProgramStages"));
        }
        this.dispatch_glUseProgramStages1(n, n2, n3, addressof_glUseProgramStages);
    }
    
    private native void dispatch_glUseProgramStages1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glValidateProgramPipeline(final int n) {
        final long addressof_glValidateProgramPipeline = this._pat._addressof_glValidateProgramPipeline;
        if (addressof_glValidateProgramPipeline == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glValidateProgramPipeline"));
        }
        this.dispatch_glValidateProgramPipeline1(n, addressof_glValidateProgramPipeline);
    }
    
    private native void dispatch_glValidateProgramPipeline1(final int p0, final long p1);
    
    @Override
    public void glProgramUniform1ui(final int n, final int n2, final int n3) {
        final long addressof_glProgramUniform1ui = this._pat._addressof_glProgramUniform1ui;
        if (addressof_glProgramUniform1ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui"));
        }
        this.dispatch_glProgramUniform1ui1(n, n2, n3, addressof_glProgramUniform1ui);
    }
    
    private native void dispatch_glProgramUniform1ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glProgramUniform2ui(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glProgramUniform2ui = this._pat._addressof_glProgramUniform2ui;
        if (addressof_glProgramUniform2ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui"));
        }
        this.dispatch_glProgramUniform2ui1(n, n2, n3, n4, addressof_glProgramUniform2ui);
    }
    
    private native void dispatch_glProgramUniform2ui1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glProgramUniform3ui(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glProgramUniform3ui = this._pat._addressof_glProgramUniform3ui;
        if (addressof_glProgramUniform3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui"));
        }
        this.dispatch_glProgramUniform3ui1(n, n2, n3, n4, n5, addressof_glProgramUniform3ui);
    }
    
    private native void dispatch_glProgramUniform3ui1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glProgramUniform4ui(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glProgramUniform4ui = this._pat._addressof_glProgramUniform4ui;
        if (addressof_glProgramUniform4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui"));
        }
        this.dispatch_glProgramUniform4ui1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4ui);
    }
    
    private native void dispatch_glProgramUniform4ui1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramUniform1uiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform1uiv = this._pat._addressof_glProgramUniform1uiv;
        if (addressof_glProgramUniform1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1uiv"));
        }
        this.dispatch_glProgramUniform1uiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform1uiv);
    }
    
    private native void dispatch_glProgramUniform1uiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1uiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1uiv = this._pat._addressof_glProgramUniform1uiv;
        if (addressof_glProgramUniform1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1uiv"));
        }
        this.dispatch_glProgramUniform1uiv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform1uiv);
    }
    
    @Override
    public void glProgramUniform2uiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform2uiv = this._pat._addressof_glProgramUniform2uiv;
        if (addressof_glProgramUniform2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2uiv"));
        }
        this.dispatch_glProgramUniform2uiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform2uiv);
    }
    
    private native void dispatch_glProgramUniform2uiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2uiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2uiv = this._pat._addressof_glProgramUniform2uiv;
        if (addressof_glProgramUniform2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2uiv"));
        }
        this.dispatch_glProgramUniform2uiv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform2uiv);
    }
    
    @Override
    public void glProgramUniform3uiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform3uiv = this._pat._addressof_glProgramUniform3uiv;
        if (addressof_glProgramUniform3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3uiv"));
        }
        this.dispatch_glProgramUniform3uiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform3uiv);
    }
    
    private native void dispatch_glProgramUniform3uiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3uiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3uiv = this._pat._addressof_glProgramUniform3uiv;
        if (addressof_glProgramUniform3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3uiv"));
        }
        this.dispatch_glProgramUniform3uiv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform3uiv);
    }
    
    @Override
    public void glProgramUniform4uiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramUniform4uiv = this._pat._addressof_glProgramUniform4uiv;
        if (addressof_glProgramUniform4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4uiv"));
        }
        this.dispatch_glProgramUniform4uiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramUniform4uiv);
    }
    
    private native void dispatch_glProgramUniform4uiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4uiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4uiv = this._pat._addressof_glProgramUniform4uiv;
        if (addressof_glProgramUniform4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4uiv"));
        }
        this.dispatch_glProgramUniform4uiv1(n, n2, n3, array, 4 * n4, false, addressof_glProgramUniform4uiv);
    }
    
    @Override
    public void glProgramUniformMatrix2x3fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix2x3fv = this._pat._addressof_glProgramUniformMatrix2x3fv;
        if (addressof_glProgramUniformMatrix2x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3fv"));
        }
        this.dispatch_glProgramUniformMatrix2x3fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix2x3fv);
    }
    
    private native void dispatch_glProgramUniformMatrix2x3fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2x3fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2x3fv = this._pat._addressof_glProgramUniformMatrix2x3fv;
        if (addressof_glProgramUniformMatrix2x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3fv"));
        }
        this.dispatch_glProgramUniformMatrix2x3fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix2x3fv);
    }
    
    @Override
    public void glProgramUniformMatrix3x2fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix3x2fv = this._pat._addressof_glProgramUniformMatrix3x2fv;
        if (addressof_glProgramUniformMatrix3x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2fv"));
        }
        this.dispatch_glProgramUniformMatrix3x2fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix3x2fv);
    }
    
    private native void dispatch_glProgramUniformMatrix3x2fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3x2fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3x2fv = this._pat._addressof_glProgramUniformMatrix3x2fv;
        if (addressof_glProgramUniformMatrix3x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2fv"));
        }
        this.dispatch_glProgramUniformMatrix3x2fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix3x2fv);
    }
    
    @Override
    public void glProgramUniformMatrix2x4fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix2x4fv = this._pat._addressof_glProgramUniformMatrix2x4fv;
        if (addressof_glProgramUniformMatrix2x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4fv"));
        }
        this.dispatch_glProgramUniformMatrix2x4fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix2x4fv);
    }
    
    private native void dispatch_glProgramUniformMatrix2x4fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2x4fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2x4fv = this._pat._addressof_glProgramUniformMatrix2x4fv;
        if (addressof_glProgramUniformMatrix2x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4fv"));
        }
        this.dispatch_glProgramUniformMatrix2x4fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix2x4fv);
    }
    
    @Override
    public void glProgramUniformMatrix4x2fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix4x2fv = this._pat._addressof_glProgramUniformMatrix4x2fv;
        if (addressof_glProgramUniformMatrix4x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2fv"));
        }
        this.dispatch_glProgramUniformMatrix4x2fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix4x2fv);
    }
    
    private native void dispatch_glProgramUniformMatrix4x2fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4x2fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4x2fv = this._pat._addressof_glProgramUniformMatrix4x2fv;
        if (addressof_glProgramUniformMatrix4x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2fv"));
        }
        this.dispatch_glProgramUniformMatrix4x2fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix4x2fv);
    }
    
    @Override
    public void glProgramUniformMatrix3x4fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix3x4fv = this._pat._addressof_glProgramUniformMatrix3x4fv;
        if (addressof_glProgramUniformMatrix3x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4fv"));
        }
        this.dispatch_glProgramUniformMatrix3x4fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix3x4fv);
    }
    
    private native void dispatch_glProgramUniformMatrix3x4fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3x4fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3x4fv = this._pat._addressof_glProgramUniformMatrix3x4fv;
        if (addressof_glProgramUniformMatrix3x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4fv"));
        }
        this.dispatch_glProgramUniformMatrix3x4fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix3x4fv);
    }
    
    @Override
    public void glProgramUniformMatrix4x3fv(final int n, final int n2, final int n3, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramUniformMatrix4x3fv = this._pat._addressof_glProgramUniformMatrix4x3fv;
        if (addressof_glProgramUniformMatrix4x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3fv"));
        }
        this.dispatch_glProgramUniformMatrix4x3fv1(n, n2, n3, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramUniformMatrix4x3fv);
    }
    
    private native void dispatch_glProgramUniformMatrix4x3fv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4x3fv(final int n, final int n2, final int n3, final boolean b, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4x3fv = this._pat._addressof_glProgramUniformMatrix4x3fv;
        if (addressof_glProgramUniformMatrix4x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3fv"));
        }
        this.dispatch_glProgramUniformMatrix4x3fv1(n, n2, n3, b, array, 4 * n4, false, addressof_glProgramUniformMatrix4x3fv);
    }
    
    @Override
    public void glDrawRangeElements(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n4);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawRangeElements = this._pat._addressof_glDrawRangeElements;
        if (addressof_glDrawRangeElements == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
        }
        this.dispatch_glDrawRangeElements1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glDrawRangeElements);
    }
    
    private native void dispatch_glDrawRangeElements1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glDrawRangeElements(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawRangeElements = this._pat._addressof_glDrawRangeElements;
        if (addressof_glDrawRangeElements == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
        }
        this.dispatch_glDrawRangeElements1(n, n2, n3, n4, n5, n6, addressof_glDrawRangeElements);
    }
    
    private native void dispatch_glDrawRangeElements1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glTexImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n8, n9, n4, n5, n6, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTexImage3D = this._pat._addressof_glTexImage3D;
        if (addressof_glTexImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
        }
        this.dispatch_glTexImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTexImage3D);
    }
    
    private native void dispatch_glTexImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glTexImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final long n10) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTexImage3D = this._pat._addressof_glTexImage3D;
        if (addressof_glTexImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
        }
        this.dispatch_glTexImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, addressof_glTexImage3D);
    }
    
    private native void dispatch_glTexImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9, final long p10);
    
    @Override
    public void glTexSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n9, n10, n6, n7, n8, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTexSubImage3D = this._pat._addressof_glTexSubImage3D;
        if (addressof_glTexSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
        }
        this.dispatch_glTexSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTexSubImage3D);
    }
    
    private native void dispatch_glTexSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glTexSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final long n11) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTexSubImage3D = this._pat._addressof_glTexSubImage3D;
        if (addressof_glTexSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
        }
        this.dispatch_glTexSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, addressof_glTexSubImage3D);
    }
    
    private native void dispatch_glTexSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final long p10, final long p11);
    
    @Override
    public void glCopyTexSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9) {
        final long addressof_glCopyTexSubImage3D = this._pat._addressof_glCopyTexSubImage3D;
        if (addressof_glCopyTexSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage3D"));
        }
        this.dispatch_glCopyTexSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCopyTexSubImage3D);
    }
    
    private native void dispatch_glCopyTexSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glActiveTexture(final int n) {
        final long addressof_glActiveTexture = this._pat._addressof_glActiveTexture;
        if (addressof_glActiveTexture == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glActiveTexture"));
        }
        this.dispatch_glActiveTexture1(n, addressof_glActiveTexture);
    }
    
    private native void dispatch_glActiveTexture1(final int p0, final long p1);
    
    @Override
    public void glSampleCoverage(final float n, final boolean b) {
        final long addressof_glSampleCoverage = this._pat._addressof_glSampleCoverage;
        if (addressof_glSampleCoverage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSampleCoverage"));
        }
        this.dispatch_glSampleCoverage1(n, b, addressof_glSampleCoverage);
    }
    
    private native void dispatch_glSampleCoverage1(final float p0, final boolean p1, final long p2);
    
    @Override
    public void glCompressedTexImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTexImage3D = this._pat._addressof_glCompressedTexImage3D;
        if (addressof_glCompressedTexImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
        }
        this.dispatch_glCompressedTexImage3D1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTexImage3D);
    }
    
    private native void dispatch_glCompressedTexImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glCompressedTexImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final long n9) {
        this.checkUnpackPBOBound(true);
        final long addressof_glCompressedTexImage3D = this._pat._addressof_glCompressedTexImage3D;
        if (addressof_glCompressedTexImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
        }
        this.dispatch_glCompressedTexImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCompressedTexImage3D);
    }
    
    private native void dispatch_glCompressedTexImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8, final long p9);
    
    @Override
    public void glCompressedTexImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTexImage2D = this._pat._addressof_glCompressedTexImage2D;
        if (addressof_glCompressedTexImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
        }
        this.dispatch_glCompressedTexImage2D1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTexImage2D);
    }
    
    private native void dispatch_glCompressedTexImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glCompressedTexImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final long n8) {
        this.checkUnpackPBOBound(true);
        final long addressof_glCompressedTexImage2D = this._pat._addressof_glCompressedTexImage2D;
        if (addressof_glCompressedTexImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
        }
        this.dispatch_glCompressedTexImage2D1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glCompressedTexImage2D);
    }
    
    private native void dispatch_glCompressedTexImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7, final long p8);
    
    @Override
    public void glCompressedTexImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTexImage1D = this._pat._addressof_glCompressedTexImage1D;
        if (addressof_glCompressedTexImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage1D"));
        }
        this.dispatch_glCompressedTexImage1D1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTexImage1D);
    }
    
    private native void dispatch_glCompressedTexImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glCompressedTexImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        this.checkUnpackPBOBound(true);
        final long addressof_glCompressedTexImage1D = this._pat._addressof_glCompressedTexImage1D;
        if (addressof_glCompressedTexImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage1D"));
        }
        this.dispatch_glCompressedTexImage1D1(n, n2, n3, n4, n5, n6, n7, addressof_glCompressedTexImage1D);
    }
    
    private native void dispatch_glCompressedTexImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glCompressedTexSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTexSubImage3D = this._pat._addressof_glCompressedTexSubImage3D;
        if (addressof_glCompressedTexSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
        }
        this.dispatch_glCompressedTexSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTexSubImage3D);
    }
    
    private native void dispatch_glCompressedTexSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glCompressedTexSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final long n11) {
        this.checkUnpackPBOBound(true);
        final long addressof_glCompressedTexSubImage3D = this._pat._addressof_glCompressedTexSubImage3D;
        if (addressof_glCompressedTexSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
        }
        this.dispatch_glCompressedTexSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, addressof_glCompressedTexSubImage3D);
    }
    
    private native void dispatch_glCompressedTexSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final long p10, final long p11);
    
    @Override
    public void glCompressedTexSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTexSubImage2D = this._pat._addressof_glCompressedTexSubImage2D;
        if (addressof_glCompressedTexSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
        }
        this.dispatch_glCompressedTexSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTexSubImage2D);
    }
    
    private native void dispatch_glCompressedTexSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glCompressedTexSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final long n9) {
        this.checkUnpackPBOBound(true);
        final long addressof_glCompressedTexSubImage2D = this._pat._addressof_glCompressedTexSubImage2D;
        if (addressof_glCompressedTexSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
        }
        this.dispatch_glCompressedTexSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCompressedTexSubImage2D);
    }
    
    private native void dispatch_glCompressedTexSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8, final long p9);
    
    @Override
    public void glCompressedTexSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTexSubImage1D = this._pat._addressof_glCompressedTexSubImage1D;
        if (addressof_glCompressedTexSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage1D"));
        }
        this.dispatch_glCompressedTexSubImage1D1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTexSubImage1D);
    }
    
    private native void dispatch_glCompressedTexSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glCompressedTexSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        this.checkUnpackPBOBound(true);
        final long addressof_glCompressedTexSubImage1D = this._pat._addressof_glCompressedTexSubImage1D;
        if (addressof_glCompressedTexSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage1D"));
        }
        this.dispatch_glCompressedTexSubImage1D1(n, n2, n3, n4, n5, n6, n7, addressof_glCompressedTexSubImage1D);
    }
    
    private native void dispatch_glCompressedTexSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glGetCompressedTexImage(final int n, final int n2, final Buffer buffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetCompressedTexImage = this._pat._addressof_glGetCompressedTexImage;
        if (addressof_glGetCompressedTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTexImage"));
        }
        this.dispatch_glGetCompressedTexImage1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetCompressedTexImage);
    }
    
    private native void dispatch_glGetCompressedTexImage1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetCompressedTexImage(final int n, final int n2, final long n3) {
        this.checkPackPBOBound(true);
        final long addressof_glGetCompressedTexImage = this._pat._addressof_glGetCompressedTexImage;
        if (addressof_glGetCompressedTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTexImage"));
        }
        this.dispatch_glGetCompressedTexImage1(n, n2, n3, addressof_glGetCompressedTexImage);
    }
    
    private native void dispatch_glGetCompressedTexImage1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glClientActiveTexture(final int n) {
        final long addressof_glClientActiveTexture = this._pat._addressof_glClientActiveTexture;
        if (addressof_glClientActiveTexture == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClientActiveTexture"));
        }
        this.dispatch_glClientActiveTexture1(n, addressof_glClientActiveTexture);
    }
    
    private native void dispatch_glClientActiveTexture1(final int p0, final long p1);
    
    @Override
    public void glMultiTexCoord1d(final int n, final double n2) {
        final long addressof_glMultiTexCoord1d = this._pat._addressof_glMultiTexCoord1d;
        if (addressof_glMultiTexCoord1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1d"));
        }
        this.dispatch_glMultiTexCoord1d1(n, n2, addressof_glMultiTexCoord1d);
    }
    
    private native void dispatch_glMultiTexCoord1d1(final int p0, final double p1, final long p2);
    
    @Override
    public void glMultiTexCoord1dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMultiTexCoord1dv = this._pat._addressof_glMultiTexCoord1dv;
        if (addressof_glMultiTexCoord1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1dv"));
        }
        this.dispatch_glMultiTexCoord1dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMultiTexCoord1dv);
    }
    
    private native void dispatch_glMultiTexCoord1dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord1dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord1dv = this._pat._addressof_glMultiTexCoord1dv;
        if (addressof_glMultiTexCoord1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1dv"));
        }
        this.dispatch_glMultiTexCoord1dv1(n, array, 8 * n2, false, addressof_glMultiTexCoord1dv);
    }
    
    @Override
    public void glMultiTexCoord1f(final int n, final float n2) {
        final long addressof_glMultiTexCoord1f = this._pat._addressof_glMultiTexCoord1f;
        if (addressof_glMultiTexCoord1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1f"));
        }
        this.dispatch_glMultiTexCoord1f1(n, n2, addressof_glMultiTexCoord1f);
    }
    
    private native void dispatch_glMultiTexCoord1f1(final int p0, final float p1, final long p2);
    
    @Override
    public void glMultiTexCoord1fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultiTexCoord1fv = this._pat._addressof_glMultiTexCoord1fv;
        if (addressof_glMultiTexCoord1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1fv"));
        }
        this.dispatch_glMultiTexCoord1fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultiTexCoord1fv);
    }
    
    private native void dispatch_glMultiTexCoord1fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord1fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord1fv = this._pat._addressof_glMultiTexCoord1fv;
        if (addressof_glMultiTexCoord1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1fv"));
        }
        this.dispatch_glMultiTexCoord1fv1(n, array, 4 * n2, false, addressof_glMultiTexCoord1fv);
    }
    
    @Override
    public void glMultiTexCoord1i(final int n, final int n2) {
        final long addressof_glMultiTexCoord1i = this._pat._addressof_glMultiTexCoord1i;
        if (addressof_glMultiTexCoord1i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1i"));
        }
        this.dispatch_glMultiTexCoord1i1(n, n2, addressof_glMultiTexCoord1i);
    }
    
    private native void dispatch_glMultiTexCoord1i1(final int p0, final int p1, final long p2);
    
    @Override
    public void glMultiTexCoord1iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoord1iv = this._pat._addressof_glMultiTexCoord1iv;
        if (addressof_glMultiTexCoord1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1iv"));
        }
        this.dispatch_glMultiTexCoord1iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoord1iv);
    }
    
    private native void dispatch_glMultiTexCoord1iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord1iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord1iv = this._pat._addressof_glMultiTexCoord1iv;
        if (addressof_glMultiTexCoord1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1iv"));
        }
        this.dispatch_glMultiTexCoord1iv1(n, array, 4 * n2, false, addressof_glMultiTexCoord1iv);
    }
    
    @Override
    public void glMultiTexCoord1s(final int n, final short n2) {
        final long addressof_glMultiTexCoord1s = this._pat._addressof_glMultiTexCoord1s;
        if (addressof_glMultiTexCoord1s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1s"));
        }
        this.dispatch_glMultiTexCoord1s1(n, n2, addressof_glMultiTexCoord1s);
    }
    
    private native void dispatch_glMultiTexCoord1s1(final int p0, final short p1, final long p2);
    
    @Override
    public void glMultiTexCoord1sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord1sv = this._pat._addressof_glMultiTexCoord1sv;
        if (addressof_glMultiTexCoord1sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1sv"));
        }
        this.dispatch_glMultiTexCoord1sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord1sv);
    }
    
    private native void dispatch_glMultiTexCoord1sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord1sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord1sv = this._pat._addressof_glMultiTexCoord1sv;
        if (addressof_glMultiTexCoord1sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1sv"));
        }
        this.dispatch_glMultiTexCoord1sv1(n, array, 2 * n2, false, addressof_glMultiTexCoord1sv);
    }
    
    @Override
    public void glMultiTexCoord2d(final int n, final double n2, final double n3) {
        final long addressof_glMultiTexCoord2d = this._pat._addressof_glMultiTexCoord2d;
        if (addressof_glMultiTexCoord2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2d"));
        }
        this.dispatch_glMultiTexCoord2d1(n, n2, n3, addressof_glMultiTexCoord2d);
    }
    
    private native void dispatch_glMultiTexCoord2d1(final int p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glMultiTexCoord2dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMultiTexCoord2dv = this._pat._addressof_glMultiTexCoord2dv;
        if (addressof_glMultiTexCoord2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2dv"));
        }
        this.dispatch_glMultiTexCoord2dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMultiTexCoord2dv);
    }
    
    private native void dispatch_glMultiTexCoord2dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord2dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord2dv = this._pat._addressof_glMultiTexCoord2dv;
        if (addressof_glMultiTexCoord2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2dv"));
        }
        this.dispatch_glMultiTexCoord2dv1(n, array, 8 * n2, false, addressof_glMultiTexCoord2dv);
    }
    
    @Override
    public void glMultiTexCoord2f(final int n, final float n2, final float n3) {
        final long addressof_glMultiTexCoord2f = this._pat._addressof_glMultiTexCoord2f;
        if (addressof_glMultiTexCoord2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2f"));
        }
        this.dispatch_glMultiTexCoord2f1(n, n2, n3, addressof_glMultiTexCoord2f);
    }
    
    private native void dispatch_glMultiTexCoord2f1(final int p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glMultiTexCoord2fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultiTexCoord2fv = this._pat._addressof_glMultiTexCoord2fv;
        if (addressof_glMultiTexCoord2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2fv"));
        }
        this.dispatch_glMultiTexCoord2fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultiTexCoord2fv);
    }
    
    private native void dispatch_glMultiTexCoord2fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord2fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord2fv = this._pat._addressof_glMultiTexCoord2fv;
        if (addressof_glMultiTexCoord2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2fv"));
        }
        this.dispatch_glMultiTexCoord2fv1(n, array, 4 * n2, false, addressof_glMultiTexCoord2fv);
    }
    
    @Override
    public void glMultiTexCoord2i(final int n, final int n2, final int n3) {
        final long addressof_glMultiTexCoord2i = this._pat._addressof_glMultiTexCoord2i;
        if (addressof_glMultiTexCoord2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2i"));
        }
        this.dispatch_glMultiTexCoord2i1(n, n2, n3, addressof_glMultiTexCoord2i);
    }
    
    private native void dispatch_glMultiTexCoord2i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiTexCoord2iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoord2iv = this._pat._addressof_glMultiTexCoord2iv;
        if (addressof_glMultiTexCoord2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2iv"));
        }
        this.dispatch_glMultiTexCoord2iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoord2iv);
    }
    
    private native void dispatch_glMultiTexCoord2iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord2iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord2iv = this._pat._addressof_glMultiTexCoord2iv;
        if (addressof_glMultiTexCoord2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2iv"));
        }
        this.dispatch_glMultiTexCoord2iv1(n, array, 4 * n2, false, addressof_glMultiTexCoord2iv);
    }
    
    @Override
    public void glMultiTexCoord2s(final int n, final short n2, final short n3) {
        final long addressof_glMultiTexCoord2s = this._pat._addressof_glMultiTexCoord2s;
        if (addressof_glMultiTexCoord2s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2s"));
        }
        this.dispatch_glMultiTexCoord2s1(n, n2, n3, addressof_glMultiTexCoord2s);
    }
    
    private native void dispatch_glMultiTexCoord2s1(final int p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glMultiTexCoord2sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord2sv = this._pat._addressof_glMultiTexCoord2sv;
        if (addressof_glMultiTexCoord2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2sv"));
        }
        this.dispatch_glMultiTexCoord2sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord2sv);
    }
    
    private native void dispatch_glMultiTexCoord2sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord2sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord2sv = this._pat._addressof_glMultiTexCoord2sv;
        if (addressof_glMultiTexCoord2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2sv"));
        }
        this.dispatch_glMultiTexCoord2sv1(n, array, 2 * n2, false, addressof_glMultiTexCoord2sv);
    }
    
    @Override
    public void glMultiTexCoord3d(final int n, final double n2, final double n3, final double n4) {
        final long addressof_glMultiTexCoord3d = this._pat._addressof_glMultiTexCoord3d;
        if (addressof_glMultiTexCoord3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3d"));
        }
        this.dispatch_glMultiTexCoord3d1(n, n2, n3, n4, addressof_glMultiTexCoord3d);
    }
    
    private native void dispatch_glMultiTexCoord3d1(final int p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glMultiTexCoord3dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMultiTexCoord3dv = this._pat._addressof_glMultiTexCoord3dv;
        if (addressof_glMultiTexCoord3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3dv"));
        }
        this.dispatch_glMultiTexCoord3dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMultiTexCoord3dv);
    }
    
    private native void dispatch_glMultiTexCoord3dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord3dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord3dv = this._pat._addressof_glMultiTexCoord3dv;
        if (addressof_glMultiTexCoord3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3dv"));
        }
        this.dispatch_glMultiTexCoord3dv1(n, array, 8 * n2, false, addressof_glMultiTexCoord3dv);
    }
    
    @Override
    public void glMultiTexCoord3f(final int n, final float n2, final float n3, final float n4) {
        final long addressof_glMultiTexCoord3f = this._pat._addressof_glMultiTexCoord3f;
        if (addressof_glMultiTexCoord3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3f"));
        }
        this.dispatch_glMultiTexCoord3f1(n, n2, n3, n4, addressof_glMultiTexCoord3f);
    }
    
    private native void dispatch_glMultiTexCoord3f1(final int p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glMultiTexCoord3fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultiTexCoord3fv = this._pat._addressof_glMultiTexCoord3fv;
        if (addressof_glMultiTexCoord3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3fv"));
        }
        this.dispatch_glMultiTexCoord3fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultiTexCoord3fv);
    }
    
    private native void dispatch_glMultiTexCoord3fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord3fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord3fv = this._pat._addressof_glMultiTexCoord3fv;
        if (addressof_glMultiTexCoord3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3fv"));
        }
        this.dispatch_glMultiTexCoord3fv1(n, array, 4 * n2, false, addressof_glMultiTexCoord3fv);
    }
    
    @Override
    public void glMultiTexCoord3i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glMultiTexCoord3i = this._pat._addressof_glMultiTexCoord3i;
        if (addressof_glMultiTexCoord3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3i"));
        }
        this.dispatch_glMultiTexCoord3i1(n, n2, n3, n4, addressof_glMultiTexCoord3i);
    }
    
    private native void dispatch_glMultiTexCoord3i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glMultiTexCoord3iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoord3iv = this._pat._addressof_glMultiTexCoord3iv;
        if (addressof_glMultiTexCoord3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3iv"));
        }
        this.dispatch_glMultiTexCoord3iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoord3iv);
    }
    
    private native void dispatch_glMultiTexCoord3iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord3iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord3iv = this._pat._addressof_glMultiTexCoord3iv;
        if (addressof_glMultiTexCoord3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3iv"));
        }
        this.dispatch_glMultiTexCoord3iv1(n, array, 4 * n2, false, addressof_glMultiTexCoord3iv);
    }
    
    @Override
    public void glMultiTexCoord3s(final int n, final short n2, final short n3, final short n4) {
        final long addressof_glMultiTexCoord3s = this._pat._addressof_glMultiTexCoord3s;
        if (addressof_glMultiTexCoord3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3s"));
        }
        this.dispatch_glMultiTexCoord3s1(n, n2, n3, n4, addressof_glMultiTexCoord3s);
    }
    
    private native void dispatch_glMultiTexCoord3s1(final int p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glMultiTexCoord3sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord3sv = this._pat._addressof_glMultiTexCoord3sv;
        if (addressof_glMultiTexCoord3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3sv"));
        }
        this.dispatch_glMultiTexCoord3sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord3sv);
    }
    
    private native void dispatch_glMultiTexCoord3sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord3sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord3sv = this._pat._addressof_glMultiTexCoord3sv;
        if (addressof_glMultiTexCoord3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3sv"));
        }
        this.dispatch_glMultiTexCoord3sv1(n, array, 2 * n2, false, addressof_glMultiTexCoord3sv);
    }
    
    @Override
    public void glMultiTexCoord4d(final int n, final double n2, final double n3, final double n4, final double n5) {
        final long addressof_glMultiTexCoord4d = this._pat._addressof_glMultiTexCoord4d;
        if (addressof_glMultiTexCoord4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4d"));
        }
        this.dispatch_glMultiTexCoord4d1(n, n2, n3, n4, n5, addressof_glMultiTexCoord4d);
    }
    
    private native void dispatch_glMultiTexCoord4d1(final int p0, final double p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glMultiTexCoord4dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMultiTexCoord4dv = this._pat._addressof_glMultiTexCoord4dv;
        if (addressof_glMultiTexCoord4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4dv"));
        }
        this.dispatch_glMultiTexCoord4dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMultiTexCoord4dv);
    }
    
    private native void dispatch_glMultiTexCoord4dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord4dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord4dv = this._pat._addressof_glMultiTexCoord4dv;
        if (addressof_glMultiTexCoord4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4dv"));
        }
        this.dispatch_glMultiTexCoord4dv1(n, array, 8 * n2, false, addressof_glMultiTexCoord4dv);
    }
    
    @Override
    public void glMultiTexCoord4f(final int n, final float n2, final float n3, final float n4, final float n5) {
        final long addressof_glMultiTexCoord4f = this._pat._addressof_glMultiTexCoord4f;
        if (addressof_glMultiTexCoord4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4f"));
        }
        this.dispatch_glMultiTexCoord4f1(n, n2, n3, n4, n5, addressof_glMultiTexCoord4f);
    }
    
    private native void dispatch_glMultiTexCoord4f1(final int p0, final float p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glMultiTexCoord4fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultiTexCoord4fv = this._pat._addressof_glMultiTexCoord4fv;
        if (addressof_glMultiTexCoord4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4fv"));
        }
        this.dispatch_glMultiTexCoord4fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultiTexCoord4fv);
    }
    
    private native void dispatch_glMultiTexCoord4fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord4fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord4fv = this._pat._addressof_glMultiTexCoord4fv;
        if (addressof_glMultiTexCoord4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4fv"));
        }
        this.dispatch_glMultiTexCoord4fv1(n, array, 4 * n2, false, addressof_glMultiTexCoord4fv);
    }
    
    @Override
    public void glMultiTexCoord4i(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glMultiTexCoord4i = this._pat._addressof_glMultiTexCoord4i;
        if (addressof_glMultiTexCoord4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4i"));
        }
        this.dispatch_glMultiTexCoord4i1(n, n2, n3, n4, n5, addressof_glMultiTexCoord4i);
    }
    
    private native void dispatch_glMultiTexCoord4i1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glMultiTexCoord4iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoord4iv = this._pat._addressof_glMultiTexCoord4iv;
        if (addressof_glMultiTexCoord4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4iv"));
        }
        this.dispatch_glMultiTexCoord4iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoord4iv);
    }
    
    private native void dispatch_glMultiTexCoord4iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord4iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord4iv = this._pat._addressof_glMultiTexCoord4iv;
        if (addressof_glMultiTexCoord4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4iv"));
        }
        this.dispatch_glMultiTexCoord4iv1(n, array, 4 * n2, false, addressof_glMultiTexCoord4iv);
    }
    
    @Override
    public void glMultiTexCoord4s(final int n, final short n2, final short n3, final short n4, final short n5) {
        final long addressof_glMultiTexCoord4s = this._pat._addressof_glMultiTexCoord4s;
        if (addressof_glMultiTexCoord4s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4s"));
        }
        this.dispatch_glMultiTexCoord4s1(n, n2, n3, n4, n5, addressof_glMultiTexCoord4s);
    }
    
    private native void dispatch_glMultiTexCoord4s1(final int p0, final short p1, final short p2, final short p3, final short p4, final long p5);
    
    @Override
    public void glMultiTexCoord4sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord4sv = this._pat._addressof_glMultiTexCoord4sv;
        if (addressof_glMultiTexCoord4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4sv"));
        }
        this.dispatch_glMultiTexCoord4sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord4sv);
    }
    
    private native void dispatch_glMultiTexCoord4sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord4sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord4sv = this._pat._addressof_glMultiTexCoord4sv;
        if (addressof_glMultiTexCoord4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4sv"));
        }
        this.dispatch_glMultiTexCoord4sv1(n, array, 2 * n2, false, addressof_glMultiTexCoord4sv);
    }
    
    @Override
    public void glLoadTransposeMatrixf(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glLoadTransposeMatrixf = this._pat._addressof_glLoadTransposeMatrixf;
        if (addressof_glLoadTransposeMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixf"));
        }
        this.dispatch_glLoadTransposeMatrixf1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glLoadTransposeMatrixf);
    }
    
    private native void dispatch_glLoadTransposeMatrixf1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glLoadTransposeMatrixf(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLoadTransposeMatrixf = this._pat._addressof_glLoadTransposeMatrixf;
        if (addressof_glLoadTransposeMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixf"));
        }
        this.dispatch_glLoadTransposeMatrixf1(array, 4 * n, false, addressof_glLoadTransposeMatrixf);
    }
    
    @Override
    public void glLoadTransposeMatrixd(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glLoadTransposeMatrixd = this._pat._addressof_glLoadTransposeMatrixd;
        if (addressof_glLoadTransposeMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixd"));
        }
        this.dispatch_glLoadTransposeMatrixd1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glLoadTransposeMatrixd);
    }
    
    private native void dispatch_glLoadTransposeMatrixd1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glLoadTransposeMatrixd(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glLoadTransposeMatrixd = this._pat._addressof_glLoadTransposeMatrixd;
        if (addressof_glLoadTransposeMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixd"));
        }
        this.dispatch_glLoadTransposeMatrixd1(array, 8 * n, false, addressof_glLoadTransposeMatrixd);
    }
    
    @Override
    public void glMultTransposeMatrixf(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultTransposeMatrixf = this._pat._addressof_glMultTransposeMatrixf;
        if (addressof_glMultTransposeMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixf"));
        }
        this.dispatch_glMultTransposeMatrixf1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultTransposeMatrixf);
    }
    
    private native void dispatch_glMultTransposeMatrixf1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glMultTransposeMatrixf(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultTransposeMatrixf = this._pat._addressof_glMultTransposeMatrixf;
        if (addressof_glMultTransposeMatrixf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixf"));
        }
        this.dispatch_glMultTransposeMatrixf1(array, 4 * n, false, addressof_glMultTransposeMatrixf);
    }
    
    @Override
    public void glMultTransposeMatrixd(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMultTransposeMatrixd = this._pat._addressof_glMultTransposeMatrixd;
        if (addressof_glMultTransposeMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixd"));
        }
        this.dispatch_glMultTransposeMatrixd1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMultTransposeMatrixd);
    }
    
    private native void dispatch_glMultTransposeMatrixd1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glMultTransposeMatrixd(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"m_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultTransposeMatrixd = this._pat._addressof_glMultTransposeMatrixd;
        if (addressof_glMultTransposeMatrixd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixd"));
        }
        this.dispatch_glMultTransposeMatrixd1(array, 8 * n, false, addressof_glMultTransposeMatrixd);
    }
    
    @Override
    public void glBlendFuncSeparate(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glBlendFuncSeparate = this._pat._addressof_glBlendFuncSeparate;
        if (addressof_glBlendFuncSeparate == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparate"));
        }
        this.dispatch_glBlendFuncSeparate1(n, n2, n3, n4, addressof_glBlendFuncSeparate);
    }
    
    private native void dispatch_glBlendFuncSeparate1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glMultiDrawArrays(final int n, final IntBuffer intBuffer, final IntBuffer intBuffer2, final int n2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glMultiDrawArrays = this._pat._addressof_glMultiDrawArrays;
        if (addressof_glMultiDrawArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArrays"));
        }
        this.dispatch_glMultiDrawArrays1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, n2, addressof_glMultiDrawArrays);
    }
    
    private native void dispatch_glMultiDrawArrays1(final int p0, final Object p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final int p7, final long p8);
    
    @Override
    public void glMultiDrawArrays(final int n, final int[] array, final int n2, final int[] array2, final int n3, final int n4) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"first_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"count_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glMultiDrawArrays = this._pat._addressof_glMultiDrawArrays;
        if (addressof_glMultiDrawArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArrays"));
        }
        this.dispatch_glMultiDrawArrays1(n, array, 4 * n2, false, array2, 4 * n3, false, n4, addressof_glMultiDrawArrays);
    }
    
    @Override
    public void glMultiDrawElements(final int n, final IntBuffer intBuffer, final int n2, final PointerBuffer pointerBuffer, final int n3) {
        if (!Buffers.isDirect(intBuffer)) {
            throw new GLException("Argument \"count\" is not a direct buffer");
        }
        if (!Buffers.isDirect(pointerBuffer)) {
            throw new GLException("Argument \"indices\" is not a direct buffer");
        }
        final long addressof_glMultiDrawElements = this._pat._addressof_glMultiDrawElements;
        if (addressof_glMultiDrawElements == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElements"));
        }
        this.dispatch_glMultiDrawElements0(n, intBuffer, Buffers.getDirectBufferByteOffset(intBuffer), n2, (pointerBuffer != null) ? pointerBuffer.getBuffer() : null, Buffers.getDirectBufferByteOffset(pointerBuffer), n3, addressof_glMultiDrawElements);
    }
    
    private native void dispatch_glMultiDrawElements0(final int p0, final Object p1, final int p2, final int p3, final Object p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glPointParameterf(final int n, final float n2) {
        final long addressof_glPointParameterf = this._pat._addressof_glPointParameterf;
        if (addressof_glPointParameterf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPointParameterf"));
        }
        this.dispatch_glPointParameterf1(n, n2, addressof_glPointParameterf);
    }
    
    private native void dispatch_glPointParameterf1(final int p0, final float p1, final long p2);
    
    @Override
    public void glPointParameterfv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glPointParameterfv = this._pat._addressof_glPointParameterfv;
        if (addressof_glPointParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPointParameterfv"));
        }
        this.dispatch_glPointParameterfv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glPointParameterfv);
    }
    
    private native void dispatch_glPointParameterfv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glPointParameterfv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPointParameterfv = this._pat._addressof_glPointParameterfv;
        if (addressof_glPointParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPointParameterfv"));
        }
        this.dispatch_glPointParameterfv1(n, array, 4 * n2, false, addressof_glPointParameterfv);
    }
    
    @Override
    public void glPointParameteri(final int n, final int n2) {
        final long addressof_glPointParameteri = this._pat._addressof_glPointParameteri;
        if (addressof_glPointParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPointParameteri"));
        }
        this.dispatch_glPointParameteri1(n, n2, addressof_glPointParameteri);
    }
    
    private native void dispatch_glPointParameteri1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPointParameteriv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glPointParameteriv = this._pat._addressof_glPointParameteriv;
        if (addressof_glPointParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPointParameteriv"));
        }
        this.dispatch_glPointParameteriv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glPointParameteriv);
    }
    
    private native void dispatch_glPointParameteriv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glPointParameteriv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPointParameteriv = this._pat._addressof_glPointParameteriv;
        if (addressof_glPointParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPointParameteriv"));
        }
        this.dispatch_glPointParameteriv1(n, array, 4 * n2, false, addressof_glPointParameteriv);
    }
    
    @Override
    public void glFogCoordf(final float n) {
        final long addressof_glFogCoordf = this._pat._addressof_glFogCoordf;
        if (addressof_glFogCoordf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordf"));
        }
        this.dispatch_glFogCoordf1(n, addressof_glFogCoordf);
    }
    
    private native void dispatch_glFogCoordf1(final float p0, final long p1);
    
    @Override
    public void glFogCoordfv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glFogCoordfv = this._pat._addressof_glFogCoordfv;
        if (addressof_glFogCoordfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordfv"));
        }
        this.dispatch_glFogCoordfv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glFogCoordfv);
    }
    
    private native void dispatch_glFogCoordfv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glFogCoordfv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coord_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFogCoordfv = this._pat._addressof_glFogCoordfv;
        if (addressof_glFogCoordfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordfv"));
        }
        this.dispatch_glFogCoordfv1(array, 4 * n, false, addressof_glFogCoordfv);
    }
    
    @Override
    public void glFogCoordd(final double n) {
        final long addressof_glFogCoordd = this._pat._addressof_glFogCoordd;
        if (addressof_glFogCoordd == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordd"));
        }
        this.dispatch_glFogCoordd1(n, addressof_glFogCoordd);
    }
    
    private native void dispatch_glFogCoordd1(final double p0, final long p1);
    
    @Override
    public void glFogCoorddv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glFogCoorddv = this._pat._addressof_glFogCoorddv;
        if (addressof_glFogCoorddv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoorddv"));
        }
        this.dispatch_glFogCoorddv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glFogCoorddv);
    }
    
    private native void dispatch_glFogCoorddv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glFogCoorddv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coord_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFogCoorddv = this._pat._addressof_glFogCoorddv;
        if (addressof_glFogCoorddv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoorddv"));
        }
        this.dispatch_glFogCoorddv1(array, 8 * n, false, addressof_glFogCoorddv);
    }
    
    @Override
    public void glFogCoordPointer(final int n, final int n2, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glFogCoordPointer = this._pat._addressof_glFogCoordPointer;
        if (addressof_glFogCoordPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordPointer"));
        }
        this.dispatch_glFogCoordPointer0(n, n2, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glFogCoordPointer);
    }
    
    private native void dispatch_glFogCoordPointer0(final int p0, final int p1, final Object p2, final int p3, final long p4);
    
    @Override
    public void glFogCoordPointer(final int n, final int n2, final long n3) {
        this.checkArrayVBOBound(true);
        final long addressof_glFogCoordPointer = this._pat._addressof_glFogCoordPointer;
        if (addressof_glFogCoordPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordPointer"));
        }
        this.dispatch_glFogCoordPointer0(n, n2, n3, addressof_glFogCoordPointer);
    }
    
    private native void dispatch_glFogCoordPointer0(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glSecondaryColor3b(final byte b, final byte b2, final byte b3) {
        final long addressof_glSecondaryColor3b = this._pat._addressof_glSecondaryColor3b;
        if (addressof_glSecondaryColor3b == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3b"));
        }
        this.dispatch_glSecondaryColor3b1(b, b2, b3, addressof_glSecondaryColor3b);
    }
    
    private native void dispatch_glSecondaryColor3b1(final byte p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glSecondaryColor3bv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glSecondaryColor3bv = this._pat._addressof_glSecondaryColor3bv;
        if (addressof_glSecondaryColor3bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3bv"));
        }
        this.dispatch_glSecondaryColor3bv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glSecondaryColor3bv);
    }
    
    private native void dispatch_glSecondaryColor3bv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3bv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3bv = this._pat._addressof_glSecondaryColor3bv;
        if (addressof_glSecondaryColor3bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3bv"));
        }
        this.dispatch_glSecondaryColor3bv1(array, n, false, addressof_glSecondaryColor3bv);
    }
    
    @Override
    public void glSecondaryColor3d(final double n, final double n2, final double n3) {
        final long addressof_glSecondaryColor3d = this._pat._addressof_glSecondaryColor3d;
        if (addressof_glSecondaryColor3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3d"));
        }
        this.dispatch_glSecondaryColor3d1(n, n2, n3, addressof_glSecondaryColor3d);
    }
    
    private native void dispatch_glSecondaryColor3d1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glSecondaryColor3dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glSecondaryColor3dv = this._pat._addressof_glSecondaryColor3dv;
        if (addressof_glSecondaryColor3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3dv"));
        }
        this.dispatch_glSecondaryColor3dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glSecondaryColor3dv);
    }
    
    private native void dispatch_glSecondaryColor3dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3dv = this._pat._addressof_glSecondaryColor3dv;
        if (addressof_glSecondaryColor3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3dv"));
        }
        this.dispatch_glSecondaryColor3dv1(array, 8 * n, false, addressof_glSecondaryColor3dv);
    }
    
    @Override
    public void glSecondaryColor3f(final float n, final float n2, final float n3) {
        final long addressof_glSecondaryColor3f = this._pat._addressof_glSecondaryColor3f;
        if (addressof_glSecondaryColor3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3f"));
        }
        this.dispatch_glSecondaryColor3f1(n, n2, n3, addressof_glSecondaryColor3f);
    }
    
    private native void dispatch_glSecondaryColor3f1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glSecondaryColor3fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glSecondaryColor3fv = this._pat._addressof_glSecondaryColor3fv;
        if (addressof_glSecondaryColor3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3fv"));
        }
        this.dispatch_glSecondaryColor3fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glSecondaryColor3fv);
    }
    
    private native void dispatch_glSecondaryColor3fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3fv = this._pat._addressof_glSecondaryColor3fv;
        if (addressof_glSecondaryColor3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3fv"));
        }
        this.dispatch_glSecondaryColor3fv1(array, 4 * n, false, addressof_glSecondaryColor3fv);
    }
    
    @Override
    public void glSecondaryColor3i(final int n, final int n2, final int n3) {
        final long addressof_glSecondaryColor3i = this._pat._addressof_glSecondaryColor3i;
        if (addressof_glSecondaryColor3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3i"));
        }
        this.dispatch_glSecondaryColor3i1(n, n2, n3, addressof_glSecondaryColor3i);
    }
    
    private native void dispatch_glSecondaryColor3i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glSecondaryColor3iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glSecondaryColor3iv = this._pat._addressof_glSecondaryColor3iv;
        if (addressof_glSecondaryColor3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3iv"));
        }
        this.dispatch_glSecondaryColor3iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glSecondaryColor3iv);
    }
    
    private native void dispatch_glSecondaryColor3iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3iv = this._pat._addressof_glSecondaryColor3iv;
        if (addressof_glSecondaryColor3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3iv"));
        }
        this.dispatch_glSecondaryColor3iv1(array, 4 * n, false, addressof_glSecondaryColor3iv);
    }
    
    @Override
    public void glSecondaryColor3s(final short n, final short n2, final short n3) {
        final long addressof_glSecondaryColor3s = this._pat._addressof_glSecondaryColor3s;
        if (addressof_glSecondaryColor3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3s"));
        }
        this.dispatch_glSecondaryColor3s1(n, n2, n3, addressof_glSecondaryColor3s);
    }
    
    private native void dispatch_glSecondaryColor3s1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glSecondaryColor3sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glSecondaryColor3sv = this._pat._addressof_glSecondaryColor3sv;
        if (addressof_glSecondaryColor3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3sv"));
        }
        this.dispatch_glSecondaryColor3sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glSecondaryColor3sv);
    }
    
    private native void dispatch_glSecondaryColor3sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3sv = this._pat._addressof_glSecondaryColor3sv;
        if (addressof_glSecondaryColor3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3sv"));
        }
        this.dispatch_glSecondaryColor3sv1(array, 2 * n, false, addressof_glSecondaryColor3sv);
    }
    
    @Override
    public void glSecondaryColor3ub(final byte b, final byte b2, final byte b3) {
        final long addressof_glSecondaryColor3ub = this._pat._addressof_glSecondaryColor3ub;
        if (addressof_glSecondaryColor3ub == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ub"));
        }
        this.dispatch_glSecondaryColor3ub1(b, b2, b3, addressof_glSecondaryColor3ub);
    }
    
    private native void dispatch_glSecondaryColor3ub1(final byte p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glSecondaryColor3ubv(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glSecondaryColor3ubv = this._pat._addressof_glSecondaryColor3ubv;
        if (addressof_glSecondaryColor3ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ubv"));
        }
        this.dispatch_glSecondaryColor3ubv1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glSecondaryColor3ubv);
    }
    
    private native void dispatch_glSecondaryColor3ubv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3ubv(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3ubv = this._pat._addressof_glSecondaryColor3ubv;
        if (addressof_glSecondaryColor3ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ubv"));
        }
        this.dispatch_glSecondaryColor3ubv1(array, n, false, addressof_glSecondaryColor3ubv);
    }
    
    @Override
    public void glSecondaryColor3ui(final int n, final int n2, final int n3) {
        final long addressof_glSecondaryColor3ui = this._pat._addressof_glSecondaryColor3ui;
        if (addressof_glSecondaryColor3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ui"));
        }
        this.dispatch_glSecondaryColor3ui1(n, n2, n3, addressof_glSecondaryColor3ui);
    }
    
    private native void dispatch_glSecondaryColor3ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glSecondaryColor3uiv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glSecondaryColor3uiv = this._pat._addressof_glSecondaryColor3uiv;
        if (addressof_glSecondaryColor3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3uiv"));
        }
        this.dispatch_glSecondaryColor3uiv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glSecondaryColor3uiv);
    }
    
    private native void dispatch_glSecondaryColor3uiv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3uiv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3uiv = this._pat._addressof_glSecondaryColor3uiv;
        if (addressof_glSecondaryColor3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3uiv"));
        }
        this.dispatch_glSecondaryColor3uiv1(array, 4 * n, false, addressof_glSecondaryColor3uiv);
    }
    
    @Override
    public void glSecondaryColor3us(final short n, final short n2, final short n3) {
        final long addressof_glSecondaryColor3us = this._pat._addressof_glSecondaryColor3us;
        if (addressof_glSecondaryColor3us == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3us"));
        }
        this.dispatch_glSecondaryColor3us1(n, n2, n3, addressof_glSecondaryColor3us);
    }
    
    private native void dispatch_glSecondaryColor3us1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glSecondaryColor3usv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glSecondaryColor3usv = this._pat._addressof_glSecondaryColor3usv;
        if (addressof_glSecondaryColor3usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3usv"));
        }
        this.dispatch_glSecondaryColor3usv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glSecondaryColor3usv);
    }
    
    private native void dispatch_glSecondaryColor3usv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3usv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3usv = this._pat._addressof_glSecondaryColor3usv;
        if (addressof_glSecondaryColor3usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3usv"));
        }
        this.dispatch_glSecondaryColor3usv1(array, 2 * n, false, addressof_glSecondaryColor3usv);
    }
    
    @Override
    public void glSecondaryColorPointer(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glSecondaryColorPointer = this._pat._addressof_glSecondaryColorPointer;
        if (addressof_glSecondaryColorPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorPointer"));
        }
        this.dispatch_glSecondaryColorPointer0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glSecondaryColorPointer);
    }
    
    private native void dispatch_glSecondaryColorPointer0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glSecondaryColorPointer(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glSecondaryColorPointer = this._pat._addressof_glSecondaryColorPointer;
        if (addressof_glSecondaryColorPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorPointer"));
        }
        this.dispatch_glSecondaryColorPointer0(n, n2, n3, n4, addressof_glSecondaryColorPointer);
    }
    
    private native void dispatch_glSecondaryColorPointer0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glWindowPos2d(final double n, final double n2) {
        final long addressof_glWindowPos2d = this._pat._addressof_glWindowPos2d;
        if (addressof_glWindowPos2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2d"));
        }
        this.dispatch_glWindowPos2d1(n, n2, addressof_glWindowPos2d);
    }
    
    private native void dispatch_glWindowPos2d1(final double p0, final double p1, final long p2);
    
    @Override
    public void glWindowPos2dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glWindowPos2dv = this._pat._addressof_glWindowPos2dv;
        if (addressof_glWindowPos2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2dv"));
        }
        this.dispatch_glWindowPos2dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glWindowPos2dv);
    }
    
    private native void dispatch_glWindowPos2dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos2dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos2dv = this._pat._addressof_glWindowPos2dv;
        if (addressof_glWindowPos2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2dv"));
        }
        this.dispatch_glWindowPos2dv1(array, 8 * n, false, addressof_glWindowPos2dv);
    }
    
    @Override
    public void glWindowPos2f(final float n, final float n2) {
        final long addressof_glWindowPos2f = this._pat._addressof_glWindowPos2f;
        if (addressof_glWindowPos2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2f"));
        }
        this.dispatch_glWindowPos2f1(n, n2, addressof_glWindowPos2f);
    }
    
    private native void dispatch_glWindowPos2f1(final float p0, final float p1, final long p2);
    
    @Override
    public void glWindowPos2fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glWindowPos2fv = this._pat._addressof_glWindowPos2fv;
        if (addressof_glWindowPos2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2fv"));
        }
        this.dispatch_glWindowPos2fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glWindowPos2fv);
    }
    
    private native void dispatch_glWindowPos2fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos2fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos2fv = this._pat._addressof_glWindowPos2fv;
        if (addressof_glWindowPos2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2fv"));
        }
        this.dispatch_glWindowPos2fv1(array, 4 * n, false, addressof_glWindowPos2fv);
    }
    
    @Override
    public void glWindowPos2i(final int n, final int n2) {
        final long addressof_glWindowPos2i = this._pat._addressof_glWindowPos2i;
        if (addressof_glWindowPos2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2i"));
        }
        this.dispatch_glWindowPos2i1(n, n2, addressof_glWindowPos2i);
    }
    
    private native void dispatch_glWindowPos2i1(final int p0, final int p1, final long p2);
    
    @Override
    public void glWindowPos2iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glWindowPos2iv = this._pat._addressof_glWindowPos2iv;
        if (addressof_glWindowPos2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2iv"));
        }
        this.dispatch_glWindowPos2iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glWindowPos2iv);
    }
    
    private native void dispatch_glWindowPos2iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos2iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos2iv = this._pat._addressof_glWindowPos2iv;
        if (addressof_glWindowPos2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2iv"));
        }
        this.dispatch_glWindowPos2iv1(array, 4 * n, false, addressof_glWindowPos2iv);
    }
    
    @Override
    public void glWindowPos2s(final short n, final short n2) {
        final long addressof_glWindowPos2s = this._pat._addressof_glWindowPos2s;
        if (addressof_glWindowPos2s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2s"));
        }
        this.dispatch_glWindowPos2s1(n, n2, addressof_glWindowPos2s);
    }
    
    private native void dispatch_glWindowPos2s1(final short p0, final short p1, final long p2);
    
    @Override
    public void glWindowPos2sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glWindowPos2sv = this._pat._addressof_glWindowPos2sv;
        if (addressof_glWindowPos2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2sv"));
        }
        this.dispatch_glWindowPos2sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glWindowPos2sv);
    }
    
    private native void dispatch_glWindowPos2sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos2sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos2sv = this._pat._addressof_glWindowPos2sv;
        if (addressof_glWindowPos2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2sv"));
        }
        this.dispatch_glWindowPos2sv1(array, 2 * n, false, addressof_glWindowPos2sv);
    }
    
    @Override
    public void glWindowPos3d(final double n, final double n2, final double n3) {
        final long addressof_glWindowPos3d = this._pat._addressof_glWindowPos3d;
        if (addressof_glWindowPos3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3d"));
        }
        this.dispatch_glWindowPos3d1(n, n2, n3, addressof_glWindowPos3d);
    }
    
    private native void dispatch_glWindowPos3d1(final double p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glWindowPos3dv(final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glWindowPos3dv = this._pat._addressof_glWindowPos3dv;
        if (addressof_glWindowPos3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3dv"));
        }
        this.dispatch_glWindowPos3dv1(direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glWindowPos3dv);
    }
    
    private native void dispatch_glWindowPos3dv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos3dv(final double[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos3dv = this._pat._addressof_glWindowPos3dv;
        if (addressof_glWindowPos3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3dv"));
        }
        this.dispatch_glWindowPos3dv1(array, 8 * n, false, addressof_glWindowPos3dv);
    }
    
    @Override
    public void glWindowPos3f(final float n, final float n2, final float n3) {
        final long addressof_glWindowPos3f = this._pat._addressof_glWindowPos3f;
        if (addressof_glWindowPos3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3f"));
        }
        this.dispatch_glWindowPos3f1(n, n2, n3, addressof_glWindowPos3f);
    }
    
    private native void dispatch_glWindowPos3f1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glWindowPos3fv(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glWindowPos3fv = this._pat._addressof_glWindowPos3fv;
        if (addressof_glWindowPos3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3fv"));
        }
        this.dispatch_glWindowPos3fv1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glWindowPos3fv);
    }
    
    private native void dispatch_glWindowPos3fv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos3fv(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos3fv = this._pat._addressof_glWindowPos3fv;
        if (addressof_glWindowPos3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3fv"));
        }
        this.dispatch_glWindowPos3fv1(array, 4 * n, false, addressof_glWindowPos3fv);
    }
    
    @Override
    public void glWindowPos3i(final int n, final int n2, final int n3) {
        final long addressof_glWindowPos3i = this._pat._addressof_glWindowPos3i;
        if (addressof_glWindowPos3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3i"));
        }
        this.dispatch_glWindowPos3i1(n, n2, n3, addressof_glWindowPos3i);
    }
    
    private native void dispatch_glWindowPos3i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glWindowPos3iv(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glWindowPos3iv = this._pat._addressof_glWindowPos3iv;
        if (addressof_glWindowPos3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3iv"));
        }
        this.dispatch_glWindowPos3iv1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glWindowPos3iv);
    }
    
    private native void dispatch_glWindowPos3iv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos3iv(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos3iv = this._pat._addressof_glWindowPos3iv;
        if (addressof_glWindowPos3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3iv"));
        }
        this.dispatch_glWindowPos3iv1(array, 4 * n, false, addressof_glWindowPos3iv);
    }
    
    @Override
    public void glWindowPos3s(final short n, final short n2, final short n3) {
        final long addressof_glWindowPos3s = this._pat._addressof_glWindowPos3s;
        if (addressof_glWindowPos3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3s"));
        }
        this.dispatch_glWindowPos3s1(n, n2, n3, addressof_glWindowPos3s);
    }
    
    private native void dispatch_glWindowPos3s1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glWindowPos3sv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glWindowPos3sv = this._pat._addressof_glWindowPos3sv;
        if (addressof_glWindowPos3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3sv"));
        }
        this.dispatch_glWindowPos3sv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glWindowPos3sv);
    }
    
    private native void dispatch_glWindowPos3sv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glWindowPos3sv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWindowPos3sv = this._pat._addressof_glWindowPos3sv;
        if (addressof_glWindowPos3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3sv"));
        }
        this.dispatch_glWindowPos3sv1(array, 2 * n, false, addressof_glWindowPos3sv);
    }
    
    @Override
    public void glBlendColor(final float n, final float n2, final float n3, final float n4) {
        final long addressof_glBlendColor = this._pat._addressof_glBlendColor;
        if (addressof_glBlendColor == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendColor"));
        }
        this.dispatch_glBlendColor1(n, n2, n3, n4, addressof_glBlendColor);
    }
    
    private native void dispatch_glBlendColor1(final float p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glBlendEquation(final int n) {
        final long addressof_glBlendEquation = this._pat._addressof_glBlendEquation;
        if (addressof_glBlendEquation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendEquation"));
        }
        this.dispatch_glBlendEquation1(n, addressof_glBlendEquation);
    }
    
    private native void dispatch_glBlendEquation1(final int p0, final long p1);
    
    @Override
    public void glGenQueries(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenQueries = this._pat._addressof_glGenQueries;
        if (addressof_glGenQueries == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
        }
        this.dispatch_glGenQueries1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenQueries);
    }
    
    private native void dispatch_glGenQueries1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenQueries(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenQueries = this._pat._addressof_glGenQueries;
        if (addressof_glGenQueries == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
        }
        this.dispatch_glGenQueries1(n, array, 4 * n2, false, addressof_glGenQueries);
    }
    
    @Override
    public void glDeleteQueries(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteQueries = this._pat._addressof_glDeleteQueries;
        if (addressof_glDeleteQueries == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
        }
        this.dispatch_glDeleteQueries1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteQueries);
    }
    
    private native void dispatch_glDeleteQueries1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteQueries(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteQueries = this._pat._addressof_glDeleteQueries;
        if (addressof_glDeleteQueries == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
        }
        this.dispatch_glDeleteQueries1(n, array, 4 * n2, false, addressof_glDeleteQueries);
    }
    
    @Override
    public boolean glIsQuery(final int n) {
        final long addressof_glIsQuery = this._pat._addressof_glIsQuery;
        if (addressof_glIsQuery == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsQuery"));
        }
        return this.dispatch_glIsQuery1(n, addressof_glIsQuery);
    }
    
    private native boolean dispatch_glIsQuery1(final int p0, final long p1);
    
    @Override
    public void glBeginQuery(final int n, final int n2) {
        final long addressof_glBeginQuery = this._pat._addressof_glBeginQuery;
        if (addressof_glBeginQuery == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginQuery"));
        }
        this.dispatch_glBeginQuery1(n, n2, addressof_glBeginQuery);
    }
    
    private native void dispatch_glBeginQuery1(final int p0, final int p1, final long p2);
    
    @Override
    public void glEndQuery(final int n) {
        final long addressof_glEndQuery = this._pat._addressof_glEndQuery;
        if (addressof_glEndQuery == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndQuery"));
        }
        this.dispatch_glEndQuery1(n, addressof_glEndQuery);
    }
    
    private native void dispatch_glEndQuery1(final int p0, final long p1);
    
    @Override
    public void glGetQueryiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetQueryiv = this._pat._addressof_glGetQueryiv;
        if (addressof_glGetQueryiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
        }
        this.dispatch_glGetQueryiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetQueryiv);
    }
    
    private native void dispatch_glGetQueryiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetQueryiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryiv = this._pat._addressof_glGetQueryiv;
        if (addressof_glGetQueryiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
        }
        this.dispatch_glGetQueryiv1(n, n2, array, 4 * n3, false, addressof_glGetQueryiv);
    }
    
    @Override
    public void glGetQueryObjectiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetQueryObjectiv = this._pat._addressof_glGetQueryObjectiv;
        if (addressof_glGetQueryObjectiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectiv"));
        }
        this.dispatch_glGetQueryObjectiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetQueryObjectiv);
    }
    
    private native void dispatch_glGetQueryObjectiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetQueryObjectiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryObjectiv = this._pat._addressof_glGetQueryObjectiv;
        if (addressof_glGetQueryObjectiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectiv"));
        }
        this.dispatch_glGetQueryObjectiv1(n, n2, array, 4 * n3, false, addressof_glGetQueryObjectiv);
    }
    
    @Override
    public void glGetQueryObjectuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetQueryObjectuiv = this._pat._addressof_glGetQueryObjectuiv;
        if (addressof_glGetQueryObjectuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
        }
        this.dispatch_glGetQueryObjectuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetQueryObjectuiv);
    }
    
    private native void dispatch_glGetQueryObjectuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetQueryObjectuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryObjectuiv = this._pat._addressof_glGetQueryObjectuiv;
        if (addressof_glGetQueryObjectuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
        }
        this.dispatch_glGetQueryObjectuiv1(n, n2, array, 4 * n3, false, addressof_glGetQueryObjectuiv);
    }
    
    @Override
    public void glBindBuffer(final int n, final int n2) {
        final long addressof_glBindBuffer = this._pat._addressof_glBindBuffer;
        if (addressof_glBindBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindBuffer"));
        }
        this.dispatch_glBindBuffer1(n, n2, addressof_glBindBuffer);
        this.bufferStateTracker.setBoundBufferObject(n, n2);
    }
    
    private native void dispatch_glBindBuffer1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDeleteBuffers(final int n, final IntBuffer intBuffer) {
        this.bufferObjectTracker.notifyBuffersDeleted(n, intBuffer);
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteBuffers = this._pat._addressof_glDeleteBuffers;
        if (addressof_glDeleteBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
        }
        this.dispatch_glDeleteBuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteBuffers);
    }
    
    private native void dispatch_glDeleteBuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteBuffers(final int n, final int[] array, final int n2) {
        this.bufferObjectTracker.notifyBuffersDeleted(n, array, n2);
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"buffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteBuffers = this._pat._addressof_glDeleteBuffers;
        if (addressof_glDeleteBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
        }
        this.dispatch_glDeleteBuffers1(n, array, 4 * n2, false, addressof_glDeleteBuffers);
    }
    
    @Override
    public void glGenBuffers(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenBuffers = this._pat._addressof_glGenBuffers;
        if (addressof_glGenBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
        }
        this.dispatch_glGenBuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenBuffers);
    }
    
    private native void dispatch_glGenBuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenBuffers(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"buffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenBuffers = this._pat._addressof_glGenBuffers;
        if (addressof_glGenBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
        }
        this.dispatch_glGenBuffers1(n, array, 4 * n2, false, addressof_glGenBuffers);
    }
    
    @Override
    public boolean glIsBuffer(final int n) {
        final long addressof_glIsBuffer = this._pat._addressof_glIsBuffer;
        if (addressof_glIsBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsBuffer"));
        }
        return this.dispatch_glIsBuffer1(n, addressof_glIsBuffer);
    }
    
    private native boolean dispatch_glIsBuffer1(final int p0, final long p1);
    
    private void glBufferDataDelegate(final int n, final long n2, final Buffer buffer, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glBufferData = this._pat._addressof_glBufferData;
        if (addressof_glBufferData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBufferData"));
        }
        this.dispatch_glBufferDataDelegate1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, addressof_glBufferData);
    }
    
    private native void dispatch_glBufferDataDelegate1(final int p0, final long p1, final Object p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glBufferSubData(final int n, final long n2, final long n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glBufferSubData = this._pat._addressof_glBufferSubData;
        if (addressof_glBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBufferSubData"));
        }
        this.dispatch_glBufferSubData1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glBufferSubData);
    }
    
    private native void dispatch_glBufferSubData1(final int p0, final long p1, final long p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetBufferSubData(final int n, final long n2, final long n3, final Buffer buffer) {
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"data\" is not a direct buffer");
        }
        final long addressof_glGetBufferSubData = this._pat._addressof_glGetBufferSubData;
        if (addressof_glGetBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBufferSubData"));
        }
        this.dispatch_glGetBufferSubData0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glGetBufferSubData);
    }
    
    private native void dispatch_glGetBufferSubData0(final int p0, final long p1, final long p2, final Object p3, final int p4, final long p5);
    
    private long glMapBufferDelegate(final int n, final int n2) {
        final long addressof_glMapBuffer = this._pat._addressof_glMapBuffer;
        if (addressof_glMapBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapBuffer"));
        }
        return this.dispatch_glMapBufferDelegate1(n, n2, addressof_glMapBuffer);
    }
    
    private native long dispatch_glMapBufferDelegate1(final int p0, final int p1, final long p2);
    
    private boolean glUnmapBufferDelegate(final int n) {
        final long addressof_glUnmapBuffer = this._pat._addressof_glUnmapBuffer;
        if (addressof_glUnmapBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUnmapBuffer"));
        }
        return this.dispatch_glUnmapBufferDelegate1(n, addressof_glUnmapBuffer);
    }
    
    private native boolean dispatch_glUnmapBufferDelegate1(final int p0, final long p1);
    
    @Override
    public void glGetBufferParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetBufferParameteriv = this._pat._addressof_glGetBufferParameteriv;
        if (addressof_glGetBufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
        }
        this.dispatch_glGetBufferParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetBufferParameteriv);
    }
    
    private native void dispatch_glGetBufferParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetBufferParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetBufferParameteriv = this._pat._addressof_glGetBufferParameteriv;
        if (addressof_glGetBufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
        }
        this.dispatch_glGetBufferParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetBufferParameteriv);
    }
    
    @Override
    public void glBlendEquationSeparate(final int n, final int n2) {
        final long addressof_glBlendEquationSeparate = this._pat._addressof_glBlendEquationSeparate;
        if (addressof_glBlendEquationSeparate == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparate"));
        }
        this.dispatch_glBlendEquationSeparate1(n, n2, addressof_glBlendEquationSeparate);
    }
    
    private native void dispatch_glBlendEquationSeparate1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDrawBuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDrawBuffers = this._pat._addressof_glDrawBuffers;
        if (addressof_glDrawBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
        }
        this.dispatch_glDrawBuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDrawBuffers);
    }
    
    private native void dispatch_glDrawBuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDrawBuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"bufs_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDrawBuffers = this._pat._addressof_glDrawBuffers;
        if (addressof_glDrawBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
        }
        this.dispatch_glDrawBuffers1(n, array, 4 * n2, false, addressof_glDrawBuffers);
    }
    
    @Override
    public void glStencilOpSeparate(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glStencilOpSeparate = this._pat._addressof_glStencilOpSeparate;
        if (addressof_glStencilOpSeparate == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilOpSeparate"));
        }
        this.dispatch_glStencilOpSeparate1(n, n2, n3, n4, addressof_glStencilOpSeparate);
    }
    
    private native void dispatch_glStencilOpSeparate1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glStencilFuncSeparate(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glStencilFuncSeparate = this._pat._addressof_glStencilFuncSeparate;
        if (addressof_glStencilFuncSeparate == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilFuncSeparate"));
        }
        this.dispatch_glStencilFuncSeparate1(n, n2, n3, n4, addressof_glStencilFuncSeparate);
    }
    
    private native void dispatch_glStencilFuncSeparate1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glStencilMaskSeparate(final int n, final int n2) {
        final long addressof_glStencilMaskSeparate = this._pat._addressof_glStencilMaskSeparate;
        if (addressof_glStencilMaskSeparate == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilMaskSeparate"));
        }
        this.dispatch_glStencilMaskSeparate1(n, n2, addressof_glStencilMaskSeparate);
    }
    
    private native void dispatch_glStencilMaskSeparate1(final int p0, final int p1, final long p2);
    
    @Override
    public void glAttachShader(final int n, final int n2) {
        final long addressof_glAttachShader = this._pat._addressof_glAttachShader;
        if (addressof_glAttachShader == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glAttachShader"));
        }
        this.dispatch_glAttachShader1(n, n2, addressof_glAttachShader);
    }
    
    private native void dispatch_glAttachShader1(final int p0, final int p1, final long p2);
    
    @Override
    public void glBindAttribLocation(final int n, final int n2, final String s) {
        final long addressof_glBindAttribLocation = this._pat._addressof_glBindAttribLocation;
        if (addressof_glBindAttribLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindAttribLocation"));
        }
        this.dispatch_glBindAttribLocation1(n, n2, s, addressof_glBindAttribLocation);
    }
    
    private native void dispatch_glBindAttribLocation1(final int p0, final int p1, final String p2, final long p3);
    
    @Override
    public void glCompileShader(final int n) {
        final long addressof_glCompileShader = this._pat._addressof_glCompileShader;
        if (addressof_glCompileShader == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompileShader"));
        }
        this.dispatch_glCompileShader1(n, addressof_glCompileShader);
    }
    
    private native void dispatch_glCompileShader1(final int p0, final long p1);
    
    @Override
    public int glCreateProgram() {
        final long addressof_glCreateProgram = this._pat._addressof_glCreateProgram;
        if (addressof_glCreateProgram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateProgram"));
        }
        return this.dispatch_glCreateProgram1(addressof_glCreateProgram);
    }
    
    private native int dispatch_glCreateProgram1(final long p0);
    
    @Override
    public int glCreateShader(final int n) {
        final long addressof_glCreateShader = this._pat._addressof_glCreateShader;
        if (addressof_glCreateShader == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateShader"));
        }
        return this.dispatch_glCreateShader1(n, addressof_glCreateShader);
    }
    
    private native int dispatch_glCreateShader1(final int p0, final long p1);
    
    @Override
    public void glDeleteProgram(final int n) {
        final long addressof_glDeleteProgram = this._pat._addressof_glDeleteProgram;
        if (addressof_glDeleteProgram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgram"));
        }
        this.dispatch_glDeleteProgram1(n, addressof_glDeleteProgram);
    }
    
    private native void dispatch_glDeleteProgram1(final int p0, final long p1);
    
    @Override
    public void glDeleteShader(final int n) {
        final long addressof_glDeleteShader = this._pat._addressof_glDeleteShader;
        if (addressof_glDeleteShader == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteShader"));
        }
        this.dispatch_glDeleteShader1(n, addressof_glDeleteShader);
    }
    
    private native void dispatch_glDeleteShader1(final int p0, final long p1);
    
    @Override
    public void glDetachShader(final int n, final int n2) {
        final long addressof_glDetachShader = this._pat._addressof_glDetachShader;
        if (addressof_glDetachShader == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDetachShader"));
        }
        this.dispatch_glDetachShader1(n, n2, addressof_glDetachShader);
    }
    
    private native void dispatch_glDetachShader1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisableVertexAttribArray(final int n) {
        final long addressof_glDisableVertexAttribArray = this._pat._addressof_glDisableVertexAttribArray;
        if (addressof_glDisableVertexAttribArray == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribArray"));
        }
        this.dispatch_glDisableVertexAttribArray1(n, addressof_glDisableVertexAttribArray);
    }
    
    private native void dispatch_glDisableVertexAttribArray1(final int p0, final long p1);
    
    @Override
    public void glEnableVertexAttribArray(final int n) {
        final long addressof_glEnableVertexAttribArray = this._pat._addressof_glEnableVertexAttribArray;
        if (addressof_glEnableVertexAttribArray == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribArray"));
        }
        this.dispatch_glEnableVertexAttribArray1(n, addressof_glEnableVertexAttribArray);
    }
    
    private native void dispatch_glEnableVertexAttribArray1(final int p0, final long p1);
    
    @Override
    public void glGetActiveAttrib(final int n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final boolean direct4 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetActiveAttrib = this._pat._addressof_glGetActiveAttrib;
        if (addressof_glGetActiveAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
        }
        this.dispatch_glGetActiveAttrib1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, direct4 ? byteBuffer : Buffers.getArray(byteBuffer), direct4 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct4, addressof_glGetActiveAttrib);
    }
    
    private native void dispatch_glGetActiveAttrib1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final Object p12, final int p13, final boolean p14, final long p15);
    
    @Override
    public void glGetActiveAttrib(final int n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5, final int[] array3, final int n6, final byte[] array4, final int n7) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"size_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n6) {
            throw new GLException("array offset argument \"type_offset\" (" + n6 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n7) {
            throw new GLException("array offset argument \"name_offset\" (" + n7 + ") equals or exceeds array length (" + array4.length + ")");
        }
        final long addressof_glGetActiveAttrib = this._pat._addressof_glGetActiveAttrib;
        if (addressof_glGetActiveAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
        }
        this.dispatch_glGetActiveAttrib1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, array3, 4 * n6, false, array4, n7, false, addressof_glGetActiveAttrib);
    }
    
    @Override
    public void glGetActiveUniform(final int n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final boolean direct4 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetActiveUniform = this._pat._addressof_glGetActiveUniform;
        if (addressof_glGetActiveUniform == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
        }
        this.dispatch_glGetActiveUniform1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, direct4 ? byteBuffer : Buffers.getArray(byteBuffer), direct4 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct4, addressof_glGetActiveUniform);
    }
    
    private native void dispatch_glGetActiveUniform1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final Object p12, final int p13, final boolean p14, final long p15);
    
    @Override
    public void glGetActiveUniform(final int n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5, final int[] array3, final int n6, final byte[] array4, final int n7) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"size_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n6) {
            throw new GLException("array offset argument \"type_offset\" (" + n6 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n7) {
            throw new GLException("array offset argument \"name_offset\" (" + n7 + ") equals or exceeds array length (" + array4.length + ")");
        }
        final long addressof_glGetActiveUniform = this._pat._addressof_glGetActiveUniform;
        if (addressof_glGetActiveUniform == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
        }
        this.dispatch_glGetActiveUniform1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, array3, 4 * n6, false, array4, n7, false, addressof_glGetActiveUniform);
    }
    
    @Override
    public void glGetAttachedShaders(final int n, final int n2, final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glGetAttachedShaders = this._pat._addressof_glGetAttachedShaders;
        if (addressof_glGetAttachedShaders == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
        }
        this.dispatch_glGetAttachedShaders1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glGetAttachedShaders);
    }
    
    private native void dispatch_glGetAttachedShaders1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetAttachedShaders(final int n, final int n2, final int[] array, final int n3, final int[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"count_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"shaders_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetAttachedShaders = this._pat._addressof_glGetAttachedShaders;
        if (addressof_glGetAttachedShaders == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
        }
        this.dispatch_glGetAttachedShaders1(n, n2, array, 4 * n3, false, array2, 4 * n4, false, addressof_glGetAttachedShaders);
    }
    
    @Override
    public int glGetAttribLocation(final int n, final String s) {
        final long addressof_glGetAttribLocation = this._pat._addressof_glGetAttribLocation;
        if (addressof_glGetAttribLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetAttribLocation"));
        }
        return this.dispatch_glGetAttribLocation1(n, s, addressof_glGetAttribLocation);
    }
    
    private native int dispatch_glGetAttribLocation1(final int p0, final String p1, final long p2);
    
    @Override
    public void glGetProgramiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramiv = this._pat._addressof_glGetProgramiv;
        if (addressof_glGetProgramiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
        }
        this.dispatch_glGetProgramiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramiv);
    }
    
    private native void dispatch_glGetProgramiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramiv = this._pat._addressof_glGetProgramiv;
        if (addressof_glGetProgramiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
        }
        this.dispatch_glGetProgramiv1(n, n2, array, 4 * n3, false, addressof_glGetProgramiv);
    }
    
    @Override
    public void glGetProgramInfoLog(final int n, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetProgramInfoLog = this._pat._addressof_glGetProgramInfoLog;
        if (addressof_glGetProgramInfoLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
        }
        this.dispatch_glGetProgramInfoLog1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetProgramInfoLog);
    }
    
    private native void dispatch_glGetProgramInfoLog1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetProgramInfoLog(final int n, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"infoLog_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetProgramInfoLog = this._pat._addressof_glGetProgramInfoLog;
        if (addressof_glGetProgramInfoLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
        }
        this.dispatch_glGetProgramInfoLog1(n, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetProgramInfoLog);
    }
    
    @Override
    public void glGetShaderiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetShaderiv = this._pat._addressof_glGetShaderiv;
        if (addressof_glGetShaderiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
        }
        this.dispatch_glGetShaderiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetShaderiv);
    }
    
    private native void dispatch_glGetShaderiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetShaderiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetShaderiv = this._pat._addressof_glGetShaderiv;
        if (addressof_glGetShaderiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
        }
        this.dispatch_glGetShaderiv1(n, n2, array, 4 * n3, false, addressof_glGetShaderiv);
    }
    
    @Override
    public void glGetShaderInfoLog(final int n, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetShaderInfoLog = this._pat._addressof_glGetShaderInfoLog;
        if (addressof_glGetShaderInfoLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
        }
        this.dispatch_glGetShaderInfoLog1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetShaderInfoLog);
    }
    
    private native void dispatch_glGetShaderInfoLog1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetShaderInfoLog(final int n, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"infoLog_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetShaderInfoLog = this._pat._addressof_glGetShaderInfoLog;
        if (addressof_glGetShaderInfoLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
        }
        this.dispatch_glGetShaderInfoLog1(n, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetShaderInfoLog);
    }
    
    @Override
    public void glGetShaderSource(final int n, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetShaderSource = this._pat._addressof_glGetShaderSource;
        if (addressof_glGetShaderSource == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
        }
        this.dispatch_glGetShaderSource1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetShaderSource);
    }
    
    private native void dispatch_glGetShaderSource1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetShaderSource(final int n, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"source_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetShaderSource = this._pat._addressof_glGetShaderSource;
        if (addressof_glGetShaderSource == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
        }
        this.dispatch_glGetShaderSource1(n, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetShaderSource);
    }
    
    @Override
    public int glGetUniformLocation(final int n, final String s) {
        final long addressof_glGetUniformLocation = this._pat._addressof_glGetUniformLocation;
        if (addressof_glGetUniformLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformLocation"));
        }
        return this.dispatch_glGetUniformLocation1(n, s, addressof_glGetUniformLocation);
    }
    
    private native int dispatch_glGetUniformLocation1(final int p0, final String p1, final long p2);
    
    @Override
    public void glGetUniformfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetUniformfv = this._pat._addressof_glGetUniformfv;
        if (addressof_glGetUniformfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
        }
        this.dispatch_glGetUniformfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetUniformfv);
    }
    
    private native void dispatch_glGetUniformfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformfv = this._pat._addressof_glGetUniformfv;
        if (addressof_glGetUniformfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
        }
        this.dispatch_glGetUniformfv1(n, n2, array, 4 * n3, false, addressof_glGetUniformfv);
    }
    
    @Override
    public void glGetUniformiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetUniformiv = this._pat._addressof_glGetUniformiv;
        if (addressof_glGetUniformiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
        }
        this.dispatch_glGetUniformiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetUniformiv);
    }
    
    private native void dispatch_glGetUniformiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformiv = this._pat._addressof_glGetUniformiv;
        if (addressof_glGetUniformiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
        }
        this.dispatch_glGetUniformiv1(n, n2, array, 4 * n3, false, addressof_glGetUniformiv);
    }
    
    @Override
    public void glGetVertexAttribdv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetVertexAttribdv = this._pat._addressof_glGetVertexAttribdv;
        if (addressof_glGetVertexAttribdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdv"));
        }
        this.dispatch_glGetVertexAttribdv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetVertexAttribdv);
    }
    
    private native void dispatch_glGetVertexAttribdv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribdv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribdv = this._pat._addressof_glGetVertexAttribdv;
        if (addressof_glGetVertexAttribdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdv"));
        }
        this.dispatch_glGetVertexAttribdv1(n, n2, array, 8 * n3, false, addressof_glGetVertexAttribdv);
    }
    
    @Override
    public void glGetVertexAttribfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetVertexAttribfv = this._pat._addressof_glGetVertexAttribfv;
        if (addressof_glGetVertexAttribfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
        }
        this.dispatch_glGetVertexAttribfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetVertexAttribfv);
    }
    
    private native void dispatch_glGetVertexAttribfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribfv = this._pat._addressof_glGetVertexAttribfv;
        if (addressof_glGetVertexAttribfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
        }
        this.dispatch_glGetVertexAttribfv1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribfv);
    }
    
    @Override
    public void glGetVertexAttribiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexAttribiv = this._pat._addressof_glGetVertexAttribiv;
        if (addressof_glGetVertexAttribiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
        }
        this.dispatch_glGetVertexAttribiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexAttribiv);
    }
    
    private native void dispatch_glGetVertexAttribiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribiv = this._pat._addressof_glGetVertexAttribiv;
        if (addressof_glGetVertexAttribiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
        }
        this.dispatch_glGetVertexAttribiv1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribiv);
    }
    
    @Override
    public boolean glIsProgram(final int n) {
        final long addressof_glIsProgram = this._pat._addressof_glIsProgram;
        if (addressof_glIsProgram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsProgram"));
        }
        return this.dispatch_glIsProgram1(n, addressof_glIsProgram);
    }
    
    private native boolean dispatch_glIsProgram1(final int p0, final long p1);
    
    @Override
    public boolean glIsShader(final int n) {
        final long addressof_glIsShader = this._pat._addressof_glIsShader;
        if (addressof_glIsShader == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsShader"));
        }
        return this.dispatch_glIsShader1(n, addressof_glIsShader);
    }
    
    private native boolean dispatch_glIsShader1(final int p0, final long p1);
    
    @Override
    public void glLinkProgram(final int n) {
        final long addressof_glLinkProgram = this._pat._addressof_glLinkProgram;
        if (addressof_glLinkProgram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLinkProgram"));
        }
        this.dispatch_glLinkProgram1(n, addressof_glLinkProgram);
    }
    
    private native void dispatch_glLinkProgram1(final int p0, final long p1);
    
    @Override
    public void glShaderSource(final int n, final int n2, final String[] array, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glShaderSource = this._pat._addressof_glShaderSource;
        if (addressof_glShaderSource == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
        }
        this.dispatch_glShaderSource1(n, n2, array, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glShaderSource);
    }
    
    private native void dispatch_glShaderSource1(final int p0, final int p1, final String[] p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glShaderSource(final int n, final int n2, final String[] array, final int[] array2, final int n3) {
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glShaderSource = this._pat._addressof_glShaderSource;
        if (addressof_glShaderSource == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
        }
        this.dispatch_glShaderSource1(n, n2, array, array2, 4 * n3, false, addressof_glShaderSource);
    }
    
    @Override
    public void glUseProgram(final int n) {
        final long addressof_glUseProgram = this._pat._addressof_glUseProgram;
        if (addressof_glUseProgram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUseProgram"));
        }
        this.dispatch_glUseProgram1(n, addressof_glUseProgram);
    }
    
    private native void dispatch_glUseProgram1(final int p0, final long p1);
    
    @Override
    public void glUniform1f(final int n, final float n2) {
        final long addressof_glUniform1f = this._pat._addressof_glUniform1f;
        if (addressof_glUniform1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1f"));
        }
        this.dispatch_glUniform1f1(n, n2, addressof_glUniform1f);
    }
    
    private native void dispatch_glUniform1f1(final int p0, final float p1, final long p2);
    
    @Override
    public void glUniform2f(final int n, final float n2, final float n3) {
        final long addressof_glUniform2f = this._pat._addressof_glUniform2f;
        if (addressof_glUniform2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2f"));
        }
        this.dispatch_glUniform2f1(n, n2, n3, addressof_glUniform2f);
    }
    
    private native void dispatch_glUniform2f1(final int p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glUniform3f(final int n, final float n2, final float n3, final float n4) {
        final long addressof_glUniform3f = this._pat._addressof_glUniform3f;
        if (addressof_glUniform3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3f"));
        }
        this.dispatch_glUniform3f1(n, n2, n3, n4, addressof_glUniform3f);
    }
    
    private native void dispatch_glUniform3f1(final int p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glUniform4f(final int n, final float n2, final float n3, final float n4, final float n5) {
        final long addressof_glUniform4f = this._pat._addressof_glUniform4f;
        if (addressof_glUniform4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4f"));
        }
        this.dispatch_glUniform4f1(n, n2, n3, n4, n5, addressof_glUniform4f);
    }
    
    private native void dispatch_glUniform4f1(final int p0, final float p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glUniform1i(final int n, final int n2) {
        final long addressof_glUniform1i = this._pat._addressof_glUniform1i;
        if (addressof_glUniform1i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1i"));
        }
        this.dispatch_glUniform1i1(n, n2, addressof_glUniform1i);
    }
    
    private native void dispatch_glUniform1i1(final int p0, final int p1, final long p2);
    
    @Override
    public void glUniform2i(final int n, final int n2, final int n3) {
        final long addressof_glUniform2i = this._pat._addressof_glUniform2i;
        if (addressof_glUniform2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2i"));
        }
        this.dispatch_glUniform2i1(n, n2, n3, addressof_glUniform2i);
    }
    
    private native void dispatch_glUniform2i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glUniform3i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glUniform3i = this._pat._addressof_glUniform3i;
        if (addressof_glUniform3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3i"));
        }
        this.dispatch_glUniform3i1(n, n2, n3, n4, addressof_glUniform3i);
    }
    
    private native void dispatch_glUniform3i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glUniform4i(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glUniform4i = this._pat._addressof_glUniform4i;
        if (addressof_glUniform4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4i"));
        }
        this.dispatch_glUniform4i1(n, n2, n3, n4, n5, addressof_glUniform4i);
    }
    
    private native void dispatch_glUniform4i1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glUniform1fv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform1fv = this._pat._addressof_glUniform1fv;
        if (addressof_glUniform1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
        }
        this.dispatch_glUniform1fv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform1fv);
    }
    
    private native void dispatch_glUniform1fv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1fv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1fv = this._pat._addressof_glUniform1fv;
        if (addressof_glUniform1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
        }
        this.dispatch_glUniform1fv1(n, n2, array, 4 * n3, false, addressof_glUniform1fv);
    }
    
    @Override
    public void glUniform2fv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform2fv = this._pat._addressof_glUniform2fv;
        if (addressof_glUniform2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
        }
        this.dispatch_glUniform2fv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform2fv);
    }
    
    private native void dispatch_glUniform2fv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2fv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2fv = this._pat._addressof_glUniform2fv;
        if (addressof_glUniform2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
        }
        this.dispatch_glUniform2fv1(n, n2, array, 4 * n3, false, addressof_glUniform2fv);
    }
    
    @Override
    public void glUniform3fv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform3fv = this._pat._addressof_glUniform3fv;
        if (addressof_glUniform3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
        }
        this.dispatch_glUniform3fv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform3fv);
    }
    
    private native void dispatch_glUniform3fv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3fv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3fv = this._pat._addressof_glUniform3fv;
        if (addressof_glUniform3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
        }
        this.dispatch_glUniform3fv1(n, n2, array, 4 * n3, false, addressof_glUniform3fv);
    }
    
    @Override
    public void glUniform4fv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform4fv = this._pat._addressof_glUniform4fv;
        if (addressof_glUniform4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
        }
        this.dispatch_glUniform4fv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform4fv);
    }
    
    private native void dispatch_glUniform4fv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4fv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4fv = this._pat._addressof_glUniform4fv;
        if (addressof_glUniform4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
        }
        this.dispatch_glUniform4fv1(n, n2, array, 4 * n3, false, addressof_glUniform4fv);
    }
    
    @Override
    public void glUniform1iv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform1iv = this._pat._addressof_glUniform1iv;
        if (addressof_glUniform1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
        }
        this.dispatch_glUniform1iv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform1iv);
    }
    
    private native void dispatch_glUniform1iv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1iv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1iv = this._pat._addressof_glUniform1iv;
        if (addressof_glUniform1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
        }
        this.dispatch_glUniform1iv1(n, n2, array, 4 * n3, false, addressof_glUniform1iv);
    }
    
    @Override
    public void glUniform2iv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform2iv = this._pat._addressof_glUniform2iv;
        if (addressof_glUniform2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
        }
        this.dispatch_glUniform2iv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform2iv);
    }
    
    private native void dispatch_glUniform2iv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2iv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2iv = this._pat._addressof_glUniform2iv;
        if (addressof_glUniform2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
        }
        this.dispatch_glUniform2iv1(n, n2, array, 4 * n3, false, addressof_glUniform2iv);
    }
    
    @Override
    public void glUniform3iv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform3iv = this._pat._addressof_glUniform3iv;
        if (addressof_glUniform3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
        }
        this.dispatch_glUniform3iv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform3iv);
    }
    
    private native void dispatch_glUniform3iv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3iv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3iv = this._pat._addressof_glUniform3iv;
        if (addressof_glUniform3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
        }
        this.dispatch_glUniform3iv1(n, n2, array, 4 * n3, false, addressof_glUniform3iv);
    }
    
    @Override
    public void glUniform4iv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform4iv = this._pat._addressof_glUniform4iv;
        if (addressof_glUniform4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
        }
        this.dispatch_glUniform4iv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform4iv);
    }
    
    private native void dispatch_glUniform4iv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4iv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4iv = this._pat._addressof_glUniform4iv;
        if (addressof_glUniform4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
        }
        this.dispatch_glUniform4iv1(n, n2, array, 4 * n3, false, addressof_glUniform4iv);
    }
    
    @Override
    public void glUniformMatrix2fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix2fv = this._pat._addressof_glUniformMatrix2fv;
        if (addressof_glUniformMatrix2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
        }
        this.dispatch_glUniformMatrix2fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix2fv);
    }
    
    private native void dispatch_glUniformMatrix2fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix2fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix2fv = this._pat._addressof_glUniformMatrix2fv;
        if (addressof_glUniformMatrix2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
        }
        this.dispatch_glUniformMatrix2fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix2fv);
    }
    
    @Override
    public void glUniformMatrix3fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix3fv = this._pat._addressof_glUniformMatrix3fv;
        if (addressof_glUniformMatrix3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
        }
        this.dispatch_glUniformMatrix3fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix3fv);
    }
    
    private native void dispatch_glUniformMatrix3fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix3fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix3fv = this._pat._addressof_glUniformMatrix3fv;
        if (addressof_glUniformMatrix3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
        }
        this.dispatch_glUniformMatrix3fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix3fv);
    }
    
    @Override
    public void glUniformMatrix4fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix4fv = this._pat._addressof_glUniformMatrix4fv;
        if (addressof_glUniformMatrix4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
        }
        this.dispatch_glUniformMatrix4fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix4fv);
    }
    
    private native void dispatch_glUniformMatrix4fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix4fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix4fv = this._pat._addressof_glUniformMatrix4fv;
        if (addressof_glUniformMatrix4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
        }
        this.dispatch_glUniformMatrix4fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix4fv);
    }
    
    @Override
    public void glValidateProgram(final int n) {
        final long addressof_glValidateProgram = this._pat._addressof_glValidateProgram;
        if (addressof_glValidateProgram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glValidateProgram"));
        }
        this.dispatch_glValidateProgram1(n, addressof_glValidateProgram);
    }
    
    private native void dispatch_glValidateProgram1(final int p0, final long p1);
    
    @Override
    public void glVertexAttrib1d(final int n, final double n2) {
        final long addressof_glVertexAttrib1d = this._pat._addressof_glVertexAttrib1d;
        if (addressof_glVertexAttrib1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1d"));
        }
        this.dispatch_glVertexAttrib1d1(n, n2, addressof_glVertexAttrib1d);
    }
    
    private native void dispatch_glVertexAttrib1d1(final int p0, final double p1, final long p2);
    
    @Override
    public void glVertexAttrib1dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib1dv = this._pat._addressof_glVertexAttrib1dv;
        if (addressof_glVertexAttrib1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dv"));
        }
        this.dispatch_glVertexAttrib1dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib1dv);
    }
    
    private native void dispatch_glVertexAttrib1dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib1dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib1dv = this._pat._addressof_glVertexAttrib1dv;
        if (addressof_glVertexAttrib1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dv"));
        }
        this.dispatch_glVertexAttrib1dv1(n, array, 8 * n2, false, addressof_glVertexAttrib1dv);
    }
    
    @Override
    public void glVertexAttrib1f(final int n, final float n2) {
        final long addressof_glVertexAttrib1f = this._pat._addressof_glVertexAttrib1f;
        if (addressof_glVertexAttrib1f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1f"));
        }
        this.dispatch_glVertexAttrib1f1(n, n2, addressof_glVertexAttrib1f);
    }
    
    private native void dispatch_glVertexAttrib1f1(final int p0, final float p1, final long p2);
    
    @Override
    public void glVertexAttrib1fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib1fv = this._pat._addressof_glVertexAttrib1fv;
        if (addressof_glVertexAttrib1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
        }
        this.dispatch_glVertexAttrib1fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib1fv);
    }
    
    private native void dispatch_glVertexAttrib1fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib1fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib1fv = this._pat._addressof_glVertexAttrib1fv;
        if (addressof_glVertexAttrib1fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
        }
        this.dispatch_glVertexAttrib1fv1(n, array, 4 * n2, false, addressof_glVertexAttrib1fv);
    }
    
    @Override
    public void glVertexAttrib1s(final int n, final short n2) {
        final long addressof_glVertexAttrib1s = this._pat._addressof_glVertexAttrib1s;
        if (addressof_glVertexAttrib1s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1s"));
        }
        this.dispatch_glVertexAttrib1s1(n, n2, addressof_glVertexAttrib1s);
    }
    
    private native void dispatch_glVertexAttrib1s1(final int p0, final short p1, final long p2);
    
    @Override
    public void glVertexAttrib1sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib1sv = this._pat._addressof_glVertexAttrib1sv;
        if (addressof_glVertexAttrib1sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1sv"));
        }
        this.dispatch_glVertexAttrib1sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib1sv);
    }
    
    private native void dispatch_glVertexAttrib1sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib1sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib1sv = this._pat._addressof_glVertexAttrib1sv;
        if (addressof_glVertexAttrib1sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1sv"));
        }
        this.dispatch_glVertexAttrib1sv1(n, array, 2 * n2, false, addressof_glVertexAttrib1sv);
    }
    
    @Override
    public void glVertexAttrib2d(final int n, final double n2, final double n3) {
        final long addressof_glVertexAttrib2d = this._pat._addressof_glVertexAttrib2d;
        if (addressof_glVertexAttrib2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2d"));
        }
        this.dispatch_glVertexAttrib2d1(n, n2, n3, addressof_glVertexAttrib2d);
    }
    
    private native void dispatch_glVertexAttrib2d1(final int p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glVertexAttrib2dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib2dv = this._pat._addressof_glVertexAttrib2dv;
        if (addressof_glVertexAttrib2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dv"));
        }
        this.dispatch_glVertexAttrib2dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib2dv);
    }
    
    private native void dispatch_glVertexAttrib2dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib2dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib2dv = this._pat._addressof_glVertexAttrib2dv;
        if (addressof_glVertexAttrib2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dv"));
        }
        this.dispatch_glVertexAttrib2dv1(n, array, 8 * n2, false, addressof_glVertexAttrib2dv);
    }
    
    @Override
    public void glVertexAttrib2f(final int n, final float n2, final float n3) {
        final long addressof_glVertexAttrib2f = this._pat._addressof_glVertexAttrib2f;
        if (addressof_glVertexAttrib2f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2f"));
        }
        this.dispatch_glVertexAttrib2f1(n, n2, n3, addressof_glVertexAttrib2f);
    }
    
    private native void dispatch_glVertexAttrib2f1(final int p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glVertexAttrib2fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib2fv = this._pat._addressof_glVertexAttrib2fv;
        if (addressof_glVertexAttrib2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
        }
        this.dispatch_glVertexAttrib2fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib2fv);
    }
    
    private native void dispatch_glVertexAttrib2fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib2fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib2fv = this._pat._addressof_glVertexAttrib2fv;
        if (addressof_glVertexAttrib2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
        }
        this.dispatch_glVertexAttrib2fv1(n, array, 4 * n2, false, addressof_glVertexAttrib2fv);
    }
    
    @Override
    public void glVertexAttrib2s(final int n, final short n2, final short n3) {
        final long addressof_glVertexAttrib2s = this._pat._addressof_glVertexAttrib2s;
        if (addressof_glVertexAttrib2s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2s"));
        }
        this.dispatch_glVertexAttrib2s1(n, n2, n3, addressof_glVertexAttrib2s);
    }
    
    private native void dispatch_glVertexAttrib2s1(final int p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glVertexAttrib2sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib2sv = this._pat._addressof_glVertexAttrib2sv;
        if (addressof_glVertexAttrib2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2sv"));
        }
        this.dispatch_glVertexAttrib2sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib2sv);
    }
    
    private native void dispatch_glVertexAttrib2sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib2sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib2sv = this._pat._addressof_glVertexAttrib2sv;
        if (addressof_glVertexAttrib2sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2sv"));
        }
        this.dispatch_glVertexAttrib2sv1(n, array, 2 * n2, false, addressof_glVertexAttrib2sv);
    }
    
    @Override
    public void glVertexAttrib3d(final int n, final double n2, final double n3, final double n4) {
        final long addressof_glVertexAttrib3d = this._pat._addressof_glVertexAttrib3d;
        if (addressof_glVertexAttrib3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3d"));
        }
        this.dispatch_glVertexAttrib3d1(n, n2, n3, n4, addressof_glVertexAttrib3d);
    }
    
    private native void dispatch_glVertexAttrib3d1(final int p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glVertexAttrib3dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib3dv = this._pat._addressof_glVertexAttrib3dv;
        if (addressof_glVertexAttrib3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dv"));
        }
        this.dispatch_glVertexAttrib3dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib3dv);
    }
    
    private native void dispatch_glVertexAttrib3dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib3dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib3dv = this._pat._addressof_glVertexAttrib3dv;
        if (addressof_glVertexAttrib3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dv"));
        }
        this.dispatch_glVertexAttrib3dv1(n, array, 8 * n2, false, addressof_glVertexAttrib3dv);
    }
    
    @Override
    public void glVertexAttrib3f(final int n, final float n2, final float n3, final float n4) {
        final long addressof_glVertexAttrib3f = this._pat._addressof_glVertexAttrib3f;
        if (addressof_glVertexAttrib3f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3f"));
        }
        this.dispatch_glVertexAttrib3f1(n, n2, n3, n4, addressof_glVertexAttrib3f);
    }
    
    private native void dispatch_glVertexAttrib3f1(final int p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glVertexAttrib3fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib3fv = this._pat._addressof_glVertexAttrib3fv;
        if (addressof_glVertexAttrib3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
        }
        this.dispatch_glVertexAttrib3fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib3fv);
    }
    
    private native void dispatch_glVertexAttrib3fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib3fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib3fv = this._pat._addressof_glVertexAttrib3fv;
        if (addressof_glVertexAttrib3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
        }
        this.dispatch_glVertexAttrib3fv1(n, array, 4 * n2, false, addressof_glVertexAttrib3fv);
    }
    
    @Override
    public void glVertexAttrib3s(final int n, final short n2, final short n3, final short n4) {
        final long addressof_glVertexAttrib3s = this._pat._addressof_glVertexAttrib3s;
        if (addressof_glVertexAttrib3s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3s"));
        }
        this.dispatch_glVertexAttrib3s1(n, n2, n3, n4, addressof_glVertexAttrib3s);
    }
    
    private native void dispatch_glVertexAttrib3s1(final int p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glVertexAttrib3sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib3sv = this._pat._addressof_glVertexAttrib3sv;
        if (addressof_glVertexAttrib3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3sv"));
        }
        this.dispatch_glVertexAttrib3sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib3sv);
    }
    
    private native void dispatch_glVertexAttrib3sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib3sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib3sv = this._pat._addressof_glVertexAttrib3sv;
        if (addressof_glVertexAttrib3sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3sv"));
        }
        this.dispatch_glVertexAttrib3sv1(n, array, 2 * n2, false, addressof_glVertexAttrib3sv);
    }
    
    @Override
    public void glVertexAttrib4Nbv(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4Nbv = this._pat._addressof_glVertexAttrib4Nbv;
        if (addressof_glVertexAttrib4Nbv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nbv"));
        }
        this.dispatch_glVertexAttrib4Nbv1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4Nbv);
    }
    
    private native void dispatch_glVertexAttrib4Nbv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4Nbv(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4Nbv = this._pat._addressof_glVertexAttrib4Nbv;
        if (addressof_glVertexAttrib4Nbv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nbv"));
        }
        this.dispatch_glVertexAttrib4Nbv1(n, array, n2, false, addressof_glVertexAttrib4Nbv);
    }
    
    @Override
    public void glVertexAttrib4Niv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4Niv = this._pat._addressof_glVertexAttrib4Niv;
        if (addressof_glVertexAttrib4Niv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Niv"));
        }
        this.dispatch_glVertexAttrib4Niv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4Niv);
    }
    
    private native void dispatch_glVertexAttrib4Niv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4Niv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4Niv = this._pat._addressof_glVertexAttrib4Niv;
        if (addressof_glVertexAttrib4Niv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Niv"));
        }
        this.dispatch_glVertexAttrib4Niv1(n, array, 4 * n2, false, addressof_glVertexAttrib4Niv);
    }
    
    @Override
    public void glVertexAttrib4Nsv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4Nsv = this._pat._addressof_glVertexAttrib4Nsv;
        if (addressof_glVertexAttrib4Nsv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nsv"));
        }
        this.dispatch_glVertexAttrib4Nsv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4Nsv);
    }
    
    private native void dispatch_glVertexAttrib4Nsv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4Nsv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4Nsv = this._pat._addressof_glVertexAttrib4Nsv;
        if (addressof_glVertexAttrib4Nsv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nsv"));
        }
        this.dispatch_glVertexAttrib4Nsv1(n, array, 2 * n2, false, addressof_glVertexAttrib4Nsv);
    }
    
    @Override
    public void glVertexAttrib4Nub(final int n, final byte b, final byte b2, final byte b3, final byte b4) {
        final long addressof_glVertexAttrib4Nub = this._pat._addressof_glVertexAttrib4Nub;
        if (addressof_glVertexAttrib4Nub == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nub"));
        }
        this.dispatch_glVertexAttrib4Nub1(n, b, b2, b3, b4, addressof_glVertexAttrib4Nub);
    }
    
    private native void dispatch_glVertexAttrib4Nub1(final int p0, final byte p1, final byte p2, final byte p3, final byte p4, final long p5);
    
    @Override
    public void glVertexAttrib4Nubv(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4Nubv = this._pat._addressof_glVertexAttrib4Nubv;
        if (addressof_glVertexAttrib4Nubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nubv"));
        }
        this.dispatch_glVertexAttrib4Nubv1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4Nubv);
    }
    
    private native void dispatch_glVertexAttrib4Nubv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4Nubv(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4Nubv = this._pat._addressof_glVertexAttrib4Nubv;
        if (addressof_glVertexAttrib4Nubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nubv"));
        }
        this.dispatch_glVertexAttrib4Nubv1(n, array, n2, false, addressof_glVertexAttrib4Nubv);
    }
    
    @Override
    public void glVertexAttrib4Nuiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4Nuiv = this._pat._addressof_glVertexAttrib4Nuiv;
        if (addressof_glVertexAttrib4Nuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nuiv"));
        }
        this.dispatch_glVertexAttrib4Nuiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4Nuiv);
    }
    
    private native void dispatch_glVertexAttrib4Nuiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4Nuiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4Nuiv = this._pat._addressof_glVertexAttrib4Nuiv;
        if (addressof_glVertexAttrib4Nuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nuiv"));
        }
        this.dispatch_glVertexAttrib4Nuiv1(n, array, 4 * n2, false, addressof_glVertexAttrib4Nuiv);
    }
    
    @Override
    public void glVertexAttrib4Nusv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4Nusv = this._pat._addressof_glVertexAttrib4Nusv;
        if (addressof_glVertexAttrib4Nusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nusv"));
        }
        this.dispatch_glVertexAttrib4Nusv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4Nusv);
    }
    
    private native void dispatch_glVertexAttrib4Nusv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4Nusv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4Nusv = this._pat._addressof_glVertexAttrib4Nusv;
        if (addressof_glVertexAttrib4Nusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nusv"));
        }
        this.dispatch_glVertexAttrib4Nusv1(n, array, 2 * n2, false, addressof_glVertexAttrib4Nusv);
    }
    
    @Override
    public void glVertexAttrib4bv(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4bv = this._pat._addressof_glVertexAttrib4bv;
        if (addressof_glVertexAttrib4bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bv"));
        }
        this.dispatch_glVertexAttrib4bv1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4bv);
    }
    
    private native void dispatch_glVertexAttrib4bv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4bv(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4bv = this._pat._addressof_glVertexAttrib4bv;
        if (addressof_glVertexAttrib4bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bv"));
        }
        this.dispatch_glVertexAttrib4bv1(n, array, n2, false, addressof_glVertexAttrib4bv);
    }
    
    @Override
    public void glVertexAttrib4d(final int n, final double n2, final double n3, final double n4, final double n5) {
        final long addressof_glVertexAttrib4d = this._pat._addressof_glVertexAttrib4d;
        if (addressof_glVertexAttrib4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4d"));
        }
        this.dispatch_glVertexAttrib4d1(n, n2, n3, n4, n5, addressof_glVertexAttrib4d);
    }
    
    private native void dispatch_glVertexAttrib4d1(final int p0, final double p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glVertexAttrib4dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib4dv = this._pat._addressof_glVertexAttrib4dv;
        if (addressof_glVertexAttrib4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dv"));
        }
        this.dispatch_glVertexAttrib4dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib4dv);
    }
    
    private native void dispatch_glVertexAttrib4dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4dv = this._pat._addressof_glVertexAttrib4dv;
        if (addressof_glVertexAttrib4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dv"));
        }
        this.dispatch_glVertexAttrib4dv1(n, array, 8 * n2, false, addressof_glVertexAttrib4dv);
    }
    
    @Override
    public void glVertexAttrib4f(final int n, final float n2, final float n3, final float n4, final float n5) {
        final long addressof_glVertexAttrib4f = this._pat._addressof_glVertexAttrib4f;
        if (addressof_glVertexAttrib4f == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4f"));
        }
        this.dispatch_glVertexAttrib4f1(n, n2, n3, n4, n5, addressof_glVertexAttrib4f);
    }
    
    private native void dispatch_glVertexAttrib4f1(final int p0, final float p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glVertexAttrib4fv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib4fv = this._pat._addressof_glVertexAttrib4fv;
        if (addressof_glVertexAttrib4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
        }
        this.dispatch_glVertexAttrib4fv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib4fv);
    }
    
    private native void dispatch_glVertexAttrib4fv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4fv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4fv = this._pat._addressof_glVertexAttrib4fv;
        if (addressof_glVertexAttrib4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
        }
        this.dispatch_glVertexAttrib4fv1(n, array, 4 * n2, false, addressof_glVertexAttrib4fv);
    }
    
    @Override
    public void glVertexAttrib4iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4iv = this._pat._addressof_glVertexAttrib4iv;
        if (addressof_glVertexAttrib4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4iv"));
        }
        this.dispatch_glVertexAttrib4iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4iv);
    }
    
    private native void dispatch_glVertexAttrib4iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4iv = this._pat._addressof_glVertexAttrib4iv;
        if (addressof_glVertexAttrib4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4iv"));
        }
        this.dispatch_glVertexAttrib4iv1(n, array, 4 * n2, false, addressof_glVertexAttrib4iv);
    }
    
    @Override
    public void glVertexAttrib4s(final int n, final short n2, final short n3, final short n4, final short n5) {
        final long addressof_glVertexAttrib4s = this._pat._addressof_glVertexAttrib4s;
        if (addressof_glVertexAttrib4s == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4s"));
        }
        this.dispatch_glVertexAttrib4s1(n, n2, n3, n4, n5, addressof_glVertexAttrib4s);
    }
    
    private native void dispatch_glVertexAttrib4s1(final int p0, final short p1, final short p2, final short p3, final short p4, final long p5);
    
    @Override
    public void glVertexAttrib4sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4sv = this._pat._addressof_glVertexAttrib4sv;
        if (addressof_glVertexAttrib4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4sv"));
        }
        this.dispatch_glVertexAttrib4sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4sv);
    }
    
    private native void dispatch_glVertexAttrib4sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4sv = this._pat._addressof_glVertexAttrib4sv;
        if (addressof_glVertexAttrib4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4sv"));
        }
        this.dispatch_glVertexAttrib4sv1(n, array, 2 * n2, false, addressof_glVertexAttrib4sv);
    }
    
    @Override
    public void glVertexAttrib4ubv(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4ubv = this._pat._addressof_glVertexAttrib4ubv;
        if (addressof_glVertexAttrib4ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubv"));
        }
        this.dispatch_glVertexAttrib4ubv1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4ubv);
    }
    
    private native void dispatch_glVertexAttrib4ubv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4ubv(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4ubv = this._pat._addressof_glVertexAttrib4ubv;
        if (addressof_glVertexAttrib4ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubv"));
        }
        this.dispatch_glVertexAttrib4ubv1(n, array, n2, false, addressof_glVertexAttrib4ubv);
    }
    
    @Override
    public void glVertexAttrib4uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4uiv = this._pat._addressof_glVertexAttrib4uiv;
        if (addressof_glVertexAttrib4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uiv"));
        }
        this.dispatch_glVertexAttrib4uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4uiv);
    }
    
    private native void dispatch_glVertexAttrib4uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4uiv = this._pat._addressof_glVertexAttrib4uiv;
        if (addressof_glVertexAttrib4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uiv"));
        }
        this.dispatch_glVertexAttrib4uiv1(n, array, 4 * n2, false, addressof_glVertexAttrib4uiv);
    }
    
    @Override
    public void glVertexAttrib4usv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4usv = this._pat._addressof_glVertexAttrib4usv;
        if (addressof_glVertexAttrib4usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usv"));
        }
        this.dispatch_glVertexAttrib4usv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4usv);
    }
    
    private native void dispatch_glVertexAttrib4usv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4usv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4usv = this._pat._addressof_glVertexAttrib4usv;
        if (addressof_glVertexAttrib4usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usv"));
        }
        this.dispatch_glVertexAttrib4usv1(n, array, 2 * n2, false, addressof_glVertexAttrib4usv);
    }
    
    @Override
    public void glVertexAttribPointer(final int n, final int n2, final int n3, final boolean b, final int n4, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glVertexAttribPointer = this._pat._addressof_glVertexAttribPointer;
        if (addressof_glVertexAttribPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
        }
        this.dispatch_glVertexAttribPointer0(n, n2, n3, b, n4, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glVertexAttribPointer);
    }
    
    private native void dispatch_glVertexAttribPointer0(final int p0, final int p1, final int p2, final boolean p3, final int p4, final Object p5, final int p6, final long p7);
    
    @Override
    public void glVertexAttribPointer(final int n, final int n2, final int n3, final boolean b, final int n4, final long n5) {
        this.checkArrayVBOBound(true);
        final long addressof_glVertexAttribPointer = this._pat._addressof_glVertexAttribPointer;
        if (addressof_glVertexAttribPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
        }
        this.dispatch_glVertexAttribPointer0(n, n2, n3, b, n4, n5, addressof_glVertexAttribPointer);
    }
    
    private native void dispatch_glVertexAttribPointer0(final int p0, final int p1, final int p2, final boolean p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glUniformMatrix2x3fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix2x3fv = this._pat._addressof_glUniformMatrix2x3fv;
        if (addressof_glUniformMatrix2x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
        }
        this.dispatch_glUniformMatrix2x3fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix2x3fv);
    }
    
    private native void dispatch_glUniformMatrix2x3fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix2x3fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix2x3fv = this._pat._addressof_glUniformMatrix2x3fv;
        if (addressof_glUniformMatrix2x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
        }
        this.dispatch_glUniformMatrix2x3fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix2x3fv);
    }
    
    @Override
    public void glUniformMatrix3x2fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix3x2fv = this._pat._addressof_glUniformMatrix3x2fv;
        if (addressof_glUniformMatrix3x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
        }
        this.dispatch_glUniformMatrix3x2fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix3x2fv);
    }
    
    private native void dispatch_glUniformMatrix3x2fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix3x2fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix3x2fv = this._pat._addressof_glUniformMatrix3x2fv;
        if (addressof_glUniformMatrix3x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
        }
        this.dispatch_glUniformMatrix3x2fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix3x2fv);
    }
    
    @Override
    public void glUniformMatrix2x4fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix2x4fv = this._pat._addressof_glUniformMatrix2x4fv;
        if (addressof_glUniformMatrix2x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
        }
        this.dispatch_glUniformMatrix2x4fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix2x4fv);
    }
    
    private native void dispatch_glUniformMatrix2x4fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix2x4fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix2x4fv = this._pat._addressof_glUniformMatrix2x4fv;
        if (addressof_glUniformMatrix2x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
        }
        this.dispatch_glUniformMatrix2x4fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix2x4fv);
    }
    
    @Override
    public void glUniformMatrix4x2fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix4x2fv = this._pat._addressof_glUniformMatrix4x2fv;
        if (addressof_glUniformMatrix4x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
        }
        this.dispatch_glUniformMatrix4x2fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix4x2fv);
    }
    
    private native void dispatch_glUniformMatrix4x2fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix4x2fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix4x2fv = this._pat._addressof_glUniformMatrix4x2fv;
        if (addressof_glUniformMatrix4x2fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
        }
        this.dispatch_glUniformMatrix4x2fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix4x2fv);
    }
    
    @Override
    public void glUniformMatrix3x4fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix3x4fv = this._pat._addressof_glUniformMatrix3x4fv;
        if (addressof_glUniformMatrix3x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
        }
        this.dispatch_glUniformMatrix3x4fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix3x4fv);
    }
    
    private native void dispatch_glUniformMatrix3x4fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix3x4fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix3x4fv = this._pat._addressof_glUniformMatrix3x4fv;
        if (addressof_glUniformMatrix3x4fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
        }
        this.dispatch_glUniformMatrix3x4fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix3x4fv);
    }
    
    @Override
    public void glUniformMatrix4x3fv(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix4x3fv = this._pat._addressof_glUniformMatrix4x3fv;
        if (addressof_glUniformMatrix4x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
        }
        this.dispatch_glUniformMatrix4x3fv1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix4x3fv);
    }
    
    private native void dispatch_glUniformMatrix4x3fv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix4x3fv(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix4x3fv = this._pat._addressof_glUniformMatrix4x3fv;
        if (addressof_glUniformMatrix4x3fv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
        }
        this.dispatch_glUniformMatrix4x3fv1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix4x3fv);
    }
    
    @Override
    public void glColorMaski(final int n, final boolean b, final boolean b2, final boolean b3, final boolean b4) {
        final long addressof_glColorMaski = this._pat._addressof_glColorMaski;
        if (addressof_glColorMaski == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorMaski"));
        }
        this.dispatch_glColorMaski1(n, b, b2, b3, b4, addressof_glColorMaski);
    }
    
    private native void dispatch_glColorMaski1(final int p0, final boolean p1, final boolean p2, final boolean p3, final boolean p4, final long p5);
    
    @Override
    public void glGetBooleani_v(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetBooleani_v = this._pat._addressof_glGetBooleani_v;
        if (addressof_glGetBooleani_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBooleani_v"));
        }
        this.dispatch_glGetBooleani_v1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetBooleani_v);
    }
    
    private native void dispatch_glGetBooleani_v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetBooleani_v(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetBooleani_v = this._pat._addressof_glGetBooleani_v;
        if (addressof_glGetBooleani_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBooleani_v"));
        }
        this.dispatch_glGetBooleani_v1(n, n2, array, n3, false, addressof_glGetBooleani_v);
    }
    
    @Override
    public void glGetIntegeri_v(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetIntegeri_v = this._pat._addressof_glGetIntegeri_v;
        if (addressof_glGetIntegeri_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
        }
        this.dispatch_glGetIntegeri_v1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetIntegeri_v);
    }
    
    private native void dispatch_glGetIntegeri_v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetIntegeri_v(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetIntegeri_v = this._pat._addressof_glGetIntegeri_v;
        if (addressof_glGetIntegeri_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
        }
        this.dispatch_glGetIntegeri_v1(n, n2, array, 4 * n3, false, addressof_glGetIntegeri_v);
    }
    
    @Override
    public void glEnablei(final int n, final int n2) {
        final long addressof_glEnablei = this._pat._addressof_glEnablei;
        if (addressof_glEnablei == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnablei"));
        }
        this.dispatch_glEnablei1(n, n2, addressof_glEnablei);
    }
    
    private native void dispatch_glEnablei1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisablei(final int n, final int n2) {
        final long addressof_glDisablei = this._pat._addressof_glDisablei;
        if (addressof_glDisablei == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisablei"));
        }
        this.dispatch_glDisablei1(n, n2, addressof_glDisablei);
    }
    
    private native void dispatch_glDisablei1(final int p0, final int p1, final long p2);
    
    @Override
    public boolean glIsEnabledi(final int n, final int n2) {
        final long addressof_glIsEnabledi = this._pat._addressof_glIsEnabledi;
        if (addressof_glIsEnabledi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsEnabledi"));
        }
        return this.dispatch_glIsEnabledi1(n, n2, addressof_glIsEnabledi);
    }
    
    private native boolean dispatch_glIsEnabledi1(final int p0, final int p1, final long p2);
    
    @Override
    public void glBeginTransformFeedback(final int n) {
        final long addressof_glBeginTransformFeedback = this._pat._addressof_glBeginTransformFeedback;
        if (addressof_glBeginTransformFeedback == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginTransformFeedback"));
        }
        this.dispatch_glBeginTransformFeedback1(n, addressof_glBeginTransformFeedback);
    }
    
    private native void dispatch_glBeginTransformFeedback1(final int p0, final long p1);
    
    @Override
    public void glEndTransformFeedback() {
        final long addressof_glEndTransformFeedback = this._pat._addressof_glEndTransformFeedback;
        if (addressof_glEndTransformFeedback == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndTransformFeedback"));
        }
        this.dispatch_glEndTransformFeedback1(addressof_glEndTransformFeedback);
    }
    
    private native void dispatch_glEndTransformFeedback1(final long p0);
    
    @Override
    public void glBindBufferRange(final int n, final int n2, final int n3, final long n4, final long n5) {
        final long addressof_glBindBufferRange = this._pat._addressof_glBindBufferRange;
        if (addressof_glBindBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindBufferRange"));
        }
        this.dispatch_glBindBufferRange1(n, n2, n3, n4, n5, addressof_glBindBufferRange);
        this.bufferStateTracker.setBoundBufferObject(n, n3);
    }
    
    private native void dispatch_glBindBufferRange1(final int p0, final int p1, final int p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glBindBufferBase(final int n, final int n2, final int n3) {
        final long addressof_glBindBufferBase = this._pat._addressof_glBindBufferBase;
        if (addressof_glBindBufferBase == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindBufferBase"));
        }
        this.dispatch_glBindBufferBase1(n, n2, n3, addressof_glBindBufferBase);
        this.bufferStateTracker.setBoundBufferObject(n, n3);
    }
    
    private native void dispatch_glBindBufferBase1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTransformFeedbackVaryings(final int n, final int n2, final String[] array, final int n3) {
        final long addressof_glTransformFeedbackVaryings = this._pat._addressof_glTransformFeedbackVaryings;
        if (addressof_glTransformFeedbackVaryings == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackVaryings"));
        }
        this.dispatch_glTransformFeedbackVaryings1(n, n2, array, n3, addressof_glTransformFeedbackVaryings);
    }
    
    private native void dispatch_glTransformFeedbackVaryings1(final int p0, final int p1, final String[] p2, final int p3, final long p4);
    
    @Override
    public void glGetTransformFeedbackVarying(final int n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final boolean direct4 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetTransformFeedbackVarying = this._pat._addressof_glGetTransformFeedbackVarying;
        if (addressof_glGetTransformFeedbackVarying == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
        }
        this.dispatch_glGetTransformFeedbackVarying1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, direct4 ? byteBuffer : Buffers.getArray(byteBuffer), direct4 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct4, addressof_glGetTransformFeedbackVarying);
    }
    
    private native void dispatch_glGetTransformFeedbackVarying1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final Object p12, final int p13, final boolean p14, final long p15);
    
    @Override
    public void glGetTransformFeedbackVarying(final int n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5, final int[] array3, final int n6, final byte[] array4, final int n7) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"size_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n6) {
            throw new GLException("array offset argument \"type_offset\" (" + n6 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n7) {
            throw new GLException("array offset argument \"name_offset\" (" + n7 + ") equals or exceeds array length (" + array4.length + ")");
        }
        final long addressof_glGetTransformFeedbackVarying = this._pat._addressof_glGetTransformFeedbackVarying;
        if (addressof_glGetTransformFeedbackVarying == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
        }
        this.dispatch_glGetTransformFeedbackVarying1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, array3, 4 * n6, false, array4, n7, false, addressof_glGetTransformFeedbackVarying);
    }
    
    @Override
    public void glClampColor(final int n, final int n2) {
        final long addressof_glClampColor = this._pat._addressof_glClampColor;
        if (addressof_glClampColor == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClampColor"));
        }
        this.dispatch_glClampColor1(n, n2, addressof_glClampColor);
    }
    
    private native void dispatch_glClampColor1(final int p0, final int p1, final long p2);
    
    @Override
    public void glBeginConditionalRender(final int n, final int n2) {
        final long addressof_glBeginConditionalRender = this._pat._addressof_glBeginConditionalRender;
        if (addressof_glBeginConditionalRender == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginConditionalRender"));
        }
        this.dispatch_glBeginConditionalRender1(n, n2, addressof_glBeginConditionalRender);
    }
    
    private native void dispatch_glBeginConditionalRender1(final int p0, final int p1, final long p2);
    
    @Override
    public void glEndConditionalRender() {
        final long addressof_glEndConditionalRender = this._pat._addressof_glEndConditionalRender;
        if (addressof_glEndConditionalRender == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndConditionalRender"));
        }
        this.dispatch_glEndConditionalRender1(addressof_glEndConditionalRender);
    }
    
    private native void dispatch_glEndConditionalRender1(final long p0);
    
    @Override
    public void glVertexAttribIPointer(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glVertexAttribIPointer = this._pat._addressof_glVertexAttribIPointer;
        if (addressof_glVertexAttribIPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
        }
        this.dispatch_glVertexAttribIPointer0(n, n2, n3, n4, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glVertexAttribIPointer);
    }
    
    private native void dispatch_glVertexAttribIPointer0(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final long p6);
    
    @Override
    public void glVertexAttribIPointer(final int n, final int n2, final int n3, final int n4, final long n5) {
        this.checkArrayVBOBound(true);
        final long addressof_glVertexAttribIPointer = this._pat._addressof_glVertexAttribIPointer;
        if (addressof_glVertexAttribIPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
        }
        this.dispatch_glVertexAttribIPointer0(n, n2, n3, n4, n5, addressof_glVertexAttribIPointer);
    }
    
    private native void dispatch_glVertexAttribIPointer0(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glGetVertexAttribIiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexAttribIiv = this._pat._addressof_glGetVertexAttribIiv;
        if (addressof_glGetVertexAttribIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
        }
        this.dispatch_glGetVertexAttribIiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexAttribIiv);
    }
    
    private native void dispatch_glGetVertexAttribIiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribIiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribIiv = this._pat._addressof_glGetVertexAttribIiv;
        if (addressof_glGetVertexAttribIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
        }
        this.dispatch_glGetVertexAttribIiv1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribIiv);
    }
    
    @Override
    public void glGetVertexAttribIuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexAttribIuiv = this._pat._addressof_glGetVertexAttribIuiv;
        if (addressof_glGetVertexAttribIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
        }
        this.dispatch_glGetVertexAttribIuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexAttribIuiv);
    }
    
    private native void dispatch_glGetVertexAttribIuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribIuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribIuiv = this._pat._addressof_glGetVertexAttribIuiv;
        if (addressof_glGetVertexAttribIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
        }
        this.dispatch_glGetVertexAttribIuiv1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribIuiv);
    }
    
    @Override
    public void glVertexAttribI1i(final int n, final int n2) {
        final long addressof_glVertexAttribI1i = this._pat._addressof_glVertexAttribI1i;
        if (addressof_glVertexAttribI1i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1i"));
        }
        this.dispatch_glVertexAttribI1i1(n, n2, addressof_glVertexAttribI1i);
    }
    
    private native void dispatch_glVertexAttribI1i1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexAttribI2i(final int n, final int n2, final int n3) {
        final long addressof_glVertexAttribI2i = this._pat._addressof_glVertexAttribI2i;
        if (addressof_glVertexAttribI2i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2i"));
        }
        this.dispatch_glVertexAttribI2i1(n, n2, n3, addressof_glVertexAttribI2i);
    }
    
    private native void dispatch_glVertexAttribI2i1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexAttribI3i(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribI3i = this._pat._addressof_glVertexAttribI3i;
        if (addressof_glVertexAttribI3i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3i"));
        }
        this.dispatch_glVertexAttribI3i1(n, n2, n3, n4, addressof_glVertexAttribI3i);
    }
    
    private native void dispatch_glVertexAttribI3i1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribI4i(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexAttribI4i = this._pat._addressof_glVertexAttribI4i;
        if (addressof_glVertexAttribI4i == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4i"));
        }
        this.dispatch_glVertexAttribI4i1(n, n2, n3, n4, n5, addressof_glVertexAttribI4i);
    }
    
    private native void dispatch_glVertexAttribI4i1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexAttribI1ui(final int n, final int n2) {
        final long addressof_glVertexAttribI1ui = this._pat._addressof_glVertexAttribI1ui;
        if (addressof_glVertexAttribI1ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1ui"));
        }
        this.dispatch_glVertexAttribI1ui1(n, n2, addressof_glVertexAttribI1ui);
    }
    
    private native void dispatch_glVertexAttribI1ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexAttribI2ui(final int n, final int n2, final int n3) {
        final long addressof_glVertexAttribI2ui = this._pat._addressof_glVertexAttribI2ui;
        if (addressof_glVertexAttribI2ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2ui"));
        }
        this.dispatch_glVertexAttribI2ui1(n, n2, n3, addressof_glVertexAttribI2ui);
    }
    
    private native void dispatch_glVertexAttribI2ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexAttribI3ui(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribI3ui = this._pat._addressof_glVertexAttribI3ui;
        if (addressof_glVertexAttribI3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3ui"));
        }
        this.dispatch_glVertexAttribI3ui1(n, n2, n3, n4, addressof_glVertexAttribI3ui);
    }
    
    private native void dispatch_glVertexAttribI3ui1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribI4ui(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexAttribI4ui = this._pat._addressof_glVertexAttribI4ui;
        if (addressof_glVertexAttribI4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ui"));
        }
        this.dispatch_glVertexAttribI4ui1(n, n2, n3, n4, n5, addressof_glVertexAttribI4ui);
    }
    
    private native void dispatch_glVertexAttribI4ui1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexAttribI1iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI1iv = this._pat._addressof_glVertexAttribI1iv;
        if (addressof_glVertexAttribI1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1iv"));
        }
        this.dispatch_glVertexAttribI1iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI1iv);
    }
    
    private native void dispatch_glVertexAttribI1iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI1iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI1iv = this._pat._addressof_glVertexAttribI1iv;
        if (addressof_glVertexAttribI1iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1iv"));
        }
        this.dispatch_glVertexAttribI1iv1(n, array, 4 * n2, false, addressof_glVertexAttribI1iv);
    }
    
    @Override
    public void glVertexAttribI2iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI2iv = this._pat._addressof_glVertexAttribI2iv;
        if (addressof_glVertexAttribI2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2iv"));
        }
        this.dispatch_glVertexAttribI2iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI2iv);
    }
    
    private native void dispatch_glVertexAttribI2iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI2iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI2iv = this._pat._addressof_glVertexAttribI2iv;
        if (addressof_glVertexAttribI2iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2iv"));
        }
        this.dispatch_glVertexAttribI2iv1(n, array, 4 * n2, false, addressof_glVertexAttribI2iv);
    }
    
    @Override
    public void glVertexAttribI3iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI3iv = this._pat._addressof_glVertexAttribI3iv;
        if (addressof_glVertexAttribI3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3iv"));
        }
        this.dispatch_glVertexAttribI3iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI3iv);
    }
    
    private native void dispatch_glVertexAttribI3iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI3iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI3iv = this._pat._addressof_glVertexAttribI3iv;
        if (addressof_glVertexAttribI3iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3iv"));
        }
        this.dispatch_glVertexAttribI3iv1(n, array, 4 * n2, false, addressof_glVertexAttribI3iv);
    }
    
    @Override
    public void glVertexAttribI4iv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI4iv = this._pat._addressof_glVertexAttribI4iv;
        if (addressof_glVertexAttribI4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
        }
        this.dispatch_glVertexAttribI4iv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI4iv);
    }
    
    private native void dispatch_glVertexAttribI4iv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4iv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4iv = this._pat._addressof_glVertexAttribI4iv;
        if (addressof_glVertexAttribI4iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
        }
        this.dispatch_glVertexAttribI4iv1(n, array, 4 * n2, false, addressof_glVertexAttribI4iv);
    }
    
    @Override
    public void glVertexAttribI1uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI1uiv = this._pat._addressof_glVertexAttribI1uiv;
        if (addressof_glVertexAttribI1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uiv"));
        }
        this.dispatch_glVertexAttribI1uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI1uiv);
    }
    
    private native void dispatch_glVertexAttribI1uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI1uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI1uiv = this._pat._addressof_glVertexAttribI1uiv;
        if (addressof_glVertexAttribI1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uiv"));
        }
        this.dispatch_glVertexAttribI1uiv1(n, array, 4 * n2, false, addressof_glVertexAttribI1uiv);
    }
    
    @Override
    public void glVertexAttribI2uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI2uiv = this._pat._addressof_glVertexAttribI2uiv;
        if (addressof_glVertexAttribI2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uiv"));
        }
        this.dispatch_glVertexAttribI2uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI2uiv);
    }
    
    private native void dispatch_glVertexAttribI2uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI2uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI2uiv = this._pat._addressof_glVertexAttribI2uiv;
        if (addressof_glVertexAttribI2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uiv"));
        }
        this.dispatch_glVertexAttribI2uiv1(n, array, 4 * n2, false, addressof_glVertexAttribI2uiv);
    }
    
    @Override
    public void glVertexAttribI3uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI3uiv = this._pat._addressof_glVertexAttribI3uiv;
        if (addressof_glVertexAttribI3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uiv"));
        }
        this.dispatch_glVertexAttribI3uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI3uiv);
    }
    
    private native void dispatch_glVertexAttribI3uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI3uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI3uiv = this._pat._addressof_glVertexAttribI3uiv;
        if (addressof_glVertexAttribI3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uiv"));
        }
        this.dispatch_glVertexAttribI3uiv1(n, array, 4 * n2, false, addressof_glVertexAttribI3uiv);
    }
    
    @Override
    public void glVertexAttribI4uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI4uiv = this._pat._addressof_glVertexAttribI4uiv;
        if (addressof_glVertexAttribI4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
        }
        this.dispatch_glVertexAttribI4uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI4uiv);
    }
    
    private native void dispatch_glVertexAttribI4uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4uiv = this._pat._addressof_glVertexAttribI4uiv;
        if (addressof_glVertexAttribI4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
        }
        this.dispatch_glVertexAttribI4uiv1(n, array, 4 * n2, false, addressof_glVertexAttribI4uiv);
    }
    
    @Override
    public void glVertexAttribI4bv(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttribI4bv = this._pat._addressof_glVertexAttribI4bv;
        if (addressof_glVertexAttribI4bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bv"));
        }
        this.dispatch_glVertexAttribI4bv1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttribI4bv);
    }
    
    private native void dispatch_glVertexAttribI4bv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4bv(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4bv = this._pat._addressof_glVertexAttribI4bv;
        if (addressof_glVertexAttribI4bv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bv"));
        }
        this.dispatch_glVertexAttribI4bv1(n, array, n2, false, addressof_glVertexAttribI4bv);
    }
    
    @Override
    public void glVertexAttribI4sv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribI4sv = this._pat._addressof_glVertexAttribI4sv;
        if (addressof_glVertexAttribI4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4sv"));
        }
        this.dispatch_glVertexAttribI4sv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribI4sv);
    }
    
    private native void dispatch_glVertexAttribI4sv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4sv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4sv = this._pat._addressof_glVertexAttribI4sv;
        if (addressof_glVertexAttribI4sv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4sv"));
        }
        this.dispatch_glVertexAttribI4sv1(n, array, 2 * n2, false, addressof_glVertexAttribI4sv);
    }
    
    @Override
    public void glVertexAttribI4ubv(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttribI4ubv = this._pat._addressof_glVertexAttribI4ubv;
        if (addressof_glVertexAttribI4ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubv"));
        }
        this.dispatch_glVertexAttribI4ubv1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttribI4ubv);
    }
    
    private native void dispatch_glVertexAttribI4ubv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4ubv(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4ubv = this._pat._addressof_glVertexAttribI4ubv;
        if (addressof_glVertexAttribI4ubv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubv"));
        }
        this.dispatch_glVertexAttribI4ubv1(n, array, n2, false, addressof_glVertexAttribI4ubv);
    }
    
    @Override
    public void glVertexAttribI4usv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribI4usv = this._pat._addressof_glVertexAttribI4usv;
        if (addressof_glVertexAttribI4usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usv"));
        }
        this.dispatch_glVertexAttribI4usv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribI4usv);
    }
    
    private native void dispatch_glVertexAttribI4usv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4usv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4usv = this._pat._addressof_glVertexAttribI4usv;
        if (addressof_glVertexAttribI4usv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usv"));
        }
        this.dispatch_glVertexAttribI4usv1(n, array, 2 * n2, false, addressof_glVertexAttribI4usv);
    }
    
    @Override
    public void glGetUniformuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetUniformuiv = this._pat._addressof_glGetUniformuiv;
        if (addressof_glGetUniformuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
        }
        this.dispatch_glGetUniformuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetUniformuiv);
    }
    
    private native void dispatch_glGetUniformuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformuiv = this._pat._addressof_glGetUniformuiv;
        if (addressof_glGetUniformuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
        }
        this.dispatch_glGetUniformuiv1(n, n2, array, 4 * n3, false, addressof_glGetUniformuiv);
    }
    
    @Override
    public void glBindFragDataLocation(final int n, final int n2, final String s) {
        final long addressof_glBindFragDataLocation = this._pat._addressof_glBindFragDataLocation;
        if (addressof_glBindFragDataLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocation"));
        }
        this.dispatch_glBindFragDataLocation1(n, n2, s, addressof_glBindFragDataLocation);
    }
    
    private native void dispatch_glBindFragDataLocation1(final int p0, final int p1, final String p2, final long p3);
    
    @Override
    public int glGetFragDataLocation(final int n, final String s) {
        final long addressof_glGetFragDataLocation = this._pat._addressof_glGetFragDataLocation;
        if (addressof_glGetFragDataLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataLocation"));
        }
        return this.dispatch_glGetFragDataLocation1(n, s, addressof_glGetFragDataLocation);
    }
    
    private native int dispatch_glGetFragDataLocation1(final int p0, final String p1, final long p2);
    
    @Override
    public void glUniform1ui(final int n, final int n2) {
        final long addressof_glUniform1ui = this._pat._addressof_glUniform1ui;
        if (addressof_glUniform1ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui"));
        }
        this.dispatch_glUniform1ui1(n, n2, addressof_glUniform1ui);
    }
    
    private native void dispatch_glUniform1ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glUniform2ui(final int n, final int n2, final int n3) {
        final long addressof_glUniform2ui = this._pat._addressof_glUniform2ui;
        if (addressof_glUniform2ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui"));
        }
        this.dispatch_glUniform2ui1(n, n2, n3, addressof_glUniform2ui);
    }
    
    private native void dispatch_glUniform2ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glUniform3ui(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glUniform3ui = this._pat._addressof_glUniform3ui;
        if (addressof_glUniform3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui"));
        }
        this.dispatch_glUniform3ui1(n, n2, n3, n4, addressof_glUniform3ui);
    }
    
    private native void dispatch_glUniform3ui1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glUniform4ui(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glUniform4ui = this._pat._addressof_glUniform4ui;
        if (addressof_glUniform4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui"));
        }
        this.dispatch_glUniform4ui1(n, n2, n3, n4, n5, addressof_glUniform4ui);
    }
    
    private native void dispatch_glUniform4ui1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glUniform1uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform1uiv = this._pat._addressof_glUniform1uiv;
        if (addressof_glUniform1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
        }
        this.dispatch_glUniform1uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform1uiv);
    }
    
    private native void dispatch_glUniform1uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1uiv = this._pat._addressof_glUniform1uiv;
        if (addressof_glUniform1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
        }
        this.dispatch_glUniform1uiv1(n, n2, array, 4 * n3, false, addressof_glUniform1uiv);
    }
    
    @Override
    public void glUniform2uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform2uiv = this._pat._addressof_glUniform2uiv;
        if (addressof_glUniform2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
        }
        this.dispatch_glUniform2uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform2uiv);
    }
    
    private native void dispatch_glUniform2uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2uiv = this._pat._addressof_glUniform2uiv;
        if (addressof_glUniform2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
        }
        this.dispatch_glUniform2uiv1(n, n2, array, 4 * n3, false, addressof_glUniform2uiv);
    }
    
    @Override
    public void glUniform3uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform3uiv = this._pat._addressof_glUniform3uiv;
        if (addressof_glUniform3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
        }
        this.dispatch_glUniform3uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform3uiv);
    }
    
    private native void dispatch_glUniform3uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3uiv = this._pat._addressof_glUniform3uiv;
        if (addressof_glUniform3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
        }
        this.dispatch_glUniform3uiv1(n, n2, array, 4 * n3, false, addressof_glUniform3uiv);
    }
    
    @Override
    public void glUniform4uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform4uiv = this._pat._addressof_glUniform4uiv;
        if (addressof_glUniform4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
        }
        this.dispatch_glUniform4uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform4uiv);
    }
    
    private native void dispatch_glUniform4uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4uiv = this._pat._addressof_glUniform4uiv;
        if (addressof_glUniform4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
        }
        this.dispatch_glUniform4uiv1(n, n2, array, 4 * n3, false, addressof_glUniform4uiv);
    }
    
    @Override
    public void glTexParameterIiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexParameterIiv = this._pat._addressof_glTexParameterIiv;
        if (addressof_glTexParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIiv"));
        }
        this.dispatch_glTexParameterIiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexParameterIiv);
    }
    
    private native void dispatch_glTexParameterIiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexParameterIiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexParameterIiv = this._pat._addressof_glTexParameterIiv;
        if (addressof_glTexParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIiv"));
        }
        this.dispatch_glTexParameterIiv1(n, n2, array, 4 * n3, false, addressof_glTexParameterIiv);
    }
    
    @Override
    public void glTexParameterIuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexParameterIuiv = this._pat._addressof_glTexParameterIuiv;
        if (addressof_glTexParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIuiv"));
        }
        this.dispatch_glTexParameterIuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexParameterIuiv);
    }
    
    private native void dispatch_glTexParameterIuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTexParameterIuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexParameterIuiv = this._pat._addressof_glTexParameterIuiv;
        if (addressof_glTexParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIuiv"));
        }
        this.dispatch_glTexParameterIuiv1(n, n2, array, 4 * n3, false, addressof_glTexParameterIuiv);
    }
    
    @Override
    public void glGetTexParameterIiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTexParameterIiv = this._pat._addressof_glGetTexParameterIiv;
        if (addressof_glGetTexParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIiv"));
        }
        this.dispatch_glGetTexParameterIiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTexParameterIiv);
    }
    
    private native void dispatch_glGetTexParameterIiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexParameterIiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexParameterIiv = this._pat._addressof_glGetTexParameterIiv;
        if (addressof_glGetTexParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIiv"));
        }
        this.dispatch_glGetTexParameterIiv1(n, n2, array, 4 * n3, false, addressof_glGetTexParameterIiv);
    }
    
    @Override
    public void glGetTexParameterIuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTexParameterIuiv = this._pat._addressof_glGetTexParameterIuiv;
        if (addressof_glGetTexParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIuiv"));
        }
        this.dispatch_glGetTexParameterIuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTexParameterIuiv);
    }
    
    private native void dispatch_glGetTexParameterIuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTexParameterIuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTexParameterIuiv = this._pat._addressof_glGetTexParameterIuiv;
        if (addressof_glGetTexParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIuiv"));
        }
        this.dispatch_glGetTexParameterIuiv1(n, n2, array, 4 * n3, false, addressof_glGetTexParameterIuiv);
    }
    
    @Override
    public void glClearBufferiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glClearBufferiv = this._pat._addressof_glClearBufferiv;
        if (addressof_glClearBufferiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
        }
        this.dispatch_glClearBufferiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glClearBufferiv);
    }
    
    private native void dispatch_glClearBufferiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glClearBufferiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClearBufferiv = this._pat._addressof_glClearBufferiv;
        if (addressof_glClearBufferiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
        }
        this.dispatch_glClearBufferiv1(n, n2, array, 4 * n3, false, addressof_glClearBufferiv);
    }
    
    @Override
    public void glClearBufferuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glClearBufferuiv = this._pat._addressof_glClearBufferuiv;
        if (addressof_glClearBufferuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
        }
        this.dispatch_glClearBufferuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glClearBufferuiv);
    }
    
    private native void dispatch_glClearBufferuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glClearBufferuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClearBufferuiv = this._pat._addressof_glClearBufferuiv;
        if (addressof_glClearBufferuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
        }
        this.dispatch_glClearBufferuiv1(n, n2, array, 4 * n3, false, addressof_glClearBufferuiv);
    }
    
    @Override
    public void glClearBufferfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glClearBufferfv = this._pat._addressof_glClearBufferfv;
        if (addressof_glClearBufferfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
        }
        this.dispatch_glClearBufferfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glClearBufferfv);
    }
    
    private native void dispatch_glClearBufferfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glClearBufferfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClearBufferfv = this._pat._addressof_glClearBufferfv;
        if (addressof_glClearBufferfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
        }
        this.dispatch_glClearBufferfv1(n, n2, array, 4 * n3, false, addressof_glClearBufferfv);
    }
    
    @Override
    public void glClearBufferfi(final int n, final int n2, final float n3, final int n4) {
        final long addressof_glClearBufferfi = this._pat._addressof_glClearBufferfi;
        if (addressof_glClearBufferfi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfi"));
        }
        this.dispatch_glClearBufferfi1(n, n2, n3, n4, addressof_glClearBufferfi);
    }
    
    private native void dispatch_glClearBufferfi1(final int p0, final int p1, final float p2, final int p3, final long p4);
    
    @Override
    public String glGetStringi(final int n, final int n2) {
        final long addressof_glGetStringi = this._pat._addressof_glGetStringi;
        if (addressof_glGetStringi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetStringi"));
        }
        return this.dispatch_glGetStringi1(n, n2, addressof_glGetStringi);
    }
    
    private native String dispatch_glGetStringi1(final int p0, final int p1, final long p2);
    
    @Override
    public boolean glIsRenderbuffer(final int n) {
        final long addressof_glIsRenderbuffer = this._pat._addressof_glIsRenderbuffer;
        if (addressof_glIsRenderbuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsRenderbuffer"));
        }
        return this.dispatch_glIsRenderbuffer1(n, addressof_glIsRenderbuffer);
    }
    
    private native boolean dispatch_glIsRenderbuffer1(final int p0, final long p1);
    
    @Override
    public void glBindRenderbuffer(final int n, final int n2) {
        final long addressof_glBindRenderbuffer = this._pat._addressof_glBindRenderbuffer;
        if (addressof_glBindRenderbuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindRenderbuffer"));
        }
        this.dispatch_glBindRenderbuffer1(n, n2, addressof_glBindRenderbuffer);
    }
    
    private native void dispatch_glBindRenderbuffer1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDeleteRenderbuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteRenderbuffers = this._pat._addressof_glDeleteRenderbuffers;
        if (addressof_glDeleteRenderbuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
        }
        this.dispatch_glDeleteRenderbuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteRenderbuffers);
    }
    
    private native void dispatch_glDeleteRenderbuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteRenderbuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"renderbuffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteRenderbuffers = this._pat._addressof_glDeleteRenderbuffers;
        if (addressof_glDeleteRenderbuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
        }
        this.dispatch_glDeleteRenderbuffers1(n, array, 4 * n2, false, addressof_glDeleteRenderbuffers);
    }
    
    @Override
    public void glGenRenderbuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenRenderbuffers = this._pat._addressof_glGenRenderbuffers;
        if (addressof_glGenRenderbuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
        }
        this.dispatch_glGenRenderbuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenRenderbuffers);
    }
    
    private native void dispatch_glGenRenderbuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenRenderbuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"renderbuffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenRenderbuffers = this._pat._addressof_glGenRenderbuffers;
        if (addressof_glGenRenderbuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
        }
        this.dispatch_glGenRenderbuffers1(n, array, 4 * n2, false, addressof_glGenRenderbuffers);
    }
    
    @Override
    public void glRenderbufferStorage(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glRenderbufferStorage = this._pat._addressof_glRenderbufferStorage;
        if (addressof_glRenderbufferStorage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorage"));
        }
        this.dispatch_glRenderbufferStorage1(n, n2, n3, n4, addressof_glRenderbufferStorage);
    }
    
    private native void dispatch_glRenderbufferStorage1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glGetRenderbufferParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetRenderbufferParameteriv = this._pat._addressof_glGetRenderbufferParameteriv;
        if (addressof_glGetRenderbufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
        }
        this.dispatch_glGetRenderbufferParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetRenderbufferParameteriv);
    }
    
    private native void dispatch_glGetRenderbufferParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetRenderbufferParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetRenderbufferParameteriv = this._pat._addressof_glGetRenderbufferParameteriv;
        if (addressof_glGetRenderbufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
        }
        this.dispatch_glGetRenderbufferParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetRenderbufferParameteriv);
    }
    
    @Override
    public boolean glIsFramebuffer(final int n) {
        final long addressof_glIsFramebuffer = this._pat._addressof_glIsFramebuffer;
        if (addressof_glIsFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsFramebuffer"));
        }
        return this.dispatch_glIsFramebuffer1(n, addressof_glIsFramebuffer);
    }
    
    private native boolean dispatch_glIsFramebuffer1(final int p0, final long p1);
    
    @Override
    public void glBindFramebuffer(final int n, int n2) {
        if (0 == n2) {
            if (36160 == n || 36009 == n) {
                n2 = this._context.getDefaultDrawFramebuffer();
            }
            else if (36008 == n) {
                n2 = this._context.getDefaultReadFramebuffer();
            }
        }
        final long addressof_glBindFramebuffer = this._pat._addressof_glBindFramebuffer;
        if (addressof_glBindFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindFramebuffer"));
        }
        this.dispatch_glBindFramebuffer1(n, n2, addressof_glBindFramebuffer);
        this._context.setBoundFramebuffer(n, n2);
    }
    
    private native void dispatch_glBindFramebuffer1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDeleteFramebuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteFramebuffers = this._pat._addressof_glDeleteFramebuffers;
        if (addressof_glDeleteFramebuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
        }
        this.dispatch_glDeleteFramebuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteFramebuffers);
    }
    
    private native void dispatch_glDeleteFramebuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteFramebuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"framebuffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteFramebuffers = this._pat._addressof_glDeleteFramebuffers;
        if (addressof_glDeleteFramebuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
        }
        this.dispatch_glDeleteFramebuffers1(n, array, 4 * n2, false, addressof_glDeleteFramebuffers);
    }
    
    @Override
    public void glGenFramebuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenFramebuffers = this._pat._addressof_glGenFramebuffers;
        if (addressof_glGenFramebuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
        }
        this.dispatch_glGenFramebuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenFramebuffers);
    }
    
    private native void dispatch_glGenFramebuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenFramebuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"framebuffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenFramebuffers = this._pat._addressof_glGenFramebuffers;
        if (addressof_glGenFramebuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
        }
        this.dispatch_glGenFramebuffers1(n, array, 4 * n2, false, addressof_glGenFramebuffers);
    }
    
    @Override
    public int glCheckFramebufferStatus(final int n) {
        final long addressof_glCheckFramebufferStatus = this._pat._addressof_glCheckFramebufferStatus;
        if (addressof_glCheckFramebufferStatus == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCheckFramebufferStatus"));
        }
        return this.dispatch_glCheckFramebufferStatus1(n, addressof_glCheckFramebufferStatus);
    }
    
    private native int dispatch_glCheckFramebufferStatus1(final int p0, final long p1);
    
    @Override
    public void glFramebufferTexture1D(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glFramebufferTexture1D = this._pat._addressof_glFramebufferTexture1D;
        if (addressof_glFramebufferTexture1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture1D"));
        }
        this.dispatch_glFramebufferTexture1D1(n, n2, n3, n4, n5, addressof_glFramebufferTexture1D);
    }
    
    private native void dispatch_glFramebufferTexture1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glFramebufferTexture2D(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glFramebufferTexture2D = this._pat._addressof_glFramebufferTexture2D;
        if (addressof_glFramebufferTexture2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2D"));
        }
        this.dispatch_glFramebufferTexture2D1(n, n2, n3, n4, n5, addressof_glFramebufferTexture2D);
    }
    
    private native void dispatch_glFramebufferTexture2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glFramebufferTexture3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glFramebufferTexture3D = this._pat._addressof_glFramebufferTexture3D;
        if (addressof_glFramebufferTexture3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture3D"));
        }
        this.dispatch_glFramebufferTexture3D1(n, n2, n3, n4, n5, n6, addressof_glFramebufferTexture3D);
    }
    
    private native void dispatch_glFramebufferTexture3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glFramebufferRenderbuffer(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glFramebufferRenderbuffer = this._pat._addressof_glFramebufferRenderbuffer;
        if (addressof_glFramebufferRenderbuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferRenderbuffer"));
        }
        this.dispatch_glFramebufferRenderbuffer1(n, n2, n3, n4, addressof_glFramebufferRenderbuffer);
    }
    
    private native void dispatch_glFramebufferRenderbuffer1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glGetFramebufferAttachmentParameteriv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetFramebufferAttachmentParameteriv = this._pat._addressof_glGetFramebufferAttachmentParameteriv;
        if (addressof_glGetFramebufferAttachmentParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
        }
        this.dispatch_glGetFramebufferAttachmentParameteriv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetFramebufferAttachmentParameteriv);
    }
    
    private native void dispatch_glGetFramebufferAttachmentParameteriv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetFramebufferAttachmentParameteriv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFramebufferAttachmentParameteriv = this._pat._addressof_glGetFramebufferAttachmentParameteriv;
        if (addressof_glGetFramebufferAttachmentParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
        }
        this.dispatch_glGetFramebufferAttachmentParameteriv1(n, n2, n3, array, 4 * n4, false, addressof_glGetFramebufferAttachmentParameteriv);
    }
    
    @Override
    public void glGenerateMipmap(final int n) {
        final long addressof_glGenerateMipmap = this._pat._addressof_glGenerateMipmap;
        if (addressof_glGenerateMipmap == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenerateMipmap"));
        }
        this.dispatch_glGenerateMipmap1(n, addressof_glGenerateMipmap);
    }
    
    private native void dispatch_glGenerateMipmap1(final int p0, final long p1);
    
    @Override
    public void glBlitFramebuffer(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10) {
        final long addressof_glBlitFramebuffer = this._pat._addressof_glBlitFramebuffer;
        if (addressof_glBlitFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebuffer"));
        }
        this.dispatch_glBlitFramebuffer1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, addressof_glBlitFramebuffer);
    }
    
    private native void dispatch_glBlitFramebuffer1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final long p10);
    
    @Override
    public void glRenderbufferStorageMultisample(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glRenderbufferStorageMultisample = this._pat._addressof_glRenderbufferStorageMultisample;
        if (addressof_glRenderbufferStorageMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisample"));
        }
        this.dispatch_glRenderbufferStorageMultisample1(n, n2, n3, n4, n5, addressof_glRenderbufferStorageMultisample);
    }
    
    private native void dispatch_glRenderbufferStorageMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glFramebufferTextureLayer(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glFramebufferTextureLayer = this._pat._addressof_glFramebufferTextureLayer;
        if (addressof_glFramebufferTextureLayer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureLayer"));
        }
        this.dispatch_glFramebufferTextureLayer1(n, n2, n3, n4, n5, addressof_glFramebufferTextureLayer);
    }
    
    private native void dispatch_glFramebufferTextureLayer1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    private long glMapBufferRangeDelegate(final int n, final long n2, final long n3, final int n4) {
        final long addressof_glMapBufferRange = this._pat._addressof_glMapBufferRange;
        if (addressof_glMapBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapBufferRange"));
        }
        return this.dispatch_glMapBufferRangeDelegate1(n, n2, n3, n4, addressof_glMapBufferRange);
    }
    
    private native long dispatch_glMapBufferRangeDelegate1(final int p0, final long p1, final long p2, final int p3, final long p4);
    
    @Override
    public void glFlushMappedBufferRange(final int n, final long n2, final long n3) {
        final long addressof_glFlushMappedBufferRange = this._pat._addressof_glFlushMappedBufferRange;
        if (addressof_glFlushMappedBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedBufferRange"));
        }
        this.dispatch_glFlushMappedBufferRange1(n, n2, n3, addressof_glFlushMappedBufferRange);
    }
    
    private native void dispatch_glFlushMappedBufferRange1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glBindVertexArray(final int n) {
        final long addressof_glBindVertexArray = this._pat._addressof_glBindVertexArray;
        if (addressof_glBindVertexArray == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindVertexArray"));
        }
        this.dispatch_glBindVertexArray1(n, addressof_glBindVertexArray);
        this.bufferStateTracker.setBoundBufferObject(34229, n);
    }
    
    private native void dispatch_glBindVertexArray1(final int p0, final long p1);
    
    @Override
    public void glDeleteVertexArrays(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteVertexArrays = this._pat._addressof_glDeleteVertexArrays;
        if (addressof_glDeleteVertexArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
        }
        this.dispatch_glDeleteVertexArrays1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteVertexArrays);
    }
    
    private native void dispatch_glDeleteVertexArrays1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteVertexArrays(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"arrays_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteVertexArrays = this._pat._addressof_glDeleteVertexArrays;
        if (addressof_glDeleteVertexArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
        }
        this.dispatch_glDeleteVertexArrays1(n, array, 4 * n2, false, addressof_glDeleteVertexArrays);
    }
    
    @Override
    public void glGenVertexArrays(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenVertexArrays = this._pat._addressof_glGenVertexArrays;
        if (addressof_glGenVertexArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
        }
        this.dispatch_glGenVertexArrays1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenVertexArrays);
    }
    
    private native void dispatch_glGenVertexArrays1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenVertexArrays(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"arrays_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenVertexArrays = this._pat._addressof_glGenVertexArrays;
        if (addressof_glGenVertexArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
        }
        this.dispatch_glGenVertexArrays1(n, array, 4 * n2, false, addressof_glGenVertexArrays);
    }
    
    @Override
    public boolean glIsVertexArray(final int n) {
        final long addressof_glIsVertexArray = this._pat._addressof_glIsVertexArray;
        if (addressof_glIsVertexArray == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsVertexArray"));
        }
        return this.dispatch_glIsVertexArray1(n, addressof_glIsVertexArray);
    }
    
    private native boolean dispatch_glIsVertexArray1(final int p0, final long p1);
    
    @Override
    public void glDrawArraysInstanced(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glDrawArraysInstanced = this._pat._addressof_glDrawArraysInstanced;
        if (addressof_glDrawArraysInstanced == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstanced"));
        }
        this.dispatch_glDrawArraysInstanced1(n, n2, n3, n4, addressof_glDrawArraysInstanced);
    }
    
    private native void dispatch_glDrawArraysInstanced1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glDrawElementsInstanced(final int n, final int n2, final int n3, final Buffer buffer, final int n4) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n2);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawElementsInstanced = this._pat._addressof_glDrawElementsInstanced;
        if (addressof_glDrawElementsInstanced == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
        }
        this.dispatch_glDrawElementsInstanced1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n4, addressof_glDrawElementsInstanced);
    }
    
    private native void dispatch_glDrawElementsInstanced1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final int p6, final long p7);
    
    @Override
    public void glDrawElementsInstanced(final int n, final int n2, final int n3, final long n4, final int n5) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawElementsInstanced = this._pat._addressof_glDrawElementsInstanced;
        if (addressof_glDrawElementsInstanced == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
        }
        this.dispatch_glDrawElementsInstanced1(n, n2, n3, n4, n5, addressof_glDrawElementsInstanced);
    }
    
    private native void dispatch_glDrawElementsInstanced1(final int p0, final int p1, final int p2, final long p3, final int p4, final long p5);
    
    @Override
    public void glTexBuffer(final int n, final int n2, final int n3) {
        final long addressof_glTexBuffer = this._pat._addressof_glTexBuffer;
        if (addressof_glTexBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexBuffer"));
        }
        this.dispatch_glTexBuffer1(n, n2, n3, addressof_glTexBuffer);
    }
    
    private native void dispatch_glTexBuffer1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glPrimitiveRestartIndex(final int n) {
        final long addressof_glPrimitiveRestartIndex = this._pat._addressof_glPrimitiveRestartIndex;
        if (addressof_glPrimitiveRestartIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveRestartIndex"));
        }
        this.dispatch_glPrimitiveRestartIndex1(n, addressof_glPrimitiveRestartIndex);
    }
    
    private native void dispatch_glPrimitiveRestartIndex1(final int p0, final long p1);
    
    @Override
    public void glCopyBufferSubData(final int n, final int n2, final long n3, final long n4, final long n5) {
        final long addressof_glCopyBufferSubData = this._pat._addressof_glCopyBufferSubData;
        if (addressof_glCopyBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyBufferSubData"));
        }
        this.dispatch_glCopyBufferSubData1(n, n2, n3, n4, n5, addressof_glCopyBufferSubData);
    }
    
    private native void dispatch_glCopyBufferSubData1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glGetUniformIndices(final int n, final int n2, final String[] array, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetUniformIndices = this._pat._addressof_glGetUniformIndices;
        if (addressof_glGetUniformIndices == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
        }
        this.dispatch_glGetUniformIndices1(n, n2, array, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetUniformIndices);
    }
    
    private native void dispatch_glGetUniformIndices1(final int p0, final int p1, final String[] p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetUniformIndices(final int n, final int n2, final String[] array, final int[] array2, final int n3) {
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"uniformIndices_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetUniformIndices = this._pat._addressof_glGetUniformIndices;
        if (addressof_glGetUniformIndices == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
        }
        this.dispatch_glGetUniformIndices1(n, n2, array, array2, 4 * n3, false, addressof_glGetUniformIndices);
    }
    
    @Override
    public void glGetActiveUniformsiv(final int n, final int n2, final IntBuffer intBuffer, final int n3, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glGetActiveUniformsiv = this._pat._addressof_glGetActiveUniformsiv;
        if (addressof_glGetActiveUniformsiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
        }
        this.dispatch_glGetActiveUniformsiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, n3, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glGetActiveUniformsiv);
    }
    
    private native void dispatch_glGetActiveUniformsiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetActiveUniformsiv(final int n, final int n2, final int[] array, final int n3, final int n4, final int[] array2, final int n5) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"uniformIndices_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetActiveUniformsiv = this._pat._addressof_glGetActiveUniformsiv;
        if (addressof_glGetActiveUniformsiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
        }
        this.dispatch_glGetActiveUniformsiv1(n, n2, array, 4 * n3, false, n4, array2, 4 * n5, false, addressof_glGetActiveUniformsiv);
    }
    
    @Override
    public void glGetActiveUniformName(final int n, final int n2, final int n3, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetActiveUniformName = this._pat._addressof_glGetActiveUniformName;
        if (addressof_glGetActiveUniformName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformName"));
        }
        this.dispatch_glGetActiveUniformName1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetActiveUniformName);
    }
    
    private native void dispatch_glGetActiveUniformName1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetActiveUniformName(final int n, final int n2, final int n3, final int[] array, final int n4, final byte[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"uniformName_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetActiveUniformName = this._pat._addressof_glGetActiveUniformName;
        if (addressof_glGetActiveUniformName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformName"));
        }
        this.dispatch_glGetActiveUniformName1(n, n2, n3, array, 4 * n4, false, array2, n5, false, addressof_glGetActiveUniformName);
    }
    
    @Override
    public int glGetUniformBlockIndex(final int n, final String s) {
        final long addressof_glGetUniformBlockIndex = this._pat._addressof_glGetUniformBlockIndex;
        if (addressof_glGetUniformBlockIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformBlockIndex"));
        }
        return this.dispatch_glGetUniformBlockIndex1(n, s, addressof_glGetUniformBlockIndex);
    }
    
    private native int dispatch_glGetUniformBlockIndex1(final int p0, final String p1, final long p2);
    
    @Override
    public void glGetActiveUniformBlockiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetActiveUniformBlockiv = this._pat._addressof_glGetActiveUniformBlockiv;
        if (addressof_glGetActiveUniformBlockiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
        }
        this.dispatch_glGetActiveUniformBlockiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetActiveUniformBlockiv);
    }
    
    private native void dispatch_glGetActiveUniformBlockiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetActiveUniformBlockiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetActiveUniformBlockiv = this._pat._addressof_glGetActiveUniformBlockiv;
        if (addressof_glGetActiveUniformBlockiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
        }
        this.dispatch_glGetActiveUniformBlockiv1(n, n2, n3, array, 4 * n4, false, addressof_glGetActiveUniformBlockiv);
    }
    
    @Override
    public void glGetActiveUniformBlockName(final int n, final int n2, final int n3, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetActiveUniformBlockName = this._pat._addressof_glGetActiveUniformBlockName;
        if (addressof_glGetActiveUniformBlockName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
        }
        this.dispatch_glGetActiveUniformBlockName1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetActiveUniformBlockName);
    }
    
    private native void dispatch_glGetActiveUniformBlockName1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetActiveUniformBlockName(final int n, final int n2, final int n3, final int[] array, final int n4, final byte[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"uniformBlockName_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetActiveUniformBlockName = this._pat._addressof_glGetActiveUniformBlockName;
        if (addressof_glGetActiveUniformBlockName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
        }
        this.dispatch_glGetActiveUniformBlockName1(n, n2, n3, array, 4 * n4, false, array2, n5, false, addressof_glGetActiveUniformBlockName);
    }
    
    @Override
    public void glUniformBlockBinding(final int n, final int n2, final int n3) {
        final long addressof_glUniformBlockBinding = this._pat._addressof_glUniformBlockBinding;
        if (addressof_glUniformBlockBinding == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformBlockBinding"));
        }
        this.dispatch_glUniformBlockBinding1(n, n2, n3, addressof_glUniformBlockBinding);
    }
    
    private native void dispatch_glUniformBlockBinding1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glDrawElementsBaseVertex(final int n, final int n2, final int n3, final Buffer buffer, final int n4) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n2);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawElementsBaseVertex = this._pat._addressof_glDrawElementsBaseVertex;
        if (addressof_glDrawElementsBaseVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertex"));
        }
        this.dispatch_glDrawElementsBaseVertex1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n4, addressof_glDrawElementsBaseVertex);
    }
    
    private native void dispatch_glDrawElementsBaseVertex1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final int p6, final long p7);
    
    @Override
    public void glDrawElementsBaseVertex(final int n, final int n2, final int n3, final long n4, final int n5) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawElementsBaseVertex = this._pat._addressof_glDrawElementsBaseVertex;
        if (addressof_glDrawElementsBaseVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertex"));
        }
        this.dispatch_glDrawElementsBaseVertex1(n, n2, n3, n4, n5, addressof_glDrawElementsBaseVertex);
    }
    
    private native void dispatch_glDrawElementsBaseVertex1(final int p0, final int p1, final int p2, final long p3, final int p4, final long p5);
    
    @Override
    public void glDrawRangeElementsBaseVertex(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer, final int n6) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n4);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawRangeElementsBaseVertex = this._pat._addressof_glDrawRangeElementsBaseVertex;
        if (addressof_glDrawRangeElementsBaseVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertex"));
        }
        this.dispatch_glDrawRangeElementsBaseVertex1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n6, addressof_glDrawRangeElementsBaseVertex);
    }
    
    private native void dispatch_glDrawRangeElementsBaseVertex1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final int p8, final long p9);
    
    @Override
    public void glDrawRangeElementsBaseVertex(final int n, final int n2, final int n3, final int n4, final int n5, final long n6, final int n7) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawRangeElementsBaseVertex = this._pat._addressof_glDrawRangeElementsBaseVertex;
        if (addressof_glDrawRangeElementsBaseVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertex"));
        }
        this.dispatch_glDrawRangeElementsBaseVertex1(n, n2, n3, n4, n5, n6, n7, addressof_glDrawRangeElementsBaseVertex);
    }
    
    private native void dispatch_glDrawRangeElementsBaseVertex1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final int p6, final long p7);
    
    @Override
    public void glDrawElementsInstancedBaseVertex(final int n, final int n2, final int n3, final Buffer buffer, final int n4, final int n5) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n2);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawElementsInstancedBaseVertex = this._pat._addressof_glDrawElementsInstancedBaseVertex;
        if (addressof_glDrawElementsInstancedBaseVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertex"));
        }
        this.dispatch_glDrawElementsInstancedBaseVertex1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n4, n5, addressof_glDrawElementsInstancedBaseVertex);
    }
    
    private native void dispatch_glDrawElementsInstancedBaseVertex1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glDrawElementsInstancedBaseVertex(final int n, final int n2, final int n3, final long n4, final int n5, final int n6) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawElementsInstancedBaseVertex = this._pat._addressof_glDrawElementsInstancedBaseVertex;
        if (addressof_glDrawElementsInstancedBaseVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertex"));
        }
        this.dispatch_glDrawElementsInstancedBaseVertex1(n, n2, n3, n4, n5, n6, addressof_glDrawElementsInstancedBaseVertex);
    }
    
    private native void dispatch_glDrawElementsInstancedBaseVertex1(final int p0, final int p1, final int p2, final long p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glMultiDrawElementsBaseVertex(final int n, final IntBuffer intBuffer, final int n2, final PointerBuffer pointerBuffer, final int n3, final IntBuffer intBuffer2) {
        if (!Buffers.isDirect(intBuffer)) {
            throw new GLException("Argument \"count\" is not a direct buffer");
        }
        if (!Buffers.isDirect(pointerBuffer)) {
            throw new GLException("Argument \"indices\" is not a direct buffer");
        }
        if (!Buffers.isDirect(intBuffer2)) {
            throw new GLException("Argument \"basevertex\" is not a direct buffer");
        }
        final long addressof_glMultiDrawElementsBaseVertex = this._pat._addressof_glMultiDrawElementsBaseVertex;
        if (addressof_glMultiDrawElementsBaseVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsBaseVertex"));
        }
        this.dispatch_glMultiDrawElementsBaseVertex0(n, intBuffer, Buffers.getDirectBufferByteOffset(intBuffer), n2, (pointerBuffer != null) ? pointerBuffer.getBuffer() : null, Buffers.getDirectBufferByteOffset(pointerBuffer), n3, intBuffer2, Buffers.getDirectBufferByteOffset(intBuffer2), addressof_glMultiDrawElementsBaseVertex);
    }
    
    private native void dispatch_glMultiDrawElementsBaseVertex0(final int p0, final Object p1, final int p2, final int p3, final Object p4, final int p5, final int p6, final Object p7, final int p8, final long p9);
    
    @Override
    public void glProvokingVertex(final int n) {
        final long addressof_glProvokingVertex = this._pat._addressof_glProvokingVertex;
        if (addressof_glProvokingVertex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProvokingVertex"));
        }
        this.dispatch_glProvokingVertex1(n, addressof_glProvokingVertex);
    }
    
    private native void dispatch_glProvokingVertex1(final int p0, final long p1);
    
    @Override
    public long glFenceSync(final int n, final int n2) {
        final long addressof_glFenceSync = this._pat._addressof_glFenceSync;
        if (addressof_glFenceSync == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFenceSync"));
        }
        return this.dispatch_glFenceSync1(n, n2, addressof_glFenceSync);
    }
    
    private native long dispatch_glFenceSync1(final int p0, final int p1, final long p2);
    
    @Override
    public boolean glIsSync(final long n) {
        final long addressof_glIsSync = this._pat._addressof_glIsSync;
        if (addressof_glIsSync == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsSync"));
        }
        return this.dispatch_glIsSync1(n, addressof_glIsSync);
    }
    
    private native boolean dispatch_glIsSync1(final long p0, final long p1);
    
    @Override
    public void glDeleteSync(final long n) {
        final long addressof_glDeleteSync = this._pat._addressof_glDeleteSync;
        if (addressof_glDeleteSync == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteSync"));
        }
        this.dispatch_glDeleteSync1(n, addressof_glDeleteSync);
    }
    
    private native void dispatch_glDeleteSync1(final long p0, final long p1);
    
    @Override
    public int glClientWaitSync(final long n, final int n2, final long n3) {
        final long addressof_glClientWaitSync = this._pat._addressof_glClientWaitSync;
        if (addressof_glClientWaitSync == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClientWaitSync"));
        }
        return this.dispatch_glClientWaitSync1(n, n2, n3, addressof_glClientWaitSync);
    }
    
    private native int dispatch_glClientWaitSync1(final long p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glWaitSync(final long n, final int n2, final long n3) {
        final long addressof_glWaitSync = this._pat._addressof_glWaitSync;
        if (addressof_glWaitSync == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWaitSync"));
        }
        this.dispatch_glWaitSync1(n, n2, n3, addressof_glWaitSync);
    }
    
    private native void dispatch_glWaitSync1(final long p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glGetInteger64v(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetInteger64v = this._pat._addressof_glGetInteger64v;
        if (addressof_glGetInteger64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
        }
        this.dispatch_glGetInteger64v1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetInteger64v);
    }
    
    private native void dispatch_glGetInteger64v1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetInteger64v(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"data_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetInteger64v = this._pat._addressof_glGetInteger64v;
        if (addressof_glGetInteger64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
        }
        this.dispatch_glGetInteger64v1(n, array, 8 * n2, false, addressof_glGetInteger64v);
    }
    
    @Override
    public void glGetSynciv(final long n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glGetSynciv = this._pat._addressof_glGetSynciv;
        if (addressof_glGetSynciv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
        }
        this.dispatch_glGetSynciv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glGetSynciv);
    }
    
    private native void dispatch_glGetSynciv1(final long p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetSynciv(final long n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"values_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetSynciv = this._pat._addressof_glGetSynciv;
        if (addressof_glGetSynciv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
        }
        this.dispatch_glGetSynciv1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, addressof_glGetSynciv);
    }
    
    @Override
    public void glGetInteger64i_v(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetInteger64i_v = this._pat._addressof_glGetInteger64i_v;
        if (addressof_glGetInteger64i_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
        }
        this.dispatch_glGetInteger64i_v1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetInteger64i_v);
    }
    
    private native void dispatch_glGetInteger64i_v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetInteger64i_v(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetInteger64i_v = this._pat._addressof_glGetInteger64i_v;
        if (addressof_glGetInteger64i_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
        }
        this.dispatch_glGetInteger64i_v1(n, n2, array, 8 * n3, false, addressof_glGetInteger64i_v);
    }
    
    @Override
    public void glGetBufferParameteri64v(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetBufferParameteri64v = this._pat._addressof_glGetBufferParameteri64v;
        if (addressof_glGetBufferParameteri64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
        }
        this.dispatch_glGetBufferParameteri64v1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetBufferParameteri64v);
    }
    
    private native void dispatch_glGetBufferParameteri64v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetBufferParameteri64v(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetBufferParameteri64v = this._pat._addressof_glGetBufferParameteri64v;
        if (addressof_glGetBufferParameteri64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
        }
        this.dispatch_glGetBufferParameteri64v1(n, n2, array, 8 * n3, false, addressof_glGetBufferParameteri64v);
    }
    
    @Override
    public void glFramebufferTexture(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glFramebufferTexture = this._pat._addressof_glFramebufferTexture;
        if (addressof_glFramebufferTexture == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture"));
        }
        this.dispatch_glFramebufferTexture1(n, n2, n3, n4, addressof_glFramebufferTexture);
    }
    
    private native void dispatch_glFramebufferTexture1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glTexImage2DMultisample(final int n, final int n2, final int n3, final int n4, final int n5, final boolean b) {
        final long addressof_glTexImage2DMultisample = this._pat._addressof_glTexImage2DMultisample;
        if (addressof_glTexImage2DMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage2DMultisample"));
        }
        this.dispatch_glTexImage2DMultisample1(n, n2, n3, n4, n5, b, addressof_glTexImage2DMultisample);
    }
    
    private native void dispatch_glTexImage2DMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTexImage3DMultisample(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final boolean b) {
        final long addressof_glTexImage3DMultisample = this._pat._addressof_glTexImage3DMultisample;
        if (addressof_glTexImage3DMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage3DMultisample"));
        }
        this.dispatch_glTexImage3DMultisample1(n, n2, n3, n4, n5, n6, b, addressof_glTexImage3DMultisample);
    }
    
    private native void dispatch_glTexImage3DMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetMultisamplefv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMultisamplefv = this._pat._addressof_glGetMultisamplefv;
        if (addressof_glGetMultisamplefv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefv"));
        }
        this.dispatch_glGetMultisamplefv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMultisamplefv);
    }
    
    private native void dispatch_glGetMultisamplefv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMultisamplefv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"val_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultisamplefv = this._pat._addressof_glGetMultisamplefv;
        if (addressof_glGetMultisamplefv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefv"));
        }
        this.dispatch_glGetMultisamplefv1(n, n2, array, 4 * n3, false, addressof_glGetMultisamplefv);
    }
    
    @Override
    public void glSampleMaski(final int n, final int n2) {
        final long addressof_glSampleMaski = this._pat._addressof_glSampleMaski;
        if (addressof_glSampleMaski == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSampleMaski"));
        }
        this.dispatch_glSampleMaski1(n, n2, addressof_glSampleMaski);
    }
    
    private native void dispatch_glSampleMaski1(final int p0, final int p1, final long p2);
    
    @Override
    public void glBindFragDataLocationIndexed(final int n, final int n2, final int n3, final String s) {
        final long addressof_glBindFragDataLocationIndexed = this._pat._addressof_glBindFragDataLocationIndexed;
        if (addressof_glBindFragDataLocationIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocationIndexed"));
        }
        this.dispatch_glBindFragDataLocationIndexed1(n, n2, n3, s, addressof_glBindFragDataLocationIndexed);
    }
    
    private native void dispatch_glBindFragDataLocationIndexed1(final int p0, final int p1, final int p2, final String p3, final long p4);
    
    @Override
    public int glGetFragDataIndex(final int n, final String s) {
        final long addressof_glGetFragDataIndex = this._pat._addressof_glGetFragDataIndex;
        if (addressof_glGetFragDataIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataIndex"));
        }
        return this.dispatch_glGetFragDataIndex1(n, s, addressof_glGetFragDataIndex);
    }
    
    private native int dispatch_glGetFragDataIndex1(final int p0, final String p1, final long p2);
    
    @Override
    public void glGenSamplers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenSamplers = this._pat._addressof_glGenSamplers;
        if (addressof_glGenSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
        }
        this.dispatch_glGenSamplers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenSamplers);
    }
    
    private native void dispatch_glGenSamplers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenSamplers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"samplers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenSamplers = this._pat._addressof_glGenSamplers;
        if (addressof_glGenSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
        }
        this.dispatch_glGenSamplers1(n, array, 4 * n2, false, addressof_glGenSamplers);
    }
    
    @Override
    public void glDeleteSamplers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteSamplers = this._pat._addressof_glDeleteSamplers;
        if (addressof_glDeleteSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
        }
        this.dispatch_glDeleteSamplers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteSamplers);
    }
    
    private native void dispatch_glDeleteSamplers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteSamplers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"samplers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteSamplers = this._pat._addressof_glDeleteSamplers;
        if (addressof_glDeleteSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
        }
        this.dispatch_glDeleteSamplers1(n, array, 4 * n2, false, addressof_glDeleteSamplers);
    }
    
    @Override
    public boolean glIsSampler(final int n) {
        final long addressof_glIsSampler = this._pat._addressof_glIsSampler;
        if (addressof_glIsSampler == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsSampler"));
        }
        return this.dispatch_glIsSampler1(n, addressof_glIsSampler);
    }
    
    private native boolean dispatch_glIsSampler1(final int p0, final long p1);
    
    @Override
    public void glBindSampler(final int n, final int n2) {
        final long addressof_glBindSampler = this._pat._addressof_glBindSampler;
        if (addressof_glBindSampler == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindSampler"));
        }
        this.dispatch_glBindSampler1(n, n2, addressof_glBindSampler);
    }
    
    private native void dispatch_glBindSampler1(final int p0, final int p1, final long p2);
    
    @Override
    public void glSamplerParameteri(final int n, final int n2, final int n3) {
        final long addressof_glSamplerParameteri = this._pat._addressof_glSamplerParameteri;
        if (addressof_glSamplerParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteri"));
        }
        this.dispatch_glSamplerParameteri1(n, n2, n3, addressof_glSamplerParameteri);
    }
    
    private native void dispatch_glSamplerParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glSamplerParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glSamplerParameteriv = this._pat._addressof_glSamplerParameteriv;
        if (addressof_glSamplerParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
        }
        this.dispatch_glSamplerParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glSamplerParameteriv);
    }
    
    private native void dispatch_glSamplerParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glSamplerParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSamplerParameteriv = this._pat._addressof_glSamplerParameteriv;
        if (addressof_glSamplerParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
        }
        this.dispatch_glSamplerParameteriv1(n, n2, array, 4 * n3, false, addressof_glSamplerParameteriv);
    }
    
    @Override
    public void glSamplerParameterf(final int n, final int n2, final float n3) {
        final long addressof_glSamplerParameterf = this._pat._addressof_glSamplerParameterf;
        if (addressof_glSamplerParameterf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterf"));
        }
        this.dispatch_glSamplerParameterf1(n, n2, n3, addressof_glSamplerParameterf);
    }
    
    private native void dispatch_glSamplerParameterf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glSamplerParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glSamplerParameterfv = this._pat._addressof_glSamplerParameterfv;
        if (addressof_glSamplerParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
        }
        this.dispatch_glSamplerParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glSamplerParameterfv);
    }
    
    private native void dispatch_glSamplerParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glSamplerParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSamplerParameterfv = this._pat._addressof_glSamplerParameterfv;
        if (addressof_glSamplerParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
        }
        this.dispatch_glSamplerParameterfv1(n, n2, array, 4 * n3, false, addressof_glSamplerParameterfv);
    }
    
    @Override
    public void glSamplerParameterIiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glSamplerParameterIiv = this._pat._addressof_glSamplerParameterIiv;
        if (addressof_glSamplerParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIiv"));
        }
        this.dispatch_glSamplerParameterIiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glSamplerParameterIiv);
    }
    
    private native void dispatch_glSamplerParameterIiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glSamplerParameterIiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSamplerParameterIiv = this._pat._addressof_glSamplerParameterIiv;
        if (addressof_glSamplerParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIiv"));
        }
        this.dispatch_glSamplerParameterIiv1(n, n2, array, 4 * n3, false, addressof_glSamplerParameterIiv);
    }
    
    @Override
    public void glSamplerParameterIuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glSamplerParameterIuiv = this._pat._addressof_glSamplerParameterIuiv;
        if (addressof_glSamplerParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIuiv"));
        }
        this.dispatch_glSamplerParameterIuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glSamplerParameterIuiv);
    }
    
    private native void dispatch_glSamplerParameterIuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glSamplerParameterIuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSamplerParameterIuiv = this._pat._addressof_glSamplerParameterIuiv;
        if (addressof_glSamplerParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIuiv"));
        }
        this.dispatch_glSamplerParameterIuiv1(n, n2, array, 4 * n3, false, addressof_glSamplerParameterIuiv);
    }
    
    @Override
    public void glGetSamplerParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetSamplerParameteriv = this._pat._addressof_glGetSamplerParameteriv;
        if (addressof_glGetSamplerParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
        }
        this.dispatch_glGetSamplerParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetSamplerParameteriv);
    }
    
    private native void dispatch_glGetSamplerParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetSamplerParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetSamplerParameteriv = this._pat._addressof_glGetSamplerParameteriv;
        if (addressof_glGetSamplerParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
        }
        this.dispatch_glGetSamplerParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetSamplerParameteriv);
    }
    
    @Override
    public void glGetSamplerParameterIiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetSamplerParameterIiv = this._pat._addressof_glGetSamplerParameterIiv;
        if (addressof_glGetSamplerParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIiv"));
        }
        this.dispatch_glGetSamplerParameterIiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetSamplerParameterIiv);
    }
    
    private native void dispatch_glGetSamplerParameterIiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetSamplerParameterIiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetSamplerParameterIiv = this._pat._addressof_glGetSamplerParameterIiv;
        if (addressof_glGetSamplerParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIiv"));
        }
        this.dispatch_glGetSamplerParameterIiv1(n, n2, array, 4 * n3, false, addressof_glGetSamplerParameterIiv);
    }
    
    @Override
    public void glGetSamplerParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetSamplerParameterfv = this._pat._addressof_glGetSamplerParameterfv;
        if (addressof_glGetSamplerParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
        }
        this.dispatch_glGetSamplerParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetSamplerParameterfv);
    }
    
    private native void dispatch_glGetSamplerParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetSamplerParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetSamplerParameterfv = this._pat._addressof_glGetSamplerParameterfv;
        if (addressof_glGetSamplerParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
        }
        this.dispatch_glGetSamplerParameterfv1(n, n2, array, 4 * n3, false, addressof_glGetSamplerParameterfv);
    }
    
    @Override
    public void glGetSamplerParameterIuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetSamplerParameterIuiv = this._pat._addressof_glGetSamplerParameterIuiv;
        if (addressof_glGetSamplerParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIuiv"));
        }
        this.dispatch_glGetSamplerParameterIuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetSamplerParameterIuiv);
    }
    
    private native void dispatch_glGetSamplerParameterIuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetSamplerParameterIuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetSamplerParameterIuiv = this._pat._addressof_glGetSamplerParameterIuiv;
        if (addressof_glGetSamplerParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIuiv"));
        }
        this.dispatch_glGetSamplerParameterIuiv1(n, n2, array, 4 * n3, false, addressof_glGetSamplerParameterIuiv);
    }
    
    @Override
    public void glQueryCounter(final int n, final int n2) {
        final long addressof_glQueryCounter = this._pat._addressof_glQueryCounter;
        if (addressof_glQueryCounter == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glQueryCounter"));
        }
        this.dispatch_glQueryCounter1(n, n2, addressof_glQueryCounter);
    }
    
    private native void dispatch_glQueryCounter1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetQueryObjecti64v(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetQueryObjecti64v = this._pat._addressof_glGetQueryObjecti64v;
        if (addressof_glGetQueryObjecti64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64v"));
        }
        this.dispatch_glGetQueryObjecti64v1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetQueryObjecti64v);
    }
    
    private native void dispatch_glGetQueryObjecti64v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetQueryObjecti64v(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryObjecti64v = this._pat._addressof_glGetQueryObjecti64v;
        if (addressof_glGetQueryObjecti64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64v"));
        }
        this.dispatch_glGetQueryObjecti64v1(n, n2, array, 8 * n3, false, addressof_glGetQueryObjecti64v);
    }
    
    @Override
    public void glGetQueryObjectui64v(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetQueryObjectui64v = this._pat._addressof_glGetQueryObjectui64v;
        if (addressof_glGetQueryObjectui64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64v"));
        }
        this.dispatch_glGetQueryObjectui64v1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetQueryObjectui64v);
    }
    
    private native void dispatch_glGetQueryObjectui64v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetQueryObjectui64v(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryObjectui64v = this._pat._addressof_glGetQueryObjectui64v;
        if (addressof_glGetQueryObjectui64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64v"));
        }
        this.dispatch_glGetQueryObjectui64v1(n, n2, array, 8 * n3, false, addressof_glGetQueryObjectui64v);
    }
    
    @Override
    public void glVertexAttribDivisor(final int n, final int n2) {
        final long addressof_glVertexAttribDivisor = this._pat._addressof_glVertexAttribDivisor;
        if (addressof_glVertexAttribDivisor == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisor"));
        }
        this.dispatch_glVertexAttribDivisor1(n, n2, addressof_glVertexAttribDivisor);
    }
    
    private native void dispatch_glVertexAttribDivisor1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexAttribP1ui(final int n, final int n2, final boolean b, final int n3) {
        final long addressof_glVertexAttribP1ui = this._pat._addressof_glVertexAttribP1ui;
        if (addressof_glVertexAttribP1ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP1ui"));
        }
        this.dispatch_glVertexAttribP1ui1(n, n2, b, n3, addressof_glVertexAttribP1ui);
    }
    
    private native void dispatch_glVertexAttribP1ui1(final int p0, final int p1, final boolean p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribP1uiv(final int n, final int n2, final boolean b, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribP1uiv = this._pat._addressof_glVertexAttribP1uiv;
        if (addressof_glVertexAttribP1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP1uiv"));
        }
        this.dispatch_glVertexAttribP1uiv1(n, n2, b, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribP1uiv);
    }
    
    private native void dispatch_glVertexAttribP1uiv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVertexAttribP1uiv(final int n, final int n2, final boolean b, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribP1uiv = this._pat._addressof_glVertexAttribP1uiv;
        if (addressof_glVertexAttribP1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP1uiv"));
        }
        this.dispatch_glVertexAttribP1uiv1(n, n2, b, array, 4 * n3, false, addressof_glVertexAttribP1uiv);
    }
    
    @Override
    public void glVertexAttribP2ui(final int n, final int n2, final boolean b, final int n3) {
        final long addressof_glVertexAttribP2ui = this._pat._addressof_glVertexAttribP2ui;
        if (addressof_glVertexAttribP2ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP2ui"));
        }
        this.dispatch_glVertexAttribP2ui1(n, n2, b, n3, addressof_glVertexAttribP2ui);
    }
    
    private native void dispatch_glVertexAttribP2ui1(final int p0, final int p1, final boolean p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribP2uiv(final int n, final int n2, final boolean b, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribP2uiv = this._pat._addressof_glVertexAttribP2uiv;
        if (addressof_glVertexAttribP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP2uiv"));
        }
        this.dispatch_glVertexAttribP2uiv1(n, n2, b, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribP2uiv);
    }
    
    private native void dispatch_glVertexAttribP2uiv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVertexAttribP2uiv(final int n, final int n2, final boolean b, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribP2uiv = this._pat._addressof_glVertexAttribP2uiv;
        if (addressof_glVertexAttribP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP2uiv"));
        }
        this.dispatch_glVertexAttribP2uiv1(n, n2, b, array, 4 * n3, false, addressof_glVertexAttribP2uiv);
    }
    
    @Override
    public void glVertexAttribP3ui(final int n, final int n2, final boolean b, final int n3) {
        final long addressof_glVertexAttribP3ui = this._pat._addressof_glVertexAttribP3ui;
        if (addressof_glVertexAttribP3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP3ui"));
        }
        this.dispatch_glVertexAttribP3ui1(n, n2, b, n3, addressof_glVertexAttribP3ui);
    }
    
    private native void dispatch_glVertexAttribP3ui1(final int p0, final int p1, final boolean p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribP3uiv(final int n, final int n2, final boolean b, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribP3uiv = this._pat._addressof_glVertexAttribP3uiv;
        if (addressof_glVertexAttribP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP3uiv"));
        }
        this.dispatch_glVertexAttribP3uiv1(n, n2, b, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribP3uiv);
    }
    
    private native void dispatch_glVertexAttribP3uiv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVertexAttribP3uiv(final int n, final int n2, final boolean b, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribP3uiv = this._pat._addressof_glVertexAttribP3uiv;
        if (addressof_glVertexAttribP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP3uiv"));
        }
        this.dispatch_glVertexAttribP3uiv1(n, n2, b, array, 4 * n3, false, addressof_glVertexAttribP3uiv);
    }
    
    @Override
    public void glVertexAttribP4ui(final int n, final int n2, final boolean b, final int n3) {
        final long addressof_glVertexAttribP4ui = this._pat._addressof_glVertexAttribP4ui;
        if (addressof_glVertexAttribP4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP4ui"));
        }
        this.dispatch_glVertexAttribP4ui1(n, n2, b, n3, addressof_glVertexAttribP4ui);
    }
    
    private native void dispatch_glVertexAttribP4ui1(final int p0, final int p1, final boolean p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribP4uiv(final int n, final int n2, final boolean b, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribP4uiv = this._pat._addressof_glVertexAttribP4uiv;
        if (addressof_glVertexAttribP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP4uiv"));
        }
        this.dispatch_glVertexAttribP4uiv1(n, n2, b, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribP4uiv);
    }
    
    private native void dispatch_glVertexAttribP4uiv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVertexAttribP4uiv(final int n, final int n2, final boolean b, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribP4uiv = this._pat._addressof_glVertexAttribP4uiv;
        if (addressof_glVertexAttribP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP4uiv"));
        }
        this.dispatch_glVertexAttribP4uiv1(n, n2, b, array, 4 * n3, false, addressof_glVertexAttribP4uiv);
    }
    
    @Override
    public void glVertexP2ui(final int n, final int n2) {
        final long addressof_glVertexP2ui = this._pat._addressof_glVertexP2ui;
        if (addressof_glVertexP2ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP2ui"));
        }
        this.dispatch_glVertexP2ui1(n, n2, addressof_glVertexP2ui);
    }
    
    private native void dispatch_glVertexP2ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexP2uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexP2uiv = this._pat._addressof_glVertexP2uiv;
        if (addressof_glVertexP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP2uiv"));
        }
        this.dispatch_glVertexP2uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexP2uiv);
    }
    
    private native void dispatch_glVertexP2uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexP2uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"value_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexP2uiv = this._pat._addressof_glVertexP2uiv;
        if (addressof_glVertexP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP2uiv"));
        }
        this.dispatch_glVertexP2uiv1(n, array, 4 * n2, false, addressof_glVertexP2uiv);
    }
    
    @Override
    public void glVertexP3ui(final int n, final int n2) {
        final long addressof_glVertexP3ui = this._pat._addressof_glVertexP3ui;
        if (addressof_glVertexP3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP3ui"));
        }
        this.dispatch_glVertexP3ui1(n, n2, addressof_glVertexP3ui);
    }
    
    private native void dispatch_glVertexP3ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexP3uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexP3uiv = this._pat._addressof_glVertexP3uiv;
        if (addressof_glVertexP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP3uiv"));
        }
        this.dispatch_glVertexP3uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexP3uiv);
    }
    
    private native void dispatch_glVertexP3uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexP3uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"value_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexP3uiv = this._pat._addressof_glVertexP3uiv;
        if (addressof_glVertexP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP3uiv"));
        }
        this.dispatch_glVertexP3uiv1(n, array, 4 * n2, false, addressof_glVertexP3uiv);
    }
    
    @Override
    public void glVertexP4ui(final int n, final int n2) {
        final long addressof_glVertexP4ui = this._pat._addressof_glVertexP4ui;
        if (addressof_glVertexP4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP4ui"));
        }
        this.dispatch_glVertexP4ui1(n, n2, addressof_glVertexP4ui);
    }
    
    private native void dispatch_glVertexP4ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexP4uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexP4uiv = this._pat._addressof_glVertexP4uiv;
        if (addressof_glVertexP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP4uiv"));
        }
        this.dispatch_glVertexP4uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexP4uiv);
    }
    
    private native void dispatch_glVertexP4uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexP4uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"value_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexP4uiv = this._pat._addressof_glVertexP4uiv;
        if (addressof_glVertexP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexP4uiv"));
        }
        this.dispatch_glVertexP4uiv1(n, array, 4 * n2, false, addressof_glVertexP4uiv);
    }
    
    @Override
    public void glTexCoordP1ui(final int n, final int n2) {
        final long addressof_glTexCoordP1ui = this._pat._addressof_glTexCoordP1ui;
        if (addressof_glTexCoordP1ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP1ui"));
        }
        this.dispatch_glTexCoordP1ui1(n, n2, addressof_glTexCoordP1ui);
    }
    
    private native void dispatch_glTexCoordP1ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTexCoordP1uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoordP1uiv = this._pat._addressof_glTexCoordP1uiv;
        if (addressof_glTexCoordP1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP1uiv"));
        }
        this.dispatch_glTexCoordP1uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoordP1uiv);
    }
    
    private native void dispatch_glTexCoordP1uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glTexCoordP1uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoordP1uiv = this._pat._addressof_glTexCoordP1uiv;
        if (addressof_glTexCoordP1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP1uiv"));
        }
        this.dispatch_glTexCoordP1uiv1(n, array, 4 * n2, false, addressof_glTexCoordP1uiv);
    }
    
    @Override
    public void glTexCoordP2ui(final int n, final int n2) {
        final long addressof_glTexCoordP2ui = this._pat._addressof_glTexCoordP2ui;
        if (addressof_glTexCoordP2ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP2ui"));
        }
        this.dispatch_glTexCoordP2ui1(n, n2, addressof_glTexCoordP2ui);
    }
    
    private native void dispatch_glTexCoordP2ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTexCoordP2uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoordP2uiv = this._pat._addressof_glTexCoordP2uiv;
        if (addressof_glTexCoordP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP2uiv"));
        }
        this.dispatch_glTexCoordP2uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoordP2uiv);
    }
    
    private native void dispatch_glTexCoordP2uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glTexCoordP2uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoordP2uiv = this._pat._addressof_glTexCoordP2uiv;
        if (addressof_glTexCoordP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP2uiv"));
        }
        this.dispatch_glTexCoordP2uiv1(n, array, 4 * n2, false, addressof_glTexCoordP2uiv);
    }
    
    @Override
    public void glTexCoordP3ui(final int n, final int n2) {
        final long addressof_glTexCoordP3ui = this._pat._addressof_glTexCoordP3ui;
        if (addressof_glTexCoordP3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP3ui"));
        }
        this.dispatch_glTexCoordP3ui1(n, n2, addressof_glTexCoordP3ui);
    }
    
    private native void dispatch_glTexCoordP3ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTexCoordP3uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoordP3uiv = this._pat._addressof_glTexCoordP3uiv;
        if (addressof_glTexCoordP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP3uiv"));
        }
        this.dispatch_glTexCoordP3uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoordP3uiv);
    }
    
    private native void dispatch_glTexCoordP3uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glTexCoordP3uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoordP3uiv = this._pat._addressof_glTexCoordP3uiv;
        if (addressof_glTexCoordP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP3uiv"));
        }
        this.dispatch_glTexCoordP3uiv1(n, array, 4 * n2, false, addressof_glTexCoordP3uiv);
    }
    
    @Override
    public void glTexCoordP4ui(final int n, final int n2) {
        final long addressof_glTexCoordP4ui = this._pat._addressof_glTexCoordP4ui;
        if (addressof_glTexCoordP4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP4ui"));
        }
        this.dispatch_glTexCoordP4ui1(n, n2, addressof_glTexCoordP4ui);
    }
    
    private native void dispatch_glTexCoordP4ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTexCoordP4uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTexCoordP4uiv = this._pat._addressof_glTexCoordP4uiv;
        if (addressof_glTexCoordP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP4uiv"));
        }
        this.dispatch_glTexCoordP4uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTexCoordP4uiv);
    }
    
    private native void dispatch_glTexCoordP4uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glTexCoordP4uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoordP4uiv = this._pat._addressof_glTexCoordP4uiv;
        if (addressof_glTexCoordP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP4uiv"));
        }
        this.dispatch_glTexCoordP4uiv1(n, array, 4 * n2, false, addressof_glTexCoordP4uiv);
    }
    
    @Override
    public void glMultiTexCoordP1ui(final int n, final int n2, final int n3) {
        final long addressof_glMultiTexCoordP1ui = this._pat._addressof_glMultiTexCoordP1ui;
        if (addressof_glMultiTexCoordP1ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP1ui"));
        }
        this.dispatch_glMultiTexCoordP1ui1(n, n2, n3, addressof_glMultiTexCoordP1ui);
    }
    
    private native void dispatch_glMultiTexCoordP1ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiTexCoordP1uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoordP1uiv = this._pat._addressof_glMultiTexCoordP1uiv;
        if (addressof_glMultiTexCoordP1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP1uiv"));
        }
        this.dispatch_glMultiTexCoordP1uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoordP1uiv);
    }
    
    private native void dispatch_glMultiTexCoordP1uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMultiTexCoordP1uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"coords_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoordP1uiv = this._pat._addressof_glMultiTexCoordP1uiv;
        if (addressof_glMultiTexCoordP1uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP1uiv"));
        }
        this.dispatch_glMultiTexCoordP1uiv1(n, n2, array, 4 * n3, false, addressof_glMultiTexCoordP1uiv);
    }
    
    @Override
    public void glMultiTexCoordP2ui(final int n, final int n2, final int n3) {
        final long addressof_glMultiTexCoordP2ui = this._pat._addressof_glMultiTexCoordP2ui;
        if (addressof_glMultiTexCoordP2ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP2ui"));
        }
        this.dispatch_glMultiTexCoordP2ui1(n, n2, n3, addressof_glMultiTexCoordP2ui);
    }
    
    private native void dispatch_glMultiTexCoordP2ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiTexCoordP2uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoordP2uiv = this._pat._addressof_glMultiTexCoordP2uiv;
        if (addressof_glMultiTexCoordP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP2uiv"));
        }
        this.dispatch_glMultiTexCoordP2uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoordP2uiv);
    }
    
    private native void dispatch_glMultiTexCoordP2uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMultiTexCoordP2uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"coords_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoordP2uiv = this._pat._addressof_glMultiTexCoordP2uiv;
        if (addressof_glMultiTexCoordP2uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP2uiv"));
        }
        this.dispatch_glMultiTexCoordP2uiv1(n, n2, array, 4 * n3, false, addressof_glMultiTexCoordP2uiv);
    }
    
    @Override
    public void glMultiTexCoordP3ui(final int n, final int n2, final int n3) {
        final long addressof_glMultiTexCoordP3ui = this._pat._addressof_glMultiTexCoordP3ui;
        if (addressof_glMultiTexCoordP3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP3ui"));
        }
        this.dispatch_glMultiTexCoordP3ui1(n, n2, n3, addressof_glMultiTexCoordP3ui);
    }
    
    private native void dispatch_glMultiTexCoordP3ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiTexCoordP3uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoordP3uiv = this._pat._addressof_glMultiTexCoordP3uiv;
        if (addressof_glMultiTexCoordP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP3uiv"));
        }
        this.dispatch_glMultiTexCoordP3uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoordP3uiv);
    }
    
    private native void dispatch_glMultiTexCoordP3uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMultiTexCoordP3uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"coords_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoordP3uiv = this._pat._addressof_glMultiTexCoordP3uiv;
        if (addressof_glMultiTexCoordP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP3uiv"));
        }
        this.dispatch_glMultiTexCoordP3uiv1(n, n2, array, 4 * n3, false, addressof_glMultiTexCoordP3uiv);
    }
    
    @Override
    public void glMultiTexCoordP4ui(final int n, final int n2, final int n3) {
        final long addressof_glMultiTexCoordP4ui = this._pat._addressof_glMultiTexCoordP4ui;
        if (addressof_glMultiTexCoordP4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP4ui"));
        }
        this.dispatch_glMultiTexCoordP4ui1(n, n2, n3, addressof_glMultiTexCoordP4ui);
    }
    
    private native void dispatch_glMultiTexCoordP4ui1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiTexCoordP4uiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexCoordP4uiv = this._pat._addressof_glMultiTexCoordP4uiv;
        if (addressof_glMultiTexCoordP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP4uiv"));
        }
        this.dispatch_glMultiTexCoordP4uiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexCoordP4uiv);
    }
    
    private native void dispatch_glMultiTexCoordP4uiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMultiTexCoordP4uiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"coords_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoordP4uiv = this._pat._addressof_glMultiTexCoordP4uiv;
        if (addressof_glMultiTexCoordP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP4uiv"));
        }
        this.dispatch_glMultiTexCoordP4uiv1(n, n2, array, 4 * n3, false, addressof_glMultiTexCoordP4uiv);
    }
    
    @Override
    public void glNormalP3ui(final int n, final int n2) {
        final long addressof_glNormalP3ui = this._pat._addressof_glNormalP3ui;
        if (addressof_glNormalP3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormalP3ui"));
        }
        this.dispatch_glNormalP3ui1(n, n2, addressof_glNormalP3ui);
    }
    
    private native void dispatch_glNormalP3ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glNormalP3uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glNormalP3uiv = this._pat._addressof_glNormalP3uiv;
        if (addressof_glNormalP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormalP3uiv"));
        }
        this.dispatch_glNormalP3uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glNormalP3uiv);
    }
    
    private native void dispatch_glNormalP3uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glNormalP3uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNormalP3uiv = this._pat._addressof_glNormalP3uiv;
        if (addressof_glNormalP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormalP3uiv"));
        }
        this.dispatch_glNormalP3uiv1(n, array, 4 * n2, false, addressof_glNormalP3uiv);
    }
    
    @Override
    public void glColorP3ui(final int n, final int n2) {
        final long addressof_glColorP3ui = this._pat._addressof_glColorP3ui;
        if (addressof_glColorP3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorP3ui"));
        }
        this.dispatch_glColorP3ui1(n, n2, addressof_glColorP3ui);
    }
    
    private native void dispatch_glColorP3ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glColorP3uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glColorP3uiv = this._pat._addressof_glColorP3uiv;
        if (addressof_glColorP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorP3uiv"));
        }
        this.dispatch_glColorP3uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glColorP3uiv);
    }
    
    private native void dispatch_glColorP3uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glColorP3uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"color_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColorP3uiv = this._pat._addressof_glColorP3uiv;
        if (addressof_glColorP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorP3uiv"));
        }
        this.dispatch_glColorP3uiv1(n, array, 4 * n2, false, addressof_glColorP3uiv);
    }
    
    @Override
    public void glColorP4ui(final int n, final int n2) {
        final long addressof_glColorP4ui = this._pat._addressof_glColorP4ui;
        if (addressof_glColorP4ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorP4ui"));
        }
        this.dispatch_glColorP4ui1(n, n2, addressof_glColorP4ui);
    }
    
    private native void dispatch_glColorP4ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glColorP4uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glColorP4uiv = this._pat._addressof_glColorP4uiv;
        if (addressof_glColorP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorP4uiv"));
        }
        this.dispatch_glColorP4uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glColorP4uiv);
    }
    
    private native void dispatch_glColorP4uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glColorP4uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"color_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColorP4uiv = this._pat._addressof_glColorP4uiv;
        if (addressof_glColorP4uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorP4uiv"));
        }
        this.dispatch_glColorP4uiv1(n, array, 4 * n2, false, addressof_glColorP4uiv);
    }
    
    @Override
    public void glSecondaryColorP3ui(final int n, final int n2) {
        final long addressof_glSecondaryColorP3ui = this._pat._addressof_glSecondaryColorP3ui;
        if (addressof_glSecondaryColorP3ui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorP3ui"));
        }
        this.dispatch_glSecondaryColorP3ui1(n, n2, addressof_glSecondaryColorP3ui);
    }
    
    private native void dispatch_glSecondaryColorP3ui1(final int p0, final int p1, final long p2);
    
    @Override
    public void glSecondaryColorP3uiv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glSecondaryColorP3uiv = this._pat._addressof_glSecondaryColorP3uiv;
        if (addressof_glSecondaryColorP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorP3uiv"));
        }
        this.dispatch_glSecondaryColorP3uiv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glSecondaryColorP3uiv);
    }
    
    private native void dispatch_glSecondaryColorP3uiv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glSecondaryColorP3uiv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"color_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColorP3uiv = this._pat._addressof_glSecondaryColorP3uiv;
        if (addressof_glSecondaryColorP3uiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorP3uiv"));
        }
        this.dispatch_glSecondaryColorP3uiv1(n, array, 4 * n2, false, addressof_glSecondaryColorP3uiv);
    }
    
    @Override
    public void glMinSampleShading(final float n) {
        final long addressof_glMinSampleShading = this._pat._addressof_glMinSampleShading;
        if (addressof_glMinSampleShading == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMinSampleShading"));
        }
        this.dispatch_glMinSampleShading1(n, addressof_glMinSampleShading);
    }
    
    private native void dispatch_glMinSampleShading1(final float p0, final long p1);
    
    @Override
    public void glBlendEquationi(final int n, final int n2) {
        final long addressof_glBlendEquationi = this._pat._addressof_glBlendEquationi;
        if (addressof_glBlendEquationi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationi"));
        }
        this.dispatch_glBlendEquationi1(n, n2, addressof_glBlendEquationi);
    }
    
    private native void dispatch_glBlendEquationi1(final int p0, final int p1, final long p2);
    
    @Override
    public void glBlendEquationSeparatei(final int n, final int n2, final int n3) {
        final long addressof_glBlendEquationSeparatei = this._pat._addressof_glBlendEquationSeparatei;
        if (addressof_glBlendEquationSeparatei == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparatei"));
        }
        this.dispatch_glBlendEquationSeparatei1(n, n2, n3, addressof_glBlendEquationSeparatei);
    }
    
    private native void dispatch_glBlendEquationSeparatei1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glBlendFunci(final int n, final int n2, final int n3) {
        final long addressof_glBlendFunci = this._pat._addressof_glBlendFunci;
        if (addressof_glBlendFunci == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendFunci"));
        }
        this.dispatch_glBlendFunci1(n, n2, n3, addressof_glBlendFunci);
    }
    
    private native void dispatch_glBlendFunci1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glBlendFuncSeparatei(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glBlendFuncSeparatei = this._pat._addressof_glBlendFuncSeparatei;
        if (addressof_glBlendFuncSeparatei == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparatei"));
        }
        this.dispatch_glBlendFuncSeparatei1(n, n2, n3, n4, n5, addressof_glBlendFuncSeparatei);
    }
    
    private native void dispatch_glBlendFuncSeparatei1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glDrawArraysIndirect(final int n, final Buffer buffer) {
        this.checkIndirectVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawArraysIndirect = this._pat._addressof_glDrawArraysIndirect;
        if (addressof_glDrawArraysIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysIndirect"));
        }
        this.dispatch_glDrawArraysIndirect1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glDrawArraysIndirect);
    }
    
    private native void dispatch_glDrawArraysIndirect1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDrawArraysIndirect(final int n, final long n2) {
        this.checkIndirectVBOBound(true);
        final long addressof_glDrawArraysIndirect = this._pat._addressof_glDrawArraysIndirect;
        if (addressof_glDrawArraysIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysIndirect"));
        }
        this.dispatch_glDrawArraysIndirect1(n, n2, addressof_glDrawArraysIndirect);
    }
    
    private native void dispatch_glDrawArraysIndirect1(final int p0, final long p1, final long p2);
    
    @Override
    public void glDrawElementsIndirect(final int n, final int n2, final Buffer buffer) {
        this.checkIndirectVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawElementsIndirect = this._pat._addressof_glDrawElementsIndirect;
        if (addressof_glDrawElementsIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsIndirect"));
        }
        this.dispatch_glDrawElementsIndirect1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glDrawElementsIndirect);
    }
    
    private native void dispatch_glDrawElementsIndirect1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glDrawElementsIndirect(final int n, final int n2, final long n3) {
        this.checkIndirectVBOBound(true);
        final long addressof_glDrawElementsIndirect = this._pat._addressof_glDrawElementsIndirect;
        if (addressof_glDrawElementsIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsIndirect"));
        }
        this.dispatch_glDrawElementsIndirect1(n, n2, n3, addressof_glDrawElementsIndirect);
    }
    
    private native void dispatch_glDrawElementsIndirect1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glUniform1d(final int n, final double n2) {
        final long addressof_glUniform1d = this._pat._addressof_glUniform1d;
        if (addressof_glUniform1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1d"));
        }
        this.dispatch_glUniform1d1(n, n2, addressof_glUniform1d);
    }
    
    private native void dispatch_glUniform1d1(final int p0, final double p1, final long p2);
    
    @Override
    public void glUniform2d(final int n, final double n2, final double n3) {
        final long addressof_glUniform2d = this._pat._addressof_glUniform2d;
        if (addressof_glUniform2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2d"));
        }
        this.dispatch_glUniform2d1(n, n2, n3, addressof_glUniform2d);
    }
    
    private native void dispatch_glUniform2d1(final int p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glUniform3d(final int n, final double n2, final double n3, final double n4) {
        final long addressof_glUniform3d = this._pat._addressof_glUniform3d;
        if (addressof_glUniform3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3d"));
        }
        this.dispatch_glUniform3d1(n, n2, n3, n4, addressof_glUniform3d);
    }
    
    private native void dispatch_glUniform3d1(final int p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glUniform4d(final int n, final double n2, final double n3, final double n4, final double n5) {
        final long addressof_glUniform4d = this._pat._addressof_glUniform4d;
        if (addressof_glUniform4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4d"));
        }
        this.dispatch_glUniform4d1(n, n2, n3, n4, n5, addressof_glUniform4d);
    }
    
    private native void dispatch_glUniform4d1(final int p0, final double p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glUniform1dv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniform1dv = this._pat._addressof_glUniform1dv;
        if (addressof_glUniform1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1dv"));
        }
        this.dispatch_glUniform1dv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniform1dv);
    }
    
    private native void dispatch_glUniform1dv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1dv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1dv = this._pat._addressof_glUniform1dv;
        if (addressof_glUniform1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1dv"));
        }
        this.dispatch_glUniform1dv1(n, n2, array, 8 * n3, false, addressof_glUniform1dv);
    }
    
    @Override
    public void glUniform2dv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniform2dv = this._pat._addressof_glUniform2dv;
        if (addressof_glUniform2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2dv"));
        }
        this.dispatch_glUniform2dv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniform2dv);
    }
    
    private native void dispatch_glUniform2dv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2dv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2dv = this._pat._addressof_glUniform2dv;
        if (addressof_glUniform2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2dv"));
        }
        this.dispatch_glUniform2dv1(n, n2, array, 8 * n3, false, addressof_glUniform2dv);
    }
    
    @Override
    public void glUniform3dv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniform3dv = this._pat._addressof_glUniform3dv;
        if (addressof_glUniform3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3dv"));
        }
        this.dispatch_glUniform3dv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniform3dv);
    }
    
    private native void dispatch_glUniform3dv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3dv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3dv = this._pat._addressof_glUniform3dv;
        if (addressof_glUniform3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3dv"));
        }
        this.dispatch_glUniform3dv1(n, n2, array, 8 * n3, false, addressof_glUniform3dv);
    }
    
    @Override
    public void glUniform4dv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniform4dv = this._pat._addressof_glUniform4dv;
        if (addressof_glUniform4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4dv"));
        }
        this.dispatch_glUniform4dv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniform4dv);
    }
    
    private native void dispatch_glUniform4dv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4dv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4dv = this._pat._addressof_glUniform4dv;
        if (addressof_glUniform4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4dv"));
        }
        this.dispatch_glUniform4dv1(n, n2, array, 8 * n3, false, addressof_glUniform4dv);
    }
    
    @Override
    public void glUniformMatrix2dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix2dv = this._pat._addressof_glUniformMatrix2dv;
        if (addressof_glUniformMatrix2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2dv"));
        }
        this.dispatch_glUniformMatrix2dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix2dv);
    }
    
    private native void dispatch_glUniformMatrix2dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix2dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix2dv = this._pat._addressof_glUniformMatrix2dv;
        if (addressof_glUniformMatrix2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2dv"));
        }
        this.dispatch_glUniformMatrix2dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix2dv);
    }
    
    @Override
    public void glUniformMatrix3dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix3dv = this._pat._addressof_glUniformMatrix3dv;
        if (addressof_glUniformMatrix3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3dv"));
        }
        this.dispatch_glUniformMatrix3dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix3dv);
    }
    
    private native void dispatch_glUniformMatrix3dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix3dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix3dv = this._pat._addressof_glUniformMatrix3dv;
        if (addressof_glUniformMatrix3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3dv"));
        }
        this.dispatch_glUniformMatrix3dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix3dv);
    }
    
    @Override
    public void glUniformMatrix4dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix4dv = this._pat._addressof_glUniformMatrix4dv;
        if (addressof_glUniformMatrix4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4dv"));
        }
        this.dispatch_glUniformMatrix4dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix4dv);
    }
    
    private native void dispatch_glUniformMatrix4dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix4dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix4dv = this._pat._addressof_glUniformMatrix4dv;
        if (addressof_glUniformMatrix4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4dv"));
        }
        this.dispatch_glUniformMatrix4dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix4dv);
    }
    
    @Override
    public void glUniformMatrix2x3dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix2x3dv = this._pat._addressof_glUniformMatrix2x3dv;
        if (addressof_glUniformMatrix2x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3dv"));
        }
        this.dispatch_glUniformMatrix2x3dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix2x3dv);
    }
    
    private native void dispatch_glUniformMatrix2x3dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix2x3dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix2x3dv = this._pat._addressof_glUniformMatrix2x3dv;
        if (addressof_glUniformMatrix2x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3dv"));
        }
        this.dispatch_glUniformMatrix2x3dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix2x3dv);
    }
    
    @Override
    public void glUniformMatrix2x4dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix2x4dv = this._pat._addressof_glUniformMatrix2x4dv;
        if (addressof_glUniformMatrix2x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4dv"));
        }
        this.dispatch_glUniformMatrix2x4dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix2x4dv);
    }
    
    private native void dispatch_glUniformMatrix2x4dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix2x4dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix2x4dv = this._pat._addressof_glUniformMatrix2x4dv;
        if (addressof_glUniformMatrix2x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4dv"));
        }
        this.dispatch_glUniformMatrix2x4dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix2x4dv);
    }
    
    @Override
    public void glUniformMatrix3x2dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix3x2dv = this._pat._addressof_glUniformMatrix3x2dv;
        if (addressof_glUniformMatrix3x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2dv"));
        }
        this.dispatch_glUniformMatrix3x2dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix3x2dv);
    }
    
    private native void dispatch_glUniformMatrix3x2dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix3x2dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix3x2dv = this._pat._addressof_glUniformMatrix3x2dv;
        if (addressof_glUniformMatrix3x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2dv"));
        }
        this.dispatch_glUniformMatrix3x2dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix3x2dv);
    }
    
    @Override
    public void glUniformMatrix3x4dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix3x4dv = this._pat._addressof_glUniformMatrix3x4dv;
        if (addressof_glUniformMatrix3x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4dv"));
        }
        this.dispatch_glUniformMatrix3x4dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix3x4dv);
    }
    
    private native void dispatch_glUniformMatrix3x4dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix3x4dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix3x4dv = this._pat._addressof_glUniformMatrix3x4dv;
        if (addressof_glUniformMatrix3x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4dv"));
        }
        this.dispatch_glUniformMatrix3x4dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix3x4dv);
    }
    
    @Override
    public void glUniformMatrix4x2dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix4x2dv = this._pat._addressof_glUniformMatrix4x2dv;
        if (addressof_glUniformMatrix4x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2dv"));
        }
        this.dispatch_glUniformMatrix4x2dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix4x2dv);
    }
    
    private native void dispatch_glUniformMatrix4x2dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix4x2dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix4x2dv = this._pat._addressof_glUniformMatrix4x2dv;
        if (addressof_glUniformMatrix4x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2dv"));
        }
        this.dispatch_glUniformMatrix4x2dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix4x2dv);
    }
    
    @Override
    public void glUniformMatrix4x3dv(final int n, final int n2, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glUniformMatrix4x3dv = this._pat._addressof_glUniformMatrix4x3dv;
        if (addressof_glUniformMatrix4x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3dv"));
        }
        this.dispatch_glUniformMatrix4x3dv1(n, n2, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glUniformMatrix4x3dv);
    }
    
    private native void dispatch_glUniformMatrix4x3dv1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix4x3dv(final int n, final int n2, final boolean b, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix4x3dv = this._pat._addressof_glUniformMatrix4x3dv;
        if (addressof_glUniformMatrix4x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3dv"));
        }
        this.dispatch_glUniformMatrix4x3dv1(n, n2, b, array, 8 * n3, false, addressof_glUniformMatrix4x3dv);
    }
    
    @Override
    public void glGetUniformdv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetUniformdv = this._pat._addressof_glGetUniformdv;
        if (addressof_glGetUniformdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformdv"));
        }
        this.dispatch_glGetUniformdv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetUniformdv);
    }
    
    private native void dispatch_glGetUniformdv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformdv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformdv = this._pat._addressof_glGetUniformdv;
        if (addressof_glGetUniformdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformdv"));
        }
        this.dispatch_glGetUniformdv1(n, n2, array, 8 * n3, false, addressof_glGetUniformdv);
    }
    
    @Override
    public int glGetSubroutineUniformLocation(final int n, final int n2, final String s) {
        final long addressof_glGetSubroutineUniformLocation = this._pat._addressof_glGetSubroutineUniformLocation;
        if (addressof_glGetSubroutineUniformLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSubroutineUniformLocation"));
        }
        return this.dispatch_glGetSubroutineUniformLocation1(n, n2, s, addressof_glGetSubroutineUniformLocation);
    }
    
    private native int dispatch_glGetSubroutineUniformLocation1(final int p0, final int p1, final String p2, final long p3);
    
    @Override
    public int glGetSubroutineIndex(final int n, final int n2, final String s) {
        final long addressof_glGetSubroutineIndex = this._pat._addressof_glGetSubroutineIndex;
        if (addressof_glGetSubroutineIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSubroutineIndex"));
        }
        return this.dispatch_glGetSubroutineIndex1(n, n2, s, addressof_glGetSubroutineIndex);
    }
    
    private native int dispatch_glGetSubroutineIndex1(final int p0, final int p1, final String p2, final long p3);
    
    @Override
    public void glGetActiveSubroutineUniformiv(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetActiveSubroutineUniformiv = this._pat._addressof_glGetActiveSubroutineUniformiv;
        if (addressof_glGetActiveSubroutineUniformiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformiv"));
        }
        this.dispatch_glGetActiveSubroutineUniformiv1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetActiveSubroutineUniformiv);
    }
    
    private native void dispatch_glGetActiveSubroutineUniformiv1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetActiveSubroutineUniformiv(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"values_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetActiveSubroutineUniformiv = this._pat._addressof_glGetActiveSubroutineUniformiv;
        if (addressof_glGetActiveSubroutineUniformiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformiv"));
        }
        this.dispatch_glGetActiveSubroutineUniformiv1(n, n2, n3, n4, array, 4 * n5, false, addressof_glGetActiveSubroutineUniformiv);
    }
    
    @Override
    public void glGetActiveSubroutineUniformName(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetActiveSubroutineUniformName = this._pat._addressof_glGetActiveSubroutineUniformName;
        if (addressof_glGetActiveSubroutineUniformName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformName"));
        }
        this.dispatch_glGetActiveSubroutineUniformName1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetActiveSubroutineUniformName);
    }
    
    private native void dispatch_glGetActiveSubroutineUniformName1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glGetActiveSubroutineUniformName(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5, final byte[] array2, final int n6) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"length_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n6) {
            throw new GLException("array offset argument \"name_offset\" (" + n6 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetActiveSubroutineUniformName = this._pat._addressof_glGetActiveSubroutineUniformName;
        if (addressof_glGetActiveSubroutineUniformName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformName"));
        }
        this.dispatch_glGetActiveSubroutineUniformName1(n, n2, n3, n4, array, 4 * n5, false, array2, n6, false, addressof_glGetActiveSubroutineUniformName);
    }
    
    @Override
    public void glGetActiveSubroutineName(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetActiveSubroutineName = this._pat._addressof_glGetActiveSubroutineName;
        if (addressof_glGetActiveSubroutineName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineName"));
        }
        this.dispatch_glGetActiveSubroutineName1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetActiveSubroutineName);
    }
    
    private native void dispatch_glGetActiveSubroutineName1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glGetActiveSubroutineName(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5, final byte[] array2, final int n6) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"length_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n6) {
            throw new GLException("array offset argument \"name_offset\" (" + n6 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetActiveSubroutineName = this._pat._addressof_glGetActiveSubroutineName;
        if (addressof_glGetActiveSubroutineName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineName"));
        }
        this.dispatch_glGetActiveSubroutineName1(n, n2, n3, n4, array, 4 * n5, false, array2, n6, false, addressof_glGetActiveSubroutineName);
    }
    
    @Override
    public void glUniformSubroutinesuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniformSubroutinesuiv = this._pat._addressof_glUniformSubroutinesuiv;
        if (addressof_glUniformSubroutinesuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformSubroutinesuiv"));
        }
        this.dispatch_glUniformSubroutinesuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniformSubroutinesuiv);
    }
    
    private native void dispatch_glUniformSubroutinesuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniformSubroutinesuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"indices_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformSubroutinesuiv = this._pat._addressof_glUniformSubroutinesuiv;
        if (addressof_glUniformSubroutinesuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformSubroutinesuiv"));
        }
        this.dispatch_glUniformSubroutinesuiv1(n, n2, array, 4 * n3, false, addressof_glUniformSubroutinesuiv);
    }
    
    @Override
    public void glGetUniformSubroutineuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetUniformSubroutineuiv = this._pat._addressof_glGetUniformSubroutineuiv;
        if (addressof_glGetUniformSubroutineuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformSubroutineuiv"));
        }
        this.dispatch_glGetUniformSubroutineuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetUniformSubroutineuiv);
    }
    
    private native void dispatch_glGetUniformSubroutineuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformSubroutineuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformSubroutineuiv = this._pat._addressof_glGetUniformSubroutineuiv;
        if (addressof_glGetUniformSubroutineuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformSubroutineuiv"));
        }
        this.dispatch_glGetUniformSubroutineuiv1(n, n2, array, 4 * n3, false, addressof_glGetUniformSubroutineuiv);
    }
    
    @Override
    public void glGetProgramStageiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramStageiv = this._pat._addressof_glGetProgramStageiv;
        if (addressof_glGetProgramStageiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramStageiv"));
        }
        this.dispatch_glGetProgramStageiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramStageiv);
    }
    
    private native void dispatch_glGetProgramStageiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetProgramStageiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"values_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramStageiv = this._pat._addressof_glGetProgramStageiv;
        if (addressof_glGetProgramStageiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramStageiv"));
        }
        this.dispatch_glGetProgramStageiv1(n, n2, n3, array, 4 * n4, false, addressof_glGetProgramStageiv);
    }
    
    @Override
    public void glPatchParameteri(final int n, final int n2) {
        final long addressof_glPatchParameteri = this._pat._addressof_glPatchParameteri;
        if (addressof_glPatchParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPatchParameteri"));
        }
        this.dispatch_glPatchParameteri1(n, n2, addressof_glPatchParameteri);
    }
    
    private native void dispatch_glPatchParameteri1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPatchParameterfv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glPatchParameterfv = this._pat._addressof_glPatchParameterfv;
        if (addressof_glPatchParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPatchParameterfv"));
        }
        this.dispatch_glPatchParameterfv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glPatchParameterfv);
    }
    
    private native void dispatch_glPatchParameterfv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glPatchParameterfv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"values_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPatchParameterfv = this._pat._addressof_glPatchParameterfv;
        if (addressof_glPatchParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPatchParameterfv"));
        }
        this.dispatch_glPatchParameterfv1(n, array, 4 * n2, false, addressof_glPatchParameterfv);
    }
    
    @Override
    public void glBindTransformFeedback(final int n, final int n2) {
        final long addressof_glBindTransformFeedback = this._pat._addressof_glBindTransformFeedback;
        if (addressof_glBindTransformFeedback == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTransformFeedback"));
        }
        this.dispatch_glBindTransformFeedback1(n, n2, addressof_glBindTransformFeedback);
    }
    
    private native void dispatch_glBindTransformFeedback1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDeleteTransformFeedbacks(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteTransformFeedbacks = this._pat._addressof_glDeleteTransformFeedbacks;
        if (addressof_glDeleteTransformFeedbacks == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
        }
        this.dispatch_glDeleteTransformFeedbacks1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteTransformFeedbacks);
    }
    
    private native void dispatch_glDeleteTransformFeedbacks1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteTransformFeedbacks(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteTransformFeedbacks = this._pat._addressof_glDeleteTransformFeedbacks;
        if (addressof_glDeleteTransformFeedbacks == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
        }
        this.dispatch_glDeleteTransformFeedbacks1(n, array, 4 * n2, false, addressof_glDeleteTransformFeedbacks);
    }
    
    @Override
    public void glGenTransformFeedbacks(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenTransformFeedbacks = this._pat._addressof_glGenTransformFeedbacks;
        if (addressof_glGenTransformFeedbacks == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
        }
        this.dispatch_glGenTransformFeedbacks1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenTransformFeedbacks);
    }
    
    private native void dispatch_glGenTransformFeedbacks1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenTransformFeedbacks(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenTransformFeedbacks = this._pat._addressof_glGenTransformFeedbacks;
        if (addressof_glGenTransformFeedbacks == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
        }
        this.dispatch_glGenTransformFeedbacks1(n, array, 4 * n2, false, addressof_glGenTransformFeedbacks);
    }
    
    @Override
    public boolean glIsTransformFeedback(final int n) {
        final long addressof_glIsTransformFeedback = this._pat._addressof_glIsTransformFeedback;
        if (addressof_glIsTransformFeedback == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsTransformFeedback"));
        }
        return this.dispatch_glIsTransformFeedback1(n, addressof_glIsTransformFeedback);
    }
    
    private native boolean dispatch_glIsTransformFeedback1(final int p0, final long p1);
    
    @Override
    public void glPauseTransformFeedback() {
        final long addressof_glPauseTransformFeedback = this._pat._addressof_glPauseTransformFeedback;
        if (addressof_glPauseTransformFeedback == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPauseTransformFeedback"));
        }
        this.dispatch_glPauseTransformFeedback1(addressof_glPauseTransformFeedback);
    }
    
    private native void dispatch_glPauseTransformFeedback1(final long p0);
    
    @Override
    public void glResumeTransformFeedback() {
        final long addressof_glResumeTransformFeedback = this._pat._addressof_glResumeTransformFeedback;
        if (addressof_glResumeTransformFeedback == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glResumeTransformFeedback"));
        }
        this.dispatch_glResumeTransformFeedback1(addressof_glResumeTransformFeedback);
    }
    
    private native void dispatch_glResumeTransformFeedback1(final long p0);
    
    @Override
    public void glDrawTransformFeedback(final int n, final int n2) {
        final long addressof_glDrawTransformFeedback = this._pat._addressof_glDrawTransformFeedback;
        if (addressof_glDrawTransformFeedback == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedback"));
        }
        this.dispatch_glDrawTransformFeedback1(n, n2, addressof_glDrawTransformFeedback);
    }
    
    private native void dispatch_glDrawTransformFeedback1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDrawTransformFeedbackStream(final int n, final int n2, final int n3) {
        final long addressof_glDrawTransformFeedbackStream = this._pat._addressof_glDrawTransformFeedbackStream;
        if (addressof_glDrawTransformFeedbackStream == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackStream"));
        }
        this.dispatch_glDrawTransformFeedbackStream1(n, n2, n3, addressof_glDrawTransformFeedbackStream);
    }
    
    private native void dispatch_glDrawTransformFeedbackStream1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glBeginQueryIndexed(final int n, final int n2, final int n3) {
        final long addressof_glBeginQueryIndexed = this._pat._addressof_glBeginQueryIndexed;
        if (addressof_glBeginQueryIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginQueryIndexed"));
        }
        this.dispatch_glBeginQueryIndexed1(n, n2, n3, addressof_glBeginQueryIndexed);
    }
    
    private native void dispatch_glBeginQueryIndexed1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glEndQueryIndexed(final int n, final int n2) {
        final long addressof_glEndQueryIndexed = this._pat._addressof_glEndQueryIndexed;
        if (addressof_glEndQueryIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndQueryIndexed"));
        }
        this.dispatch_glEndQueryIndexed1(n, n2, addressof_glEndQueryIndexed);
    }
    
    private native void dispatch_glEndQueryIndexed1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetQueryIndexediv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetQueryIndexediv = this._pat._addressof_glGetQueryIndexediv;
        if (addressof_glGetQueryIndexediv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryIndexediv"));
        }
        this.dispatch_glGetQueryIndexediv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetQueryIndexediv);
    }
    
    private native void dispatch_glGetQueryIndexediv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetQueryIndexediv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryIndexediv = this._pat._addressof_glGetQueryIndexediv;
        if (addressof_glGetQueryIndexediv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryIndexediv"));
        }
        this.dispatch_glGetQueryIndexediv1(n, n2, n3, array, 4 * n4, false, addressof_glGetQueryIndexediv);
    }
    
    @Override
    public void glReleaseShaderCompiler() {
        if (!this._context.isGLES2Compatible()) {
            return;
        }
        final long addressof_glReleaseShaderCompiler = this._pat._addressof_glReleaseShaderCompiler;
        if (addressof_glReleaseShaderCompiler == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glReleaseShaderCompiler"));
        }
        this.dispatch_glReleaseShaderCompiler1(addressof_glReleaseShaderCompiler);
    }
    
    private native void dispatch_glReleaseShaderCompiler1(final long p0);
    
    @Override
    public void glShaderBinary(final int n, final IntBuffer intBuffer, final int n2, final Buffer buffer, final int n3) {
        if (!this._context.isGLES2Compatible()) {
            throw new GLException("Method \"glShaderBinary\" not available");
        }
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(buffer);
        final long addressof_glShaderBinary = this._pat._addressof_glShaderBinary;
        if (addressof_glShaderBinary == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
        }
        this.dispatch_glShaderBinary1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, n2, direct2 ? buffer : Buffers.getArray(buffer), direct2 ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct2, n3, addressof_glShaderBinary);
    }
    
    private native void dispatch_glShaderBinary1(final int p0, final Object p1, final int p2, final boolean p3, final int p4, final Object p5, final int p6, final boolean p7, final int p8, final long p9);
    
    @Override
    public void glShaderBinary(final int n, final int[] array, final int n2, final int n3, final Buffer buffer, final int n4) {
        if (!this._context.isGLES2Compatible()) {
            throw new GLException("Method \"glShaderBinary\" not available");
        }
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"shaders_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glShaderBinary = this._pat._addressof_glShaderBinary;
        if (addressof_glShaderBinary == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
        }
        this.dispatch_glShaderBinary1(n, array, 4 * n2, false, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n4, addressof_glShaderBinary);
    }
    
    @Override
    public void glGetShaderPrecisionFormat(final int n, final int n2, final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        if (!this._context.isGLES2Compatible()) {
            throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
        }
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glGetShaderPrecisionFormat = this._pat._addressof_glGetShaderPrecisionFormat;
        if (addressof_glGetShaderPrecisionFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
        }
        this.dispatch_glGetShaderPrecisionFormat1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glGetShaderPrecisionFormat);
    }
    
    private native void dispatch_glGetShaderPrecisionFormat1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetShaderPrecisionFormat(final int n, final int n2, final int[] array, final int n3, final int[] array2, final int n4) {
        if (!this._context.isGLES2Compatible()) {
            throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
        }
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"range_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"precision_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetShaderPrecisionFormat = this._pat._addressof_glGetShaderPrecisionFormat;
        if (addressof_glGetShaderPrecisionFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
        }
        this.dispatch_glGetShaderPrecisionFormat1(n, n2, array, 4 * n3, false, array2, 4 * n4, false, addressof_glGetShaderPrecisionFormat);
    }
    
    @Override
    public void glDepthRangef(final float n, final float n2) {
        if (!this._context.isGLES2Compatible() && !this._context.hasFP32CompatAPI()) {
            this.glDepthRange(n, n2);
            return;
        }
        final long addressof_glDepthRangef = this._pat._addressof_glDepthRangef;
        if (addressof_glDepthRangef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthRangef"));
        }
        this.dispatch_glDepthRangef1(n, n2, addressof_glDepthRangef);
    }
    
    private native void dispatch_glDepthRangef1(final float p0, final float p1, final long p2);
    
    @Override
    public void glClearDepthf(final float n) {
        if (!this._context.isGLES2Compatible() && !this._context.hasFP32CompatAPI()) {
            this.glClearDepth(n);
            return;
        }
        final long addressof_glClearDepthf = this._pat._addressof_glClearDepthf;
        if (addressof_glClearDepthf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearDepthf"));
        }
        this.dispatch_glClearDepthf1(n, addressof_glClearDepthf);
    }
    
    private native void dispatch_glClearDepthf1(final float p0, final long p1);
    
    @Override
    public void glGetProgramBinary(final int n, final int n2, final IntBuffer intBuffer, final IntBuffer intBuffer2, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(buffer);
        final long addressof_glGetProgramBinary = this._pat._addressof_glGetProgramBinary;
        if (addressof_glGetProgramBinary == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
        }
        this.dispatch_glGetProgramBinary1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? buffer : Buffers.getArray(buffer), direct3 ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct3, addressof_glGetProgramBinary);
    }
    
    private native void dispatch_glGetProgramBinary1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glGetProgramBinary(final int n, final int n2, final int[] array, final int n3, final int[] array2, final int n4, final Buffer buffer) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"binaryFormat_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetProgramBinary = this._pat._addressof_glGetProgramBinary;
        if (addressof_glGetProgramBinary == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
        }
        this.dispatch_glGetProgramBinary1(n, n2, array, 4 * n3, false, array2, 4 * n4, false, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetProgramBinary);
    }
    
    @Override
    public void glProgramBinary(final int n, final int n2, final Buffer buffer, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glProgramBinary = this._pat._addressof_glProgramBinary;
        if (addressof_glProgramBinary == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramBinary"));
        }
        this.dispatch_glProgramBinary1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, addressof_glProgramBinary);
    }
    
    private native void dispatch_glProgramBinary1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glProgramUniform1d(final int n, final int n2, final double n3) {
        final long addressof_glProgramUniform1d = this._pat._addressof_glProgramUniform1d;
        if (addressof_glProgramUniform1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1d"));
        }
        this.dispatch_glProgramUniform1d1(n, n2, n3, addressof_glProgramUniform1d);
    }
    
    private native void dispatch_glProgramUniform1d1(final int p0, final int p1, final double p2, final long p3);
    
    @Override
    public void glProgramUniform1dv(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform1dv = this._pat._addressof_glProgramUniform1dv;
        if (addressof_glProgramUniform1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dv"));
        }
        this.dispatch_glProgramUniform1dv1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform1dv);
    }
    
    private native void dispatch_glProgramUniform1dv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1dv(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1dv = this._pat._addressof_glProgramUniform1dv;
        if (addressof_glProgramUniform1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dv"));
        }
        this.dispatch_glProgramUniform1dv1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform1dv);
    }
    
    @Override
    public void glProgramUniform2d(final int n, final int n2, final double n3, final double n4) {
        final long addressof_glProgramUniform2d = this._pat._addressof_glProgramUniform2d;
        if (addressof_glProgramUniform2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2d"));
        }
        this.dispatch_glProgramUniform2d1(n, n2, n3, n4, addressof_glProgramUniform2d);
    }
    
    private native void dispatch_glProgramUniform2d1(final int p0, final int p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glProgramUniform2dv(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform2dv = this._pat._addressof_glProgramUniform2dv;
        if (addressof_glProgramUniform2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dv"));
        }
        this.dispatch_glProgramUniform2dv1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform2dv);
    }
    
    private native void dispatch_glProgramUniform2dv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2dv(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2dv = this._pat._addressof_glProgramUniform2dv;
        if (addressof_glProgramUniform2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dv"));
        }
        this.dispatch_glProgramUniform2dv1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform2dv);
    }
    
    @Override
    public void glProgramUniform3d(final int n, final int n2, final double n3, final double n4, final double n5) {
        final long addressof_glProgramUniform3d = this._pat._addressof_glProgramUniform3d;
        if (addressof_glProgramUniform3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3d"));
        }
        this.dispatch_glProgramUniform3d1(n, n2, n3, n4, n5, addressof_glProgramUniform3d);
    }
    
    private native void dispatch_glProgramUniform3d1(final int p0, final int p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glProgramUniform3dv(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform3dv = this._pat._addressof_glProgramUniform3dv;
        if (addressof_glProgramUniform3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dv"));
        }
        this.dispatch_glProgramUniform3dv1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform3dv);
    }
    
    private native void dispatch_glProgramUniform3dv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3dv(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3dv = this._pat._addressof_glProgramUniform3dv;
        if (addressof_glProgramUniform3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dv"));
        }
        this.dispatch_glProgramUniform3dv1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform3dv);
    }
    
    @Override
    public void glProgramUniform4d(final int n, final int n2, final double n3, final double n4, final double n5, final double n6) {
        final long addressof_glProgramUniform4d = this._pat._addressof_glProgramUniform4d;
        if (addressof_glProgramUniform4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4d"));
        }
        this.dispatch_glProgramUniform4d1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4d);
    }
    
    private native void dispatch_glProgramUniform4d1(final int p0, final int p1, final double p2, final double p3, final double p4, final double p5, final long p6);
    
    @Override
    public void glProgramUniform4dv(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform4dv = this._pat._addressof_glProgramUniform4dv;
        if (addressof_glProgramUniform4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dv"));
        }
        this.dispatch_glProgramUniform4dv1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform4dv);
    }
    
    private native void dispatch_glProgramUniform4dv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4dv(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4dv = this._pat._addressof_glProgramUniform4dv;
        if (addressof_glProgramUniform4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dv"));
        }
        this.dispatch_glProgramUniform4dv1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform4dv);
    }
    
    @Override
    public void glProgramUniformMatrix2dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix2dv = this._pat._addressof_glProgramUniformMatrix2dv;
        if (addressof_glProgramUniformMatrix2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dv"));
        }
        this.dispatch_glProgramUniformMatrix2dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix2dv);
    }
    
    private native void dispatch_glProgramUniformMatrix2dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2dv = this._pat._addressof_glProgramUniformMatrix2dv;
        if (addressof_glProgramUniformMatrix2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dv"));
        }
        this.dispatch_glProgramUniformMatrix2dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix2dv);
    }
    
    @Override
    public void glProgramUniformMatrix3dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix3dv = this._pat._addressof_glProgramUniformMatrix3dv;
        if (addressof_glProgramUniformMatrix3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dv"));
        }
        this.dispatch_glProgramUniformMatrix3dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix3dv);
    }
    
    private native void dispatch_glProgramUniformMatrix3dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3dv = this._pat._addressof_glProgramUniformMatrix3dv;
        if (addressof_glProgramUniformMatrix3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dv"));
        }
        this.dispatch_glProgramUniformMatrix3dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix3dv);
    }
    
    @Override
    public void glProgramUniformMatrix4dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix4dv = this._pat._addressof_glProgramUniformMatrix4dv;
        if (addressof_glProgramUniformMatrix4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dv"));
        }
        this.dispatch_glProgramUniformMatrix4dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix4dv);
    }
    
    private native void dispatch_glProgramUniformMatrix4dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4dv = this._pat._addressof_glProgramUniformMatrix4dv;
        if (addressof_glProgramUniformMatrix4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dv"));
        }
        this.dispatch_glProgramUniformMatrix4dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix4dv);
    }
    
    @Override
    public void glProgramUniformMatrix2x3dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix2x3dv = this._pat._addressof_glProgramUniformMatrix2x3dv;
        if (addressof_glProgramUniformMatrix2x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dv"));
        }
        this.dispatch_glProgramUniformMatrix2x3dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix2x3dv);
    }
    
    private native void dispatch_glProgramUniformMatrix2x3dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2x3dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2x3dv = this._pat._addressof_glProgramUniformMatrix2x3dv;
        if (addressof_glProgramUniformMatrix2x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dv"));
        }
        this.dispatch_glProgramUniformMatrix2x3dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix2x3dv);
    }
    
    @Override
    public void glProgramUniformMatrix3x2dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix3x2dv = this._pat._addressof_glProgramUniformMatrix3x2dv;
        if (addressof_glProgramUniformMatrix3x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dv"));
        }
        this.dispatch_glProgramUniformMatrix3x2dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix3x2dv);
    }
    
    private native void dispatch_glProgramUniformMatrix3x2dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3x2dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3x2dv = this._pat._addressof_glProgramUniformMatrix3x2dv;
        if (addressof_glProgramUniformMatrix3x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dv"));
        }
        this.dispatch_glProgramUniformMatrix3x2dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix3x2dv);
    }
    
    @Override
    public void glProgramUniformMatrix2x4dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix2x4dv = this._pat._addressof_glProgramUniformMatrix2x4dv;
        if (addressof_glProgramUniformMatrix2x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dv"));
        }
        this.dispatch_glProgramUniformMatrix2x4dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix2x4dv);
    }
    
    private native void dispatch_glProgramUniformMatrix2x4dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2x4dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2x4dv = this._pat._addressof_glProgramUniformMatrix2x4dv;
        if (addressof_glProgramUniformMatrix2x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dv"));
        }
        this.dispatch_glProgramUniformMatrix2x4dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix2x4dv);
    }
    
    @Override
    public void glProgramUniformMatrix4x2dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix4x2dv = this._pat._addressof_glProgramUniformMatrix4x2dv;
        if (addressof_glProgramUniformMatrix4x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dv"));
        }
        this.dispatch_glProgramUniformMatrix4x2dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix4x2dv);
    }
    
    private native void dispatch_glProgramUniformMatrix4x2dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4x2dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4x2dv = this._pat._addressof_glProgramUniformMatrix4x2dv;
        if (addressof_glProgramUniformMatrix4x2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dv"));
        }
        this.dispatch_glProgramUniformMatrix4x2dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix4x2dv);
    }
    
    @Override
    public void glProgramUniformMatrix3x4dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix3x4dv = this._pat._addressof_glProgramUniformMatrix3x4dv;
        if (addressof_glProgramUniformMatrix3x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dv"));
        }
        this.dispatch_glProgramUniformMatrix3x4dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix3x4dv);
    }
    
    private native void dispatch_glProgramUniformMatrix3x4dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3x4dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3x4dv = this._pat._addressof_glProgramUniformMatrix3x4dv;
        if (addressof_glProgramUniformMatrix3x4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dv"));
        }
        this.dispatch_glProgramUniformMatrix3x4dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix3x4dv);
    }
    
    @Override
    public void glProgramUniformMatrix4x3dv(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix4x3dv = this._pat._addressof_glProgramUniformMatrix4x3dv;
        if (addressof_glProgramUniformMatrix4x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dv"));
        }
        this.dispatch_glProgramUniformMatrix4x3dv1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix4x3dv);
    }
    
    private native void dispatch_glProgramUniformMatrix4x3dv1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4x3dv(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4x3dv = this._pat._addressof_glProgramUniformMatrix4x3dv;
        if (addressof_glProgramUniformMatrix4x3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dv"));
        }
        this.dispatch_glProgramUniformMatrix4x3dv1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix4x3dv);
    }
    
    @Override
    public void glVertexAttribL1d(final int n, final double n2) {
        final long addressof_glVertexAttribL1d = this._pat._addressof_glVertexAttribL1d;
        if (addressof_glVertexAttribL1d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1d"));
        }
        this.dispatch_glVertexAttribL1d1(n, n2, addressof_glVertexAttribL1d);
    }
    
    private native void dispatch_glVertexAttribL1d1(final int p0, final double p1, final long p2);
    
    @Override
    public void glVertexAttribL2d(final int n, final double n2, final double n3) {
        final long addressof_glVertexAttribL2d = this._pat._addressof_glVertexAttribL2d;
        if (addressof_glVertexAttribL2d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2d"));
        }
        this.dispatch_glVertexAttribL2d1(n, n2, n3, addressof_glVertexAttribL2d);
    }
    
    private native void dispatch_glVertexAttribL2d1(final int p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glVertexAttribL3d(final int n, final double n2, final double n3, final double n4) {
        final long addressof_glVertexAttribL3d = this._pat._addressof_glVertexAttribL3d;
        if (addressof_glVertexAttribL3d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3d"));
        }
        this.dispatch_glVertexAttribL3d1(n, n2, n3, n4, addressof_glVertexAttribL3d);
    }
    
    private native void dispatch_glVertexAttribL3d1(final int p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glVertexAttribL4d(final int n, final double n2, final double n3, final double n4, final double n5) {
        final long addressof_glVertexAttribL4d = this._pat._addressof_glVertexAttribL4d;
        if (addressof_glVertexAttribL4d == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4d"));
        }
        this.dispatch_glVertexAttribL4d1(n, n2, n3, n4, n5, addressof_glVertexAttribL4d);
    }
    
    private native void dispatch_glVertexAttribL4d1(final int p0, final double p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glVertexAttribL1dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttribL1dv = this._pat._addressof_glVertexAttribL1dv;
        if (addressof_glVertexAttribL1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1dv"));
        }
        this.dispatch_glVertexAttribL1dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttribL1dv);
    }
    
    private native void dispatch_glVertexAttribL1dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL1dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL1dv = this._pat._addressof_glVertexAttribL1dv;
        if (addressof_glVertexAttribL1dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1dv"));
        }
        this.dispatch_glVertexAttribL1dv1(n, array, 8 * n2, false, addressof_glVertexAttribL1dv);
    }
    
    @Override
    public void glVertexAttribL2dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttribL2dv = this._pat._addressof_glVertexAttribL2dv;
        if (addressof_glVertexAttribL2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2dv"));
        }
        this.dispatch_glVertexAttribL2dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttribL2dv);
    }
    
    private native void dispatch_glVertexAttribL2dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL2dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL2dv = this._pat._addressof_glVertexAttribL2dv;
        if (addressof_glVertexAttribL2dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2dv"));
        }
        this.dispatch_glVertexAttribL2dv1(n, array, 8 * n2, false, addressof_glVertexAttribL2dv);
    }
    
    @Override
    public void glVertexAttribL3dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttribL3dv = this._pat._addressof_glVertexAttribL3dv;
        if (addressof_glVertexAttribL3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3dv"));
        }
        this.dispatch_glVertexAttribL3dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttribL3dv);
    }
    
    private native void dispatch_glVertexAttribL3dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL3dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL3dv = this._pat._addressof_glVertexAttribL3dv;
        if (addressof_glVertexAttribL3dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3dv"));
        }
        this.dispatch_glVertexAttribL3dv1(n, array, 8 * n2, false, addressof_glVertexAttribL3dv);
    }
    
    @Override
    public void glVertexAttribL4dv(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttribL4dv = this._pat._addressof_glVertexAttribL4dv;
        if (addressof_glVertexAttribL4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4dv"));
        }
        this.dispatch_glVertexAttribL4dv1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttribL4dv);
    }
    
    private native void dispatch_glVertexAttribL4dv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL4dv(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL4dv = this._pat._addressof_glVertexAttribL4dv;
        if (addressof_glVertexAttribL4dv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4dv"));
        }
        this.dispatch_glVertexAttribL4dv1(n, array, 8 * n2, false, addressof_glVertexAttribL4dv);
    }
    
    @Override
    public void glVertexAttribLPointer(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glVertexAttribLPointer = this._pat._addressof_glVertexAttribLPointer;
        if (addressof_glVertexAttribLPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLPointer"));
        }
        this.dispatch_glVertexAttribLPointer0(n, n2, n3, n4, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glVertexAttribLPointer);
    }
    
    private native void dispatch_glVertexAttribLPointer0(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final long p6);
    
    @Override
    public void glVertexAttribLPointer(final int n, final int n2, final int n3, final int n4, final long n5) {
        this.checkArrayVBOBound(true);
        final long addressof_glVertexAttribLPointer = this._pat._addressof_glVertexAttribLPointer;
        if (addressof_glVertexAttribLPointer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLPointer"));
        }
        this.dispatch_glVertexAttribLPointer0(n, n2, n3, n4, n5, addressof_glVertexAttribLPointer);
    }
    
    private native void dispatch_glVertexAttribLPointer0(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glGetVertexAttribLdv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetVertexAttribLdv = this._pat._addressof_glGetVertexAttribLdv;
        if (addressof_glGetVertexAttribLdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLdv"));
        }
        this.dispatch_glGetVertexAttribLdv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetVertexAttribLdv);
    }
    
    private native void dispatch_glGetVertexAttribLdv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribLdv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribLdv = this._pat._addressof_glGetVertexAttribLdv;
        if (addressof_glGetVertexAttribLdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLdv"));
        }
        this.dispatch_glGetVertexAttribLdv1(n, n2, array, 8 * n3, false, addressof_glGetVertexAttribLdv);
    }
    
    @Override
    public void glViewportArrayv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glViewportArrayv = this._pat._addressof_glViewportArrayv;
        if (addressof_glViewportArrayv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glViewportArrayv"));
        }
        this.dispatch_glViewportArrayv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glViewportArrayv);
    }
    
    private native void dispatch_glViewportArrayv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glViewportArrayv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glViewportArrayv = this._pat._addressof_glViewportArrayv;
        if (addressof_glViewportArrayv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glViewportArrayv"));
        }
        this.dispatch_glViewportArrayv1(n, n2, array, 4 * n3, false, addressof_glViewportArrayv);
    }
    
    @Override
    public void glViewportIndexedf(final int n, final float n2, final float n3, final float n4, final float n5) {
        final long addressof_glViewportIndexedf = this._pat._addressof_glViewportIndexedf;
        if (addressof_glViewportIndexedf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedf"));
        }
        this.dispatch_glViewportIndexedf1(n, n2, n3, n4, n5, addressof_glViewportIndexedf);
    }
    
    private native void dispatch_glViewportIndexedf1(final int p0, final float p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glViewportIndexedfv(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glViewportIndexedfv = this._pat._addressof_glViewportIndexedfv;
        if (addressof_glViewportIndexedfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedfv"));
        }
        this.dispatch_glViewportIndexedfv1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glViewportIndexedfv);
    }
    
    private native void dispatch_glViewportIndexedfv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glViewportIndexedfv(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glViewportIndexedfv = this._pat._addressof_glViewportIndexedfv;
        if (addressof_glViewportIndexedfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedfv"));
        }
        this.dispatch_glViewportIndexedfv1(n, array, 4 * n2, false, addressof_glViewportIndexedfv);
    }
    
    @Override
    public void glScissorArrayv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glScissorArrayv = this._pat._addressof_glScissorArrayv;
        if (addressof_glScissorArrayv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScissorArrayv"));
        }
        this.dispatch_glScissorArrayv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glScissorArrayv);
    }
    
    private native void dispatch_glScissorArrayv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glScissorArrayv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glScissorArrayv = this._pat._addressof_glScissorArrayv;
        if (addressof_glScissorArrayv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScissorArrayv"));
        }
        this.dispatch_glScissorArrayv1(n, n2, array, 4 * n3, false, addressof_glScissorArrayv);
    }
    
    @Override
    public void glScissorIndexed(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glScissorIndexed = this._pat._addressof_glScissorIndexed;
        if (addressof_glScissorIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexed"));
        }
        this.dispatch_glScissorIndexed1(n, n2, n3, n4, n5, addressof_glScissorIndexed);
    }
    
    private native void dispatch_glScissorIndexed1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glScissorIndexedv(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glScissorIndexedv = this._pat._addressof_glScissorIndexedv;
        if (addressof_glScissorIndexedv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexedv"));
        }
        this.dispatch_glScissorIndexedv1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glScissorIndexedv);
    }
    
    private native void dispatch_glScissorIndexedv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glScissorIndexedv(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glScissorIndexedv = this._pat._addressof_glScissorIndexedv;
        if (addressof_glScissorIndexedv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexedv"));
        }
        this.dispatch_glScissorIndexedv1(n, array, 4 * n2, false, addressof_glScissorIndexedv);
    }
    
    @Override
    public void glDepthRangeArrayv(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glDepthRangeArrayv = this._pat._addressof_glDepthRangeArrayv;
        if (addressof_glDepthRangeArrayv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeArrayv"));
        }
        this.dispatch_glDepthRangeArrayv1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glDepthRangeArrayv);
    }
    
    private native void dispatch_glDepthRangeArrayv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glDepthRangeArrayv(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDepthRangeArrayv = this._pat._addressof_glDepthRangeArrayv;
        if (addressof_glDepthRangeArrayv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeArrayv"));
        }
        this.dispatch_glDepthRangeArrayv1(n, n2, array, 8 * n3, false, addressof_glDepthRangeArrayv);
    }
    
    @Override
    public void glDepthRangeIndexed(final int n, final double n2, final double n3) {
        final long addressof_glDepthRangeIndexed = this._pat._addressof_glDepthRangeIndexed;
        if (addressof_glDepthRangeIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeIndexed"));
        }
        this.dispatch_glDepthRangeIndexed1(n, n2, n3, addressof_glDepthRangeIndexed);
    }
    
    private native void dispatch_glDepthRangeIndexed1(final int p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glGetFloati_v(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetFloati_v = this._pat._addressof_glGetFloati_v;
        if (addressof_glGetFloati_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_v"));
        }
        this.dispatch_glGetFloati_v1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetFloati_v);
    }
    
    private native void dispatch_glGetFloati_v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetFloati_v(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFloati_v = this._pat._addressof_glGetFloati_v;
        if (addressof_glGetFloati_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_v"));
        }
        this.dispatch_glGetFloati_v1(n, n2, array, 4 * n3, false, addressof_glGetFloati_v);
    }
    
    @Override
    public void glGetDoublei_v(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetDoublei_v = this._pat._addressof_glGetDoublei_v;
        if (addressof_glGetDoublei_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_v"));
        }
        this.dispatch_glGetDoublei_v1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetDoublei_v);
    }
    
    private native void dispatch_glGetDoublei_v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetDoublei_v(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetDoublei_v = this._pat._addressof_glGetDoublei_v;
        if (addressof_glGetDoublei_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_v"));
        }
        this.dispatch_glGetDoublei_v1(n, n2, array, 8 * n3, false, addressof_glGetDoublei_v);
    }
    
    @Override
    public void glDrawArraysInstancedBaseInstance(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glDrawArraysInstancedBaseInstance = this._pat._addressof_glDrawArraysInstancedBaseInstance;
        if (addressof_glDrawArraysInstancedBaseInstance == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstancedBaseInstance"));
        }
        this.dispatch_glDrawArraysInstancedBaseInstance1(n, n2, n3, n4, n5, addressof_glDrawArraysInstancedBaseInstance);
    }
    
    private native void dispatch_glDrawArraysInstancedBaseInstance1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glDrawElementsInstancedBaseInstance(final int n, final int n2, final int n3, final Buffer buffer, final int n4, final int n5) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n2);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawElementsInstancedBaseInstance = this._pat._addressof_glDrawElementsInstancedBaseInstance;
        if (addressof_glDrawElementsInstancedBaseInstance == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseInstance"));
        }
        this.dispatch_glDrawElementsInstancedBaseInstance1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n4, n5, addressof_glDrawElementsInstancedBaseInstance);
    }
    
    private native void dispatch_glDrawElementsInstancedBaseInstance1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glDrawElementsInstancedBaseInstance(final int n, final int n2, final int n3, final long n4, final int n5, final int n6) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawElementsInstancedBaseInstance = this._pat._addressof_glDrawElementsInstancedBaseInstance;
        if (addressof_glDrawElementsInstancedBaseInstance == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseInstance"));
        }
        this.dispatch_glDrawElementsInstancedBaseInstance1(n, n2, n3, n4, n5, n6, addressof_glDrawElementsInstancedBaseInstance);
    }
    
    private native void dispatch_glDrawElementsInstancedBaseInstance1(final int p0, final int p1, final int p2, final long p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glDrawElementsInstancedBaseVertexBaseInstance(final int n, final int n2, final int n3, final Buffer buffer, final int n4, final int n5, final int n6) {
        this.checkElementVBOUnbound(true);
        Buffers.rangeCheck(buffer, n2);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glDrawElementsInstancedBaseVertexBaseInstance = this._pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
        if (addressof_glDrawElementsInstancedBaseVertexBaseInstance == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexBaseInstance"));
        }
        this.dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n4, n5, n6, addressof_glDrawElementsInstancedBaseVertexBaseInstance);
    }
    
    private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glDrawElementsInstancedBaseVertexBaseInstance(final int n, final int n2, final int n3, final long n4, final int n5, final int n6, final int n7) {
        this.checkElementVBOBound(true);
        final long addressof_glDrawElementsInstancedBaseVertexBaseInstance = this._pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
        if (addressof_glDrawElementsInstancedBaseVertexBaseInstance == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexBaseInstance"));
        }
        this.dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(n, n2, n3, n4, n5, n6, n7, addressof_glDrawElementsInstancedBaseVertexBaseInstance);
    }
    
    private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(final int p0, final int p1, final int p2, final long p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glGetInternalformativ(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetInternalformativ = this._pat._addressof_glGetInternalformativ;
        if (addressof_glGetInternalformativ == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
        }
        this.dispatch_glGetInternalformativ1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetInternalformativ);
    }
    
    private native void dispatch_glGetInternalformativ1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetInternalformativ(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetInternalformativ = this._pat._addressof_glGetInternalformativ;
        if (addressof_glGetInternalformativ == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
        }
        this.dispatch_glGetInternalformativ1(n, n2, n3, n4, array, 4 * n5, false, addressof_glGetInternalformativ);
    }
    
    @Override
    public void glGetActiveAtomicCounterBufferiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetActiveAtomicCounterBufferiv = this._pat._addressof_glGetActiveAtomicCounterBufferiv;
        if (addressof_glGetActiveAtomicCounterBufferiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAtomicCounterBufferiv"));
        }
        this.dispatch_glGetActiveAtomicCounterBufferiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetActiveAtomicCounterBufferiv);
    }
    
    private native void dispatch_glGetActiveAtomicCounterBufferiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetActiveAtomicCounterBufferiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetActiveAtomicCounterBufferiv = this._pat._addressof_glGetActiveAtomicCounterBufferiv;
        if (addressof_glGetActiveAtomicCounterBufferiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAtomicCounterBufferiv"));
        }
        this.dispatch_glGetActiveAtomicCounterBufferiv1(n, n2, n3, array, 4 * n4, false, addressof_glGetActiveAtomicCounterBufferiv);
    }
    
    @Override
    public void glBindImageTexture(final int n, final int n2, final int n3, final boolean b, final int n4, final int n5, final int n6) {
        final long addressof_glBindImageTexture = this._pat._addressof_glBindImageTexture;
        if (addressof_glBindImageTexture == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindImageTexture"));
        }
        this.dispatch_glBindImageTexture1(n, n2, n3, b, n4, n5, n6, addressof_glBindImageTexture);
    }
    
    private native void dispatch_glBindImageTexture1(final int p0, final int p1, final int p2, final boolean p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glMemoryBarrier(final int n) {
        final long addressof_glMemoryBarrier = this._pat._addressof_glMemoryBarrier;
        if (addressof_glMemoryBarrier == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMemoryBarrier"));
        }
        this.dispatch_glMemoryBarrier1(n, addressof_glMemoryBarrier);
    }
    
    private native void dispatch_glMemoryBarrier1(final int p0, final long p1);
    
    @Override
    public void glDrawTransformFeedbackInstanced(final int n, final int n2, final int n3) {
        final long addressof_glDrawTransformFeedbackInstanced = this._pat._addressof_glDrawTransformFeedbackInstanced;
        if (addressof_glDrawTransformFeedbackInstanced == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackInstanced"));
        }
        this.dispatch_glDrawTransformFeedbackInstanced1(n, n2, n3, addressof_glDrawTransformFeedbackInstanced);
    }
    
    private native void dispatch_glDrawTransformFeedbackInstanced1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glDrawTransformFeedbackStreamInstanced(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glDrawTransformFeedbackStreamInstanced = this._pat._addressof_glDrawTransformFeedbackStreamInstanced;
        if (addressof_glDrawTransformFeedbackStreamInstanced == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackStreamInstanced"));
        }
        this.dispatch_glDrawTransformFeedbackStreamInstanced1(n, n2, n3, n4, addressof_glDrawTransformFeedbackStreamInstanced);
    }
    
    private native void dispatch_glDrawTransformFeedbackStreamInstanced1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glClearBufferData(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glClearBufferData = this._pat._addressof_glClearBufferData;
        if (addressof_glClearBufferData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferData"));
        }
        this.dispatch_glClearBufferData1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glClearBufferData);
    }
    
    private native void dispatch_glClearBufferData1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glClearBufferSubData(final int n, final int n2, final long n3, final long n4, final int n5, final int n6, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glClearBufferSubData = this._pat._addressof_glClearBufferSubData;
        if (addressof_glClearBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearBufferSubData"));
        }
        this.dispatch_glClearBufferSubData1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glClearBufferSubData);
    }
    
    private native void dispatch_glClearBufferSubData1(final int p0, final int p1, final long p2, final long p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glDispatchCompute(final int n, final int n2, final int n3) {
        final long addressof_glDispatchCompute = this._pat._addressof_glDispatchCompute;
        if (addressof_glDispatchCompute == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDispatchCompute"));
        }
        this.dispatch_glDispatchCompute1(n, n2, n3, addressof_glDispatchCompute);
    }
    
    private native void dispatch_glDispatchCompute1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glDispatchComputeIndirect(final long n) {
        final long addressof_glDispatchComputeIndirect = this._pat._addressof_glDispatchComputeIndirect;
        if (addressof_glDispatchComputeIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDispatchComputeIndirect"));
        }
        this.dispatch_glDispatchComputeIndirect1(n, addressof_glDispatchComputeIndirect);
    }
    
    private native void dispatch_glDispatchComputeIndirect1(final long p0, final long p1);
    
    @Override
    public void glCopyImageSubData(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final int n12, final int n13, final int n14, final int n15) {
        final long addressof_glCopyImageSubData = this._pat._addressof_glCopyImageSubData;
        if (addressof_glCopyImageSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyImageSubData"));
        }
        this.dispatch_glCopyImageSubData1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, addressof_glCopyImageSubData);
    }
    
    private native void dispatch_glCopyImageSubData1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final int p11, final int p12, final int p13, final int p14, final long p15);
    
    @Override
    public void glFramebufferParameteri(final int n, final int n2, final int n3) {
        final long addressof_glFramebufferParameteri = this._pat._addressof_glFramebufferParameteri;
        if (addressof_glFramebufferParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferParameteri"));
        }
        this.dispatch_glFramebufferParameteri1(n, n2, n3, addressof_glFramebufferParameteri);
    }
    
    private native void dispatch_glFramebufferParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glGetFramebufferParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetFramebufferParameteriv = this._pat._addressof_glGetFramebufferParameteriv;
        if (addressof_glGetFramebufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameteriv"));
        }
        this.dispatch_glGetFramebufferParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetFramebufferParameteriv);
    }
    
    private native void dispatch_glGetFramebufferParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetFramebufferParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFramebufferParameteriv = this._pat._addressof_glGetFramebufferParameteriv;
        if (addressof_glGetFramebufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameteriv"));
        }
        this.dispatch_glGetFramebufferParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetFramebufferParameteriv);
    }
    
    @Override
    public void glGetInternalformati64v(final int n, final int n2, final int n3, final int n4, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetInternalformati64v = this._pat._addressof_glGetInternalformati64v;
        if (addressof_glGetInternalformati64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformati64v"));
        }
        this.dispatch_glGetInternalformati64v1(n, n2, n3, n4, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetInternalformati64v);
    }
    
    private native void dispatch_glGetInternalformati64v1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetInternalformati64v(final int n, final int n2, final int n3, final int n4, final long[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetInternalformati64v = this._pat._addressof_glGetInternalformati64v;
        if (addressof_glGetInternalformati64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformati64v"));
        }
        this.dispatch_glGetInternalformati64v1(n, n2, n3, n4, array, 8 * n5, false, addressof_glGetInternalformati64v);
    }
    
    @Override
    public void glInvalidateTexSubImage(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glInvalidateTexSubImage = this._pat._addressof_glInvalidateTexSubImage;
        if (addressof_glInvalidateTexSubImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateTexSubImage"));
        }
        this.dispatch_glInvalidateTexSubImage1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glInvalidateTexSubImage);
    }
    
    private native void dispatch_glInvalidateTexSubImage1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glInvalidateTexImage(final int n, final int n2) {
        final long addressof_glInvalidateTexImage = this._pat._addressof_glInvalidateTexImage;
        if (addressof_glInvalidateTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateTexImage"));
        }
        this.dispatch_glInvalidateTexImage1(n, n2, addressof_glInvalidateTexImage);
    }
    
    private native void dispatch_glInvalidateTexImage1(final int p0, final int p1, final long p2);
    
    @Override
    public void glInvalidateBufferSubData(final int n, final long n2, final long n3) {
        final long addressof_glInvalidateBufferSubData = this._pat._addressof_glInvalidateBufferSubData;
        if (addressof_glInvalidateBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateBufferSubData"));
        }
        this.dispatch_glInvalidateBufferSubData1(n, n2, n3, addressof_glInvalidateBufferSubData);
    }
    
    private native void dispatch_glInvalidateBufferSubData1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glInvalidateBufferData(final int n) {
        final long addressof_glInvalidateBufferData = this._pat._addressof_glInvalidateBufferData;
        if (addressof_glInvalidateBufferData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateBufferData"));
        }
        this.dispatch_glInvalidateBufferData1(n, addressof_glInvalidateBufferData);
    }
    
    private native void dispatch_glInvalidateBufferData1(final int p0, final long p1);
    
    @Override
    public void glInvalidateFramebuffer(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glInvalidateFramebuffer = this._pat._addressof_glInvalidateFramebuffer;
        if (addressof_glInvalidateFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
        }
        this.dispatch_glInvalidateFramebuffer1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glInvalidateFramebuffer);
    }
    
    private native void dispatch_glInvalidateFramebuffer1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glInvalidateFramebuffer(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"attachments_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glInvalidateFramebuffer = this._pat._addressof_glInvalidateFramebuffer;
        if (addressof_glInvalidateFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
        }
        this.dispatch_glInvalidateFramebuffer1(n, n2, array, 4 * n3, false, addressof_glInvalidateFramebuffer);
    }
    
    @Override
    public void glInvalidateSubFramebuffer(final int n, final int n2, final IntBuffer intBuffer, final int n3, final int n4, final int n5, final int n6) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glInvalidateSubFramebuffer = this._pat._addressof_glInvalidateSubFramebuffer;
        if (addressof_glInvalidateSubFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
        }
        this.dispatch_glInvalidateSubFramebuffer1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, n3, n4, n5, n6, addressof_glInvalidateSubFramebuffer);
    }
    
    private native void dispatch_glInvalidateSubFramebuffer1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glInvalidateSubFramebuffer(final int n, final int n2, final int[] array, final int n3, final int n4, final int n5, final int n6, final int n7) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"attachments_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glInvalidateSubFramebuffer = this._pat._addressof_glInvalidateSubFramebuffer;
        if (addressof_glInvalidateSubFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
        }
        this.dispatch_glInvalidateSubFramebuffer1(n, n2, array, 4 * n3, false, n4, n5, n6, n7, addressof_glInvalidateSubFramebuffer);
    }
    
    @Override
    public void glMultiDrawArraysIndirect(final int n, final Buffer buffer, final int n2, final int n3) {
        this.checkIndirectVBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawArraysIndirect = this._pat._addressof_glMultiDrawArraysIndirect;
        if (addressof_glMultiDrawArraysIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirect"));
        }
        this.dispatch_glMultiDrawArraysIndirect1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n2, n3, addressof_glMultiDrawArraysIndirect);
    }
    
    private native void dispatch_glMultiDrawArraysIndirect1(final int p0, final Object p1, final int p2, final boolean p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glMultiDrawArraysIndirect(final int n, final long n2, final int n3, final int n4) {
        this.checkIndirectVBOBound(true);
        final long addressof_glMultiDrawArraysIndirect = this._pat._addressof_glMultiDrawArraysIndirect;
        if (addressof_glMultiDrawArraysIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirect"));
        }
        this.dispatch_glMultiDrawArraysIndirect1(n, n2, n3, n4, addressof_glMultiDrawArraysIndirect);
    }
    
    private native void dispatch_glMultiDrawArraysIndirect1(final int p0, final long p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glMultiDrawElementsIndirect(final int n, final int n2, final Buffer buffer, final int n3, final int n4) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawElementsIndirect = this._pat._addressof_glMultiDrawElementsIndirect;
        if (addressof_glMultiDrawElementsIndirect == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirect"));
        }
        this.dispatch_glMultiDrawElementsIndirect1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, n4, addressof_glMultiDrawElementsIndirect);
    }
    
    private native void dispatch_glMultiDrawElementsIndirect1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glGetProgramInterfaceiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramInterfaceiv = this._pat._addressof_glGetProgramInterfaceiv;
        if (addressof_glGetProgramInterfaceiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInterfaceiv"));
        }
        this.dispatch_glGetProgramInterfaceiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramInterfaceiv);
    }
    
    private native void dispatch_glGetProgramInterfaceiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetProgramInterfaceiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramInterfaceiv = this._pat._addressof_glGetProgramInterfaceiv;
        if (addressof_glGetProgramInterfaceiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInterfaceiv"));
        }
        this.dispatch_glGetProgramInterfaceiv1(n, n2, n3, array, 4 * n4, false, addressof_glGetProgramInterfaceiv);
    }
    
    @Override
    public int glGetProgramResourceIndex(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetProgramResourceIndex = this._pat._addressof_glGetProgramResourceIndex;
        if (addressof_glGetProgramResourceIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceIndex"));
        }
        return this.dispatch_glGetProgramResourceIndex1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetProgramResourceIndex);
    }
    
    private native int dispatch_glGetProgramResourceIndex1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public int glGetProgramResourceIndex(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"name_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramResourceIndex = this._pat._addressof_glGetProgramResourceIndex;
        if (addressof_glGetProgramResourceIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceIndex"));
        }
        return this.dispatch_glGetProgramResourceIndex1(n, n2, array, n3, false, addressof_glGetProgramResourceIndex);
    }
    
    @Override
    public void glGetProgramResourceName(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetProgramResourceName = this._pat._addressof_glGetProgramResourceName;
        if (addressof_glGetProgramResourceName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceName"));
        }
        this.dispatch_glGetProgramResourceName1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetProgramResourceName);
    }
    
    private native void dispatch_glGetProgramResourceName1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glGetProgramResourceName(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5, final byte[] array2, final int n6) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"length_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n6) {
            throw new GLException("array offset argument \"name_offset\" (" + n6 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetProgramResourceName = this._pat._addressof_glGetProgramResourceName;
        if (addressof_glGetProgramResourceName == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceName"));
        }
        this.dispatch_glGetProgramResourceName1(n, n2, n3, n4, array, 4 * n5, false, array2, n6, false, addressof_glGetProgramResourceName);
    }
    
    @Override
    public void glGetProgramResourceiv(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer, final int n5, final IntBuffer intBuffer2, final IntBuffer intBuffer3) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final long addressof_glGetProgramResourceiv = this._pat._addressof_glGetProgramResourceiv;
        if (addressof_glGetProgramResourceiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceiv"));
        }
        this.dispatch_glGetProgramResourceiv1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, n5, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, addressof_glGetProgramResourceiv);
    }
    
    private native void dispatch_glGetProgramResourceiv1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final int p7, final Object p8, final int p9, final boolean p10, final Object p11, final int p12, final boolean p13, final long p14);
    
    @Override
    public void glGetProgramResourceiv(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5, final int n6, final int[] array2, final int n7, final int[] array3, final int n8) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"props_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n7) {
            throw new GLException("array offset argument \"length_offset\" (" + n7 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n8) {
            throw new GLException("array offset argument \"params_offset\" (" + n8 + ") equals or exceeds array length (" + array3.length + ")");
        }
        final long addressof_glGetProgramResourceiv = this._pat._addressof_glGetProgramResourceiv;
        if (addressof_glGetProgramResourceiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceiv"));
        }
        this.dispatch_glGetProgramResourceiv1(n, n2, n3, n4, array, 4 * n5, false, n6, array2, 4 * n7, false, array3, 4 * n8, false, addressof_glGetProgramResourceiv);
    }
    
    @Override
    public int glGetProgramResourceLocation(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetProgramResourceLocation = this._pat._addressof_glGetProgramResourceLocation;
        if (addressof_glGetProgramResourceLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocation"));
        }
        return this.dispatch_glGetProgramResourceLocation1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetProgramResourceLocation);
    }
    
    private native int dispatch_glGetProgramResourceLocation1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public int glGetProgramResourceLocation(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"name_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramResourceLocation = this._pat._addressof_glGetProgramResourceLocation;
        if (addressof_glGetProgramResourceLocation == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocation"));
        }
        return this.dispatch_glGetProgramResourceLocation1(n, n2, array, n3, false, addressof_glGetProgramResourceLocation);
    }
    
    @Override
    public int glGetProgramResourceLocationIndex(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetProgramResourceLocationIndex = this._pat._addressof_glGetProgramResourceLocationIndex;
        if (addressof_glGetProgramResourceLocationIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocationIndex"));
        }
        return this.dispatch_glGetProgramResourceLocationIndex1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetProgramResourceLocationIndex);
    }
    
    private native int dispatch_glGetProgramResourceLocationIndex1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public int glGetProgramResourceLocationIndex(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"name_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramResourceLocationIndex = this._pat._addressof_glGetProgramResourceLocationIndex;
        if (addressof_glGetProgramResourceLocationIndex == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocationIndex"));
        }
        return this.dispatch_glGetProgramResourceLocationIndex1(n, n2, array, n3, false, addressof_glGetProgramResourceLocationIndex);
    }
    
    @Override
    public void glShaderStorageBlockBinding(final int n, final int n2, final int n3) {
        final long addressof_glShaderStorageBlockBinding = this._pat._addressof_glShaderStorageBlockBinding;
        if (addressof_glShaderStorageBlockBinding == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderStorageBlockBinding"));
        }
        this.dispatch_glShaderStorageBlockBinding1(n, n2, n3, addressof_glShaderStorageBlockBinding);
    }
    
    private native void dispatch_glShaderStorageBlockBinding1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTexBufferRange(final int n, final int n2, final int n3, final long n4, final long n5) {
        final long addressof_glTexBufferRange = this._pat._addressof_glTexBufferRange;
        if (addressof_glTexBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexBufferRange"));
        }
        this.dispatch_glTexBufferRange1(n, n2, n3, n4, n5, addressof_glTexBufferRange);
    }
    
    private native void dispatch_glTexBufferRange1(final int p0, final int p1, final int p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glTexStorage2DMultisample(final int n, final int n2, final int n3, final int n4, final int n5, final boolean b) {
        final long addressof_glTexStorage2DMultisample = this._pat._addressof_glTexStorage2DMultisample;
        if (addressof_glTexStorage2DMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2DMultisample"));
        }
        this.dispatch_glTexStorage2DMultisample1(n, n2, n3, n4, n5, b, addressof_glTexStorage2DMultisample);
    }
    
    private native void dispatch_glTexStorage2DMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTexStorage3DMultisample(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final boolean b) {
        final long addressof_glTexStorage3DMultisample = this._pat._addressof_glTexStorage3DMultisample;
        if (addressof_glTexStorage3DMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3DMultisample"));
        }
        this.dispatch_glTexStorage3DMultisample1(n, n2, n3, n4, n5, n6, b, addressof_glTexStorage3DMultisample);
    }
    
    private native void dispatch_glTexStorage3DMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glTextureView(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glTextureView = this._pat._addressof_glTextureView;
        if (addressof_glTextureView == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureView"));
        }
        this.dispatch_glTextureView1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glTextureView);
    }
    
    private native void dispatch_glTextureView1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glBindVertexBuffer(final int n, final int n2, final long n3, final int n4) {
        final long addressof_glBindVertexBuffer = this._pat._addressof_glBindVertexBuffer;
        if (addressof_glBindVertexBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindVertexBuffer"));
        }
        this.dispatch_glBindVertexBuffer1(n, n2, n3, n4, addressof_glBindVertexBuffer);
    }
    
    private native void dispatch_glBindVertexBuffer1(final int p0, final int p1, final long p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribFormat(final int n, final int n2, final int n3, final boolean b, final int n4) {
        final long addressof_glVertexAttribFormat = this._pat._addressof_glVertexAttribFormat;
        if (addressof_glVertexAttribFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribFormat"));
        }
        this.dispatch_glVertexAttribFormat1(n, n2, n3, b, n4, addressof_glVertexAttribFormat);
    }
    
    private native void dispatch_glVertexAttribFormat1(final int p0, final int p1, final int p2, final boolean p3, final int p4, final long p5);
    
    @Override
    public void glVertexAttribIFormat(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribIFormat = this._pat._addressof_glVertexAttribIFormat;
        if (addressof_glVertexAttribIFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIFormat"));
        }
        this.dispatch_glVertexAttribIFormat1(n, n2, n3, n4, addressof_glVertexAttribIFormat);
    }
    
    private native void dispatch_glVertexAttribIFormat1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribLFormat(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribLFormat = this._pat._addressof_glVertexAttribLFormat;
        if (addressof_glVertexAttribLFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLFormat"));
        }
        this.dispatch_glVertexAttribLFormat1(n, n2, n3, n4, addressof_glVertexAttribLFormat);
    }
    
    private native void dispatch_glVertexAttribLFormat1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribBinding(final int n, final int n2) {
        final long addressof_glVertexAttribBinding = this._pat._addressof_glVertexAttribBinding;
        if (addressof_glVertexAttribBinding == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribBinding"));
        }
        this.dispatch_glVertexAttribBinding1(n, n2, addressof_glVertexAttribBinding);
    }
    
    private native void dispatch_glVertexAttribBinding1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexBindingDivisor(final int n, final int n2) {
        final long addressof_glVertexBindingDivisor = this._pat._addressof_glVertexBindingDivisor;
        if (addressof_glVertexBindingDivisor == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexBindingDivisor"));
        }
        this.dispatch_glVertexBindingDivisor1(n, n2, addressof_glVertexBindingDivisor);
    }
    
    private native void dispatch_glVertexBindingDivisor1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDebugMessageControl(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer, final boolean b) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDebugMessageControl = this._pat._addressof_glDebugMessageControl;
        if (addressof_glDebugMessageControl == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
        }
        this.dispatch_glDebugMessageControl1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, b, addressof_glDebugMessageControl);
    }
    
    private native void dispatch_glDebugMessageControl1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final boolean p7, final long p8);
    
    @Override
    public void glDebugMessageControl(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5, final boolean b) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"ids_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDebugMessageControl = this._pat._addressof_glDebugMessageControl;
        if (addressof_glDebugMessageControl == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
        }
        this.dispatch_glDebugMessageControl1(n, n2, n3, n4, array, 4 * n5, false, b, addressof_glDebugMessageControl);
    }
    
    @Override
    public void glDebugMessageInsert(final int n, final int n2, final int n3, final int n4, final int n5, final String s) {
        final long addressof_glDebugMessageInsert = this._pat._addressof_glDebugMessageInsert;
        if (addressof_glDebugMessageInsert == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageInsert"));
        }
        this.dispatch_glDebugMessageInsert1(n, n2, n3, n4, n5, s, addressof_glDebugMessageInsert);
    }
    
    private native void dispatch_glDebugMessageInsert1(final int p0, final int p1, final int p2, final int p3, final int p4, final String p5, final long p6);
    
    @Override
    public int glGetDebugMessageLog(final int n, final int n2, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final IntBuffer intBuffer4, final IntBuffer intBuffer5, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final boolean direct4 = Buffers.isDirect(intBuffer4);
        final boolean direct5 = Buffers.isDirect(intBuffer5);
        final boolean direct6 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetDebugMessageLog = this._pat._addressof_glGetDebugMessageLog;
        if (addressof_glGetDebugMessageLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
        }
        return this.dispatch_glGetDebugMessageLog1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, direct4 ? intBuffer4 : Buffers.getArray(intBuffer4), direct4 ? Buffers.getDirectBufferByteOffset(intBuffer4) : Buffers.getIndirectBufferByteOffset(intBuffer4), direct4, direct5 ? intBuffer5 : Buffers.getArray(intBuffer5), direct5 ? Buffers.getDirectBufferByteOffset(intBuffer5) : Buffers.getIndirectBufferByteOffset(intBuffer5), direct5, direct6 ? byteBuffer : Buffers.getArray(byteBuffer), direct6 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct6, addressof_glGetDebugMessageLog);
    }
    
    private native int dispatch_glGetDebugMessageLog1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final Object p8, final int p9, final boolean p10, final Object p11, final int p12, final boolean p13, final Object p14, final int p15, final boolean p16, final Object p17, final int p18, final boolean p19, final long p20);
    
    @Override
    public int glGetDebugMessageLog(final int n, final int n2, final int[] array, final int n3, final int[] array2, final int n4, final int[] array3, final int n5, final int[] array4, final int n6, final int[] array5, final int n7, final byte[] array6, final int n8) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"sources_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"types_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n5) {
            throw new GLException("array offset argument \"ids_offset\" (" + n5 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n6) {
            throw new GLException("array offset argument \"severities_offset\" (" + n6 + ") equals or exceeds array length (" + array4.length + ")");
        }
        if (array5 != null && array5.length <= n7) {
            throw new GLException("array offset argument \"lengths_offset\" (" + n7 + ") equals or exceeds array length (" + array5.length + ")");
        }
        if (array6 != null && array6.length <= n8) {
            throw new GLException("array offset argument \"messageLog_offset\" (" + n8 + ") equals or exceeds array length (" + array6.length + ")");
        }
        final long addressof_glGetDebugMessageLog = this._pat._addressof_glGetDebugMessageLog;
        if (addressof_glGetDebugMessageLog == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
        }
        return this.dispatch_glGetDebugMessageLog1(n, n2, array, 4 * n3, false, array2, 4 * n4, false, array3, 4 * n5, false, array4, 4 * n6, false, array5, 4 * n7, false, array6, n8, false, addressof_glGetDebugMessageLog);
    }
    
    @Override
    public void glPushDebugGroup(final int n, final int n2, final int n3, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glPushDebugGroup = this._pat._addressof_glPushDebugGroup;
        if (addressof_glPushDebugGroup == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
        }
        this.dispatch_glPushDebugGroup1(n, n2, n3, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glPushDebugGroup);
    }
    
    private native void dispatch_glPushDebugGroup1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glPushDebugGroup(final int n, final int n2, final int n3, final byte[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"message_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPushDebugGroup = this._pat._addressof_glPushDebugGroup;
        if (addressof_glPushDebugGroup == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
        }
        this.dispatch_glPushDebugGroup1(n, n2, n3, array, n4, false, addressof_glPushDebugGroup);
    }
    
    @Override
    public void glPopDebugGroup() {
        final long addressof_glPopDebugGroup = this._pat._addressof_glPopDebugGroup;
        if (addressof_glPopDebugGroup == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPopDebugGroup"));
        }
        this.dispatch_glPopDebugGroup1(addressof_glPopDebugGroup);
    }
    
    private native void dispatch_glPopDebugGroup1(final long p0);
    
    @Override
    public void glObjectLabel(final int n, final int n2, final int n3, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glObjectLabel = this._pat._addressof_glObjectLabel;
        if (addressof_glObjectLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
        }
        this.dispatch_glObjectLabel1(n, n2, n3, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glObjectLabel);
    }
    
    private native void dispatch_glObjectLabel1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glObjectLabel(final int n, final int n2, final int n3, final byte[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"label_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glObjectLabel = this._pat._addressof_glObjectLabel;
        if (addressof_glObjectLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
        }
        this.dispatch_glObjectLabel1(n, n2, n3, array, n4, false, addressof_glObjectLabel);
    }
    
    @Override
    public void glGetObjectLabel(final int n, final int n2, final int n3, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetObjectLabel = this._pat._addressof_glGetObjectLabel;
        if (addressof_glGetObjectLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
        }
        this.dispatch_glGetObjectLabel1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetObjectLabel);
    }
    
    private native void dispatch_glGetObjectLabel1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetObjectLabel(final int n, final int n2, final int n3, final int[] array, final int n4, final byte[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"label_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetObjectLabel = this._pat._addressof_glGetObjectLabel;
        if (addressof_glGetObjectLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
        }
        this.dispatch_glGetObjectLabel1(n, n2, n3, array, 4 * n4, false, array2, n5, false, addressof_glGetObjectLabel);
    }
    
    @Override
    public void glObjectPtrLabel(final Buffer buffer, final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glObjectPtrLabel = this._pat._addressof_glObjectPtrLabel;
        if (addressof_glObjectPtrLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
        }
        this.dispatch_glObjectPtrLabel1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glObjectPtrLabel);
    }
    
    private native void dispatch_glObjectPtrLabel1(final Object p0, final int p1, final boolean p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glObjectPtrLabel(final Buffer buffer, final int n, final byte[] array, final int n2) {
        final boolean direct = Buffers.isDirect(buffer);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"label_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glObjectPtrLabel = this._pat._addressof_glObjectPtrLabel;
        if (addressof_glObjectPtrLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
        }
        this.dispatch_glObjectPtrLabel1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, array, n2, false, addressof_glObjectPtrLabel);
    }
    
    @Override
    public void glGetObjectPtrLabel(final Buffer buffer, final int n, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final boolean direct3 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetObjectPtrLabel = this._pat._addressof_glGetObjectPtrLabel;
        if (addressof_glGetObjectPtrLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
        }
        this.dispatch_glGetObjectPtrLabel1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, direct3 ? byteBuffer : Buffers.getArray(byteBuffer), direct3 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct3, addressof_glGetObjectPtrLabel);
    }
    
    private native void dispatch_glGetObjectPtrLabel1(final Object p0, final int p1, final boolean p2, final int p3, final Object p4, final int p5, final boolean p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glGetObjectPtrLabel(final Buffer buffer, final int n, final int[] array, final int n2, final byte[] array2, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"length_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"label_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetObjectPtrLabel = this._pat._addressof_glGetObjectPtrLabel;
        if (addressof_glGetObjectPtrLabel == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
        }
        this.dispatch_glGetObjectPtrLabel1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, array, 4 * n2, false, array2, n3, false, addressof_glGetObjectPtrLabel);
    }
    
    private void glBufferStorageDelegate(final int n, final long n2, final Buffer buffer, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glBufferStorage = this._pat._addressof_glBufferStorage;
        if (addressof_glBufferStorage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBufferStorage"));
        }
        this.dispatch_glBufferStorageDelegate1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, addressof_glBufferStorage);
    }
    
    private native void dispatch_glBufferStorageDelegate1(final int p0, final long p1, final Object p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glClearTexImage(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glClearTexImage = this._pat._addressof_glClearTexImage;
        if (addressof_glClearTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearTexImage"));
        }
        this.dispatch_glClearTexImage1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glClearTexImage);
    }
    
    private native void dispatch_glClearTexImage1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glClearTexSubImage(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glClearTexSubImage = this._pat._addressof_glClearTexSubImage;
        if (addressof_glClearTexSubImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearTexSubImage"));
        }
        this.dispatch_glClearTexSubImage1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glClearTexSubImage);
    }
    
    private native void dispatch_glClearTexSubImage1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glBindBuffersBase(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glBindBuffersBase = this._pat._addressof_glBindBuffersBase;
        if (addressof_glBindBuffersBase == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersBase"));
        }
        this.dispatch_glBindBuffersBase1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glBindBuffersBase);
    }
    
    private native void dispatch_glBindBuffersBase1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glBindBuffersBase(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"buffers_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glBindBuffersBase = this._pat._addressof_glBindBuffersBase;
        if (addressof_glBindBuffersBase == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersBase"));
        }
        this.dispatch_glBindBuffersBase1(n, n2, n3, array, 4 * n4, false, addressof_glBindBuffersBase);
    }
    
    @Override
    public void glBindBuffersRange(final int n, final int n2, final int n3, final IntBuffer intBuffer, final PointerBuffer pointerBuffer, final PointerBuffer pointerBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(pointerBuffer);
        final boolean direct3 = Buffers.isDirect(pointerBuffer2);
        final long addressof_glBindBuffersRange = this._pat._addressof_glBindBuffersRange;
        if (addressof_glBindBuffersRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersRange"));
        }
        this.dispatch_glBindBuffersRange1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct2 ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct2, direct3 ? ((pointerBuffer2 != null) ? pointerBuffer2.getBuffer() : null) : Buffers.getArray(pointerBuffer2), direct3 ? Buffers.getDirectBufferByteOffset(pointerBuffer2) : Buffers.getIndirectBufferByteOffset(pointerBuffer2), direct3, addressof_glBindBuffersRange);
    }
    
    private native void dispatch_glBindBuffersRange1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glBindBuffersRange(final int n, final int n2, final int n3, final int[] array, final int n4, final PointerBuffer pointerBuffer, final PointerBuffer pointerBuffer2) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"buffers_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final boolean direct2 = Buffers.isDirect(pointerBuffer2);
        final long addressof_glBindBuffersRange = this._pat._addressof_glBindBuffersRange;
        if (addressof_glBindBuffersRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersRange"));
        }
        this.dispatch_glBindBuffersRange1(n, n2, n3, array, 4 * n4, false, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, direct2 ? ((pointerBuffer2 != null) ? pointerBuffer2.getBuffer() : null) : Buffers.getArray(pointerBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(pointerBuffer2) : Buffers.getIndirectBufferByteOffset(pointerBuffer2), direct2, addressof_glBindBuffersRange);
    }
    
    @Override
    public void glBindTextures(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glBindTextures = this._pat._addressof_glBindTextures;
        if (addressof_glBindTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTextures"));
        }
        this.dispatch_glBindTextures1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glBindTextures);
    }
    
    private native void dispatch_glBindTextures1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glBindTextures(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"textures_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glBindTextures = this._pat._addressof_glBindTextures;
        if (addressof_glBindTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTextures"));
        }
        this.dispatch_glBindTextures1(n, n2, array, 4 * n3, false, addressof_glBindTextures);
    }
    
    @Override
    public void glBindSamplers(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glBindSamplers = this._pat._addressof_glBindSamplers;
        if (addressof_glBindSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindSamplers"));
        }
        this.dispatch_glBindSamplers1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glBindSamplers);
    }
    
    private native void dispatch_glBindSamplers1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glBindSamplers(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"samplers_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glBindSamplers = this._pat._addressof_glBindSamplers;
        if (addressof_glBindSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindSamplers"));
        }
        this.dispatch_glBindSamplers1(n, n2, array, 4 * n3, false, addressof_glBindSamplers);
    }
    
    @Override
    public void glBindImageTextures(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glBindImageTextures = this._pat._addressof_glBindImageTextures;
        if (addressof_glBindImageTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindImageTextures"));
        }
        this.dispatch_glBindImageTextures1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glBindImageTextures);
    }
    
    private native void dispatch_glBindImageTextures1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glBindImageTextures(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"textures_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glBindImageTextures = this._pat._addressof_glBindImageTextures;
        if (addressof_glBindImageTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindImageTextures"));
        }
        this.dispatch_glBindImageTextures1(n, n2, array, 4 * n3, false, addressof_glBindImageTextures);
    }
    
    @Override
    public void glBindVertexBuffers(final int n, final int n2, final IntBuffer intBuffer, final PointerBuffer pointerBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(pointerBuffer);
        final boolean direct3 = Buffers.isDirect(intBuffer2);
        final long addressof_glBindVertexBuffers = this._pat._addressof_glBindVertexBuffers;
        if (addressof_glBindVertexBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindVertexBuffers"));
        }
        this.dispatch_glBindVertexBuffers1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct2 ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct2, direct3 ? intBuffer2 : Buffers.getArray(intBuffer2), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct3, addressof_glBindVertexBuffers);
    }
    
    private native void dispatch_glBindVertexBuffers1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glBindVertexBuffers(final int n, final int n2, final int[] array, final int n3, final PointerBuffer pointerBuffer, final int[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"buffers_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final boolean direct = Buffers.isDirect(pointerBuffer);
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"strides_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glBindVertexBuffers = this._pat._addressof_glBindVertexBuffers;
        if (addressof_glBindVertexBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindVertexBuffers"));
        }
        this.dispatch_glBindVertexBuffers1(n, n2, array, 4 * n3, false, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, array2, 4 * n4, false, addressof_glBindVertexBuffers);
    }
    
    @Override
    public void glClipControl(final int n, final int n2) {
        final long addressof_glClipControl = this._pat._addressof_glClipControl;
        if (addressof_glClipControl == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClipControl"));
        }
        this.dispatch_glClipControl1(n, n2, addressof_glClipControl);
    }
    
    private native void dispatch_glClipControl1(final int p0, final int p1, final long p2);
    
    @Override
    public void glCreateTransformFeedbacks(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateTransformFeedbacks = this._pat._addressof_glCreateTransformFeedbacks;
        if (addressof_glCreateTransformFeedbacks == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateTransformFeedbacks"));
        }
        this.dispatch_glCreateTransformFeedbacks1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateTransformFeedbacks);
    }
    
    private native void dispatch_glCreateTransformFeedbacks1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateTransformFeedbacks(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateTransformFeedbacks = this._pat._addressof_glCreateTransformFeedbacks;
        if (addressof_glCreateTransformFeedbacks == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateTransformFeedbacks"));
        }
        this.dispatch_glCreateTransformFeedbacks1(n, array, 4 * n2, false, addressof_glCreateTransformFeedbacks);
    }
    
    @Override
    public void glTransformFeedbackBufferBase(final int n, final int n2, final int n3) {
        final long addressof_glTransformFeedbackBufferBase = this._pat._addressof_glTransformFeedbackBufferBase;
        if (addressof_glTransformFeedbackBufferBase == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackBufferBase"));
        }
        this.dispatch_glTransformFeedbackBufferBase1(n, n2, n3, addressof_glTransformFeedbackBufferBase);
    }
    
    private native void dispatch_glTransformFeedbackBufferBase1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTransformFeedbackBufferRange(final int n, final int n2, final int n3, final long n4, final long n5) {
        final long addressof_glTransformFeedbackBufferRange = this._pat._addressof_glTransformFeedbackBufferRange;
        if (addressof_glTransformFeedbackBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackBufferRange"));
        }
        this.dispatch_glTransformFeedbackBufferRange1(n, n2, n3, n4, n5, addressof_glTransformFeedbackBufferRange);
    }
    
    private native void dispatch_glTransformFeedbackBufferRange1(final int p0, final int p1, final int p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glGetTransformFeedbackiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTransformFeedbackiv = this._pat._addressof_glGetTransformFeedbackiv;
        if (addressof_glGetTransformFeedbackiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackiv"));
        }
        this.dispatch_glGetTransformFeedbackiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTransformFeedbackiv);
    }
    
    private native void dispatch_glGetTransformFeedbackiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTransformFeedbackiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTransformFeedbackiv = this._pat._addressof_glGetTransformFeedbackiv;
        if (addressof_glGetTransformFeedbackiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackiv"));
        }
        this.dispatch_glGetTransformFeedbackiv1(n, n2, array, 4 * n3, false, addressof_glGetTransformFeedbackiv);
    }
    
    @Override
    public void glGetTransformFeedbacki_v(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTransformFeedbacki_v = this._pat._addressof_glGetTransformFeedbacki_v;
        if (addressof_glGetTransformFeedbacki_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki_v"));
        }
        this.dispatch_glGetTransformFeedbacki_v1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTransformFeedbacki_v);
    }
    
    private native void dispatch_glGetTransformFeedbacki_v1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTransformFeedbacki_v(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"param_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTransformFeedbacki_v = this._pat._addressof_glGetTransformFeedbacki_v;
        if (addressof_glGetTransformFeedbacki_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki_v"));
        }
        this.dispatch_glGetTransformFeedbacki_v1(n, n2, n3, array, 4 * n4, false, addressof_glGetTransformFeedbacki_v);
    }
    
    @Override
    public void glGetTransformFeedbacki64_v(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetTransformFeedbacki64_v = this._pat._addressof_glGetTransformFeedbacki64_v;
        if (addressof_glGetTransformFeedbacki64_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki64_v"));
        }
        this.dispatch_glGetTransformFeedbacki64_v1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetTransformFeedbacki64_v);
    }
    
    private native void dispatch_glGetTransformFeedbacki64_v1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTransformFeedbacki64_v(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"param_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTransformFeedbacki64_v = this._pat._addressof_glGetTransformFeedbacki64_v;
        if (addressof_glGetTransformFeedbacki64_v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki64_v"));
        }
        this.dispatch_glGetTransformFeedbacki64_v1(n, n2, n3, array, 8 * n4, false, addressof_glGetTransformFeedbacki64_v);
    }
    
    @Override
    public void glCreateBuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateBuffers = this._pat._addressof_glCreateBuffers;
        if (addressof_glCreateBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateBuffers"));
        }
        this.dispatch_glCreateBuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateBuffers);
    }
    
    private native void dispatch_glCreateBuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateBuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"buffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateBuffers = this._pat._addressof_glCreateBuffers;
        if (addressof_glCreateBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateBuffers"));
        }
        this.dispatch_glCreateBuffers1(n, array, 4 * n2, false, addressof_glCreateBuffers);
    }
    
    private void glNamedBufferStorageDelegate(final int n, final long n2, final Buffer buffer, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glNamedBufferStorage = this._pat._addressof_glNamedBufferStorage;
        if (addressof_glNamedBufferStorage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferStorage"));
        }
        this.dispatch_glNamedBufferStorageDelegate1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, addressof_glNamedBufferStorage);
    }
    
    private native void dispatch_glNamedBufferStorageDelegate1(final int p0, final long p1, final Object p2, final int p3, final boolean p4, final int p5, final long p6);
    
    private void glNamedBufferDataDelegate(final int n, final long n2, final Buffer buffer, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glNamedBufferData = this._pat._addressof_glNamedBufferData;
        if (addressof_glNamedBufferData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferData"));
        }
        this.dispatch_glNamedBufferDataDelegate1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, addressof_glNamedBufferData);
    }
    
    private native void dispatch_glNamedBufferDataDelegate1(final int p0, final long p1, final Object p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glNamedBufferSubData(final int n, final long n2, final long n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glNamedBufferSubData = this._pat._addressof_glNamedBufferSubData;
        if (addressof_glNamedBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferSubData"));
        }
        this.dispatch_glNamedBufferSubData1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glNamedBufferSubData);
    }
    
    private native void dispatch_glNamedBufferSubData1(final int p0, final long p1, final long p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glCopyNamedBufferSubData(final int n, final int n2, final long n3, final long n4, final long n5) {
        final long addressof_glCopyNamedBufferSubData = this._pat._addressof_glCopyNamedBufferSubData;
        if (addressof_glCopyNamedBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyNamedBufferSubData"));
        }
        this.dispatch_glCopyNamedBufferSubData1(n, n2, n3, n4, n5, addressof_glCopyNamedBufferSubData);
    }
    
    private native void dispatch_glCopyNamedBufferSubData1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glClearNamedBufferData(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glClearNamedBufferData = this._pat._addressof_glClearNamedBufferData;
        if (addressof_glClearNamedBufferData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedBufferData"));
        }
        this.dispatch_glClearNamedBufferData1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glClearNamedBufferData);
    }
    
    private native void dispatch_glClearNamedBufferData1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glClearNamedBufferSubData(final int n, final int n2, final long n3, final long n4, final int n5, final int n6, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glClearNamedBufferSubData = this._pat._addressof_glClearNamedBufferSubData;
        if (addressof_glClearNamedBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedBufferSubData"));
        }
        this.dispatch_glClearNamedBufferSubData1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glClearNamedBufferSubData);
    }
    
    private native void dispatch_glClearNamedBufferSubData1(final int p0, final int p1, final long p2, final long p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    private long glMapNamedBufferDelegate(final int n, final int n2) {
        final long addressof_glMapNamedBuffer = this._pat._addressof_glMapNamedBuffer;
        if (addressof_glMapNamedBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBuffer"));
        }
        return this.dispatch_glMapNamedBufferDelegate1(n, n2, addressof_glMapNamedBuffer);
    }
    
    private native long dispatch_glMapNamedBufferDelegate1(final int p0, final int p1, final long p2);
    
    private long glMapNamedBufferRangeDelegate(final int n, final long n2, final long n3, final int n4) {
        final long addressof_glMapNamedBufferRange = this._pat._addressof_glMapNamedBufferRange;
        if (addressof_glMapNamedBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBufferRange"));
        }
        return this.dispatch_glMapNamedBufferRangeDelegate1(n, n2, n3, n4, addressof_glMapNamedBufferRange);
    }
    
    private native long dispatch_glMapNamedBufferRangeDelegate1(final int p0, final long p1, final long p2, final int p3, final long p4);
    
    private boolean glUnmapNamedBufferDelegate(final int n) {
        final long addressof_glUnmapNamedBuffer = this._pat._addressof_glUnmapNamedBuffer;
        if (addressof_glUnmapNamedBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUnmapNamedBuffer"));
        }
        return this.dispatch_glUnmapNamedBufferDelegate1(n, addressof_glUnmapNamedBuffer);
    }
    
    private native boolean dispatch_glUnmapNamedBufferDelegate1(final int p0, final long p1);
    
    @Override
    public void glFlushMappedNamedBufferRange(final int n, final long n2, final long n3) {
        final long addressof_glFlushMappedNamedBufferRange = this._pat._addressof_glFlushMappedNamedBufferRange;
        if (addressof_glFlushMappedNamedBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedNamedBufferRange"));
        }
        this.dispatch_glFlushMappedNamedBufferRange1(n, n2, n3, addressof_glFlushMappedNamedBufferRange);
    }
    
    private native void dispatch_glFlushMappedNamedBufferRange1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glGetNamedBufferParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedBufferParameteriv = this._pat._addressof_glGetNamedBufferParameteriv;
        if (addressof_glGetNamedBufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteriv"));
        }
        this.dispatch_glGetNamedBufferParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedBufferParameteriv);
    }
    
    private native void dispatch_glGetNamedBufferParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedBufferParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedBufferParameteriv = this._pat._addressof_glGetNamedBufferParameteriv;
        if (addressof_glGetNamedBufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteriv"));
        }
        this.dispatch_glGetNamedBufferParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetNamedBufferParameteriv);
    }
    
    @Override
    public void glGetNamedBufferParameteri64v(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetNamedBufferParameteri64v = this._pat._addressof_glGetNamedBufferParameteri64v;
        if (addressof_glGetNamedBufferParameteri64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteri64v"));
        }
        this.dispatch_glGetNamedBufferParameteri64v1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetNamedBufferParameteri64v);
    }
    
    private native void dispatch_glGetNamedBufferParameteri64v1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedBufferParameteri64v(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedBufferParameteri64v = this._pat._addressof_glGetNamedBufferParameteri64v;
        if (addressof_glGetNamedBufferParameteri64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteri64v"));
        }
        this.dispatch_glGetNamedBufferParameteri64v1(n, n2, array, 8 * n3, false, addressof_glGetNamedBufferParameteri64v);
    }
    
    @Override
    public void glGetNamedBufferPointerv(final int n, final int n2, final PointerBuffer pointerBuffer) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final long addressof_glGetNamedBufferPointerv = this._pat._addressof_glGetNamedBufferPointerv;
        if (addressof_glGetNamedBufferPointerv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferPointerv"));
        }
        this.dispatch_glGetNamedBufferPointerv1(n, n2, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, addressof_glGetNamedBufferPointerv);
    }
    
    private native void dispatch_glGetNamedBufferPointerv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedBufferSubData(final int n, final long n2, final long n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetNamedBufferSubData = this._pat._addressof_glGetNamedBufferSubData;
        if (addressof_glGetNamedBufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferSubData"));
        }
        this.dispatch_glGetNamedBufferSubData1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetNamedBufferSubData);
    }
    
    private native void dispatch_glGetNamedBufferSubData1(final int p0, final long p1, final long p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glCreateFramebuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateFramebuffers = this._pat._addressof_glCreateFramebuffers;
        if (addressof_glCreateFramebuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateFramebuffers"));
        }
        this.dispatch_glCreateFramebuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateFramebuffers);
    }
    
    private native void dispatch_glCreateFramebuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateFramebuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"framebuffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateFramebuffers = this._pat._addressof_glCreateFramebuffers;
        if (addressof_glCreateFramebuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateFramebuffers"));
        }
        this.dispatch_glCreateFramebuffers1(n, array, 4 * n2, false, addressof_glCreateFramebuffers);
    }
    
    @Override
    public void glNamedFramebufferRenderbuffer(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glNamedFramebufferRenderbuffer = this._pat._addressof_glNamedFramebufferRenderbuffer;
        if (addressof_glNamedFramebufferRenderbuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferRenderbuffer"));
        }
        this.dispatch_glNamedFramebufferRenderbuffer1(n, n2, n3, n4, addressof_glNamedFramebufferRenderbuffer);
    }
    
    private native void dispatch_glNamedFramebufferRenderbuffer1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glNamedFramebufferParameteri(final int n, final int n2, final int n3) {
        final long addressof_glNamedFramebufferParameteri = this._pat._addressof_glNamedFramebufferParameteri;
        if (addressof_glNamedFramebufferParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferParameteri"));
        }
        this.dispatch_glNamedFramebufferParameteri1(n, n2, n3, addressof_glNamedFramebufferParameteri);
    }
    
    private native void dispatch_glNamedFramebufferParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glNamedFramebufferTexture(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glNamedFramebufferTexture = this._pat._addressof_glNamedFramebufferTexture;
        if (addressof_glNamedFramebufferTexture == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture"));
        }
        this.dispatch_glNamedFramebufferTexture1(n, n2, n3, n4, addressof_glNamedFramebufferTexture);
    }
    
    private native void dispatch_glNamedFramebufferTexture1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glNamedFramebufferTextureLayer(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glNamedFramebufferTextureLayer = this._pat._addressof_glNamedFramebufferTextureLayer;
        if (addressof_glNamedFramebufferTextureLayer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureLayer"));
        }
        this.dispatch_glNamedFramebufferTextureLayer1(n, n2, n3, n4, n5, addressof_glNamedFramebufferTextureLayer);
    }
    
    private native void dispatch_glNamedFramebufferTextureLayer1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glNamedFramebufferDrawBuffer(final int n, final int n2) {
        final long addressof_glNamedFramebufferDrawBuffer = this._pat._addressof_glNamedFramebufferDrawBuffer;
        if (addressof_glNamedFramebufferDrawBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferDrawBuffer"));
        }
        this.dispatch_glNamedFramebufferDrawBuffer1(n, n2, addressof_glNamedFramebufferDrawBuffer);
    }
    
    private native void dispatch_glNamedFramebufferDrawBuffer1(final int p0, final int p1, final long p2);
    
    @Override
    public void glNamedFramebufferDrawBuffers(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glNamedFramebufferDrawBuffers = this._pat._addressof_glNamedFramebufferDrawBuffers;
        if (addressof_glNamedFramebufferDrawBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferDrawBuffers"));
        }
        this.dispatch_glNamedFramebufferDrawBuffers1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glNamedFramebufferDrawBuffers);
    }
    
    private native void dispatch_glNamedFramebufferDrawBuffers1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glNamedFramebufferDrawBuffers(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"bufs_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedFramebufferDrawBuffers = this._pat._addressof_glNamedFramebufferDrawBuffers;
        if (addressof_glNamedFramebufferDrawBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferDrawBuffers"));
        }
        this.dispatch_glNamedFramebufferDrawBuffers1(n, n2, array, 4 * n3, false, addressof_glNamedFramebufferDrawBuffers);
    }
    
    @Override
    public void glNamedFramebufferReadBuffer(final int n, final int n2) {
        final long addressof_glNamedFramebufferReadBuffer = this._pat._addressof_glNamedFramebufferReadBuffer;
        if (addressof_glNamedFramebufferReadBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferReadBuffer"));
        }
        this.dispatch_glNamedFramebufferReadBuffer1(n, n2, addressof_glNamedFramebufferReadBuffer);
    }
    
    private native void dispatch_glNamedFramebufferReadBuffer1(final int p0, final int p1, final long p2);
    
    @Override
    public void glInvalidateNamedFramebufferData(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glInvalidateNamedFramebufferData = this._pat._addressof_glInvalidateNamedFramebufferData;
        if (addressof_glInvalidateNamedFramebufferData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferData"));
        }
        this.dispatch_glInvalidateNamedFramebufferData1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glInvalidateNamedFramebufferData);
    }
    
    private native void dispatch_glInvalidateNamedFramebufferData1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glInvalidateNamedFramebufferData(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"attachments_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glInvalidateNamedFramebufferData = this._pat._addressof_glInvalidateNamedFramebufferData;
        if (addressof_glInvalidateNamedFramebufferData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferData"));
        }
        this.dispatch_glInvalidateNamedFramebufferData1(n, n2, array, 4 * n3, false, addressof_glInvalidateNamedFramebufferData);
    }
    
    @Override
    public void glInvalidateNamedFramebufferSubData(final int n, final int n2, final IntBuffer intBuffer, final int n3, final int n4, final int n5, final int n6) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glInvalidateNamedFramebufferSubData = this._pat._addressof_glInvalidateNamedFramebufferSubData;
        if (addressof_glInvalidateNamedFramebufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferSubData"));
        }
        this.dispatch_glInvalidateNamedFramebufferSubData1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, n3, n4, n5, n6, addressof_glInvalidateNamedFramebufferSubData);
    }
    
    private native void dispatch_glInvalidateNamedFramebufferSubData1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glInvalidateNamedFramebufferSubData(final int n, final int n2, final int[] array, final int n3, final int n4, final int n5, final int n6, final int n7) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"attachments_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glInvalidateNamedFramebufferSubData = this._pat._addressof_glInvalidateNamedFramebufferSubData;
        if (addressof_glInvalidateNamedFramebufferSubData == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferSubData"));
        }
        this.dispatch_glInvalidateNamedFramebufferSubData1(n, n2, array, 4 * n3, false, n4, n5, n6, n7, addressof_glInvalidateNamedFramebufferSubData);
    }
    
    @Override
    public void glClearNamedFramebufferiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glClearNamedFramebufferiv = this._pat._addressof_glClearNamedFramebufferiv;
        if (addressof_glClearNamedFramebufferiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferiv"));
        }
        this.dispatch_glClearNamedFramebufferiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glClearNamedFramebufferiv);
    }
    
    private native void dispatch_glClearNamedFramebufferiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glClearNamedFramebufferiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClearNamedFramebufferiv = this._pat._addressof_glClearNamedFramebufferiv;
        if (addressof_glClearNamedFramebufferiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferiv"));
        }
        this.dispatch_glClearNamedFramebufferiv1(n, n2, n3, array, 4 * n4, false, addressof_glClearNamedFramebufferiv);
    }
    
    @Override
    public void glClearNamedFramebufferuiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glClearNamedFramebufferuiv = this._pat._addressof_glClearNamedFramebufferuiv;
        if (addressof_glClearNamedFramebufferuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferuiv"));
        }
        this.dispatch_glClearNamedFramebufferuiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glClearNamedFramebufferuiv);
    }
    
    private native void dispatch_glClearNamedFramebufferuiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glClearNamedFramebufferuiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClearNamedFramebufferuiv = this._pat._addressof_glClearNamedFramebufferuiv;
        if (addressof_glClearNamedFramebufferuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferuiv"));
        }
        this.dispatch_glClearNamedFramebufferuiv1(n, n2, n3, array, 4 * n4, false, addressof_glClearNamedFramebufferuiv);
    }
    
    @Override
    public void glClearNamedFramebufferfv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glClearNamedFramebufferfv = this._pat._addressof_glClearNamedFramebufferfv;
        if (addressof_glClearNamedFramebufferfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferfv"));
        }
        this.dispatch_glClearNamedFramebufferfv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glClearNamedFramebufferfv);
    }
    
    private native void dispatch_glClearNamedFramebufferfv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glClearNamedFramebufferfv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClearNamedFramebufferfv = this._pat._addressof_glClearNamedFramebufferfv;
        if (addressof_glClearNamedFramebufferfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferfv"));
        }
        this.dispatch_glClearNamedFramebufferfv1(n, n2, n3, array, 4 * n4, false, addressof_glClearNamedFramebufferfv);
    }
    
    @Override
    public void glClearNamedFramebufferfi(final int n, final int n2, final float n3, final int n4) {
        final long addressof_glClearNamedFramebufferfi = this._pat._addressof_glClearNamedFramebufferfi;
        if (addressof_glClearNamedFramebufferfi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferfi"));
        }
        this.dispatch_glClearNamedFramebufferfi1(n, n2, n3, n4, addressof_glClearNamedFramebufferfi);
    }
    
    private native void dispatch_glClearNamedFramebufferfi1(final int p0, final int p1, final float p2, final int p3, final long p4);
    
    @Override
    public void glBlitNamedFramebuffer(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final int n12) {
        final long addressof_glBlitNamedFramebuffer = this._pat._addressof_glBlitNamedFramebuffer;
        if (addressof_glBlitNamedFramebuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlitNamedFramebuffer"));
        }
        this.dispatch_glBlitNamedFramebuffer1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, addressof_glBlitNamedFramebuffer);
    }
    
    private native void dispatch_glBlitNamedFramebuffer1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final int p11, final long p12);
    
    @Override
    public int glCheckNamedFramebufferStatus(final int n, final int n2) {
        final long addressof_glCheckNamedFramebufferStatus = this._pat._addressof_glCheckNamedFramebufferStatus;
        if (addressof_glCheckNamedFramebufferStatus == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCheckNamedFramebufferStatus"));
        }
        return this.dispatch_glCheckNamedFramebufferStatus1(n, n2, addressof_glCheckNamedFramebufferStatus);
    }
    
    private native int dispatch_glCheckNamedFramebufferStatus1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetNamedFramebufferParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedFramebufferParameteriv = this._pat._addressof_glGetNamedFramebufferParameteriv;
        if (addressof_glGetNamedFramebufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferParameteriv"));
        }
        this.dispatch_glGetNamedFramebufferParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedFramebufferParameteriv);
    }
    
    private native void dispatch_glGetNamedFramebufferParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedFramebufferParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedFramebufferParameteriv = this._pat._addressof_glGetNamedFramebufferParameteriv;
        if (addressof_glGetNamedFramebufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferParameteriv"));
        }
        this.dispatch_glGetNamedFramebufferParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetNamedFramebufferParameteriv);
    }
    
    @Override
    public void glGetNamedFramebufferAttachmentParameteriv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedFramebufferAttachmentParameteriv = this._pat._addressof_glGetNamedFramebufferAttachmentParameteriv;
        if (addressof_glGetNamedFramebufferAttachmentParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameteriv"));
        }
        this.dispatch_glGetNamedFramebufferAttachmentParameteriv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedFramebufferAttachmentParameteriv);
    }
    
    private native void dispatch_glGetNamedFramebufferAttachmentParameteriv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedFramebufferAttachmentParameteriv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedFramebufferAttachmentParameteriv = this._pat._addressof_glGetNamedFramebufferAttachmentParameteriv;
        if (addressof_glGetNamedFramebufferAttachmentParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameteriv"));
        }
        this.dispatch_glGetNamedFramebufferAttachmentParameteriv1(n, n2, n3, array, 4 * n4, false, addressof_glGetNamedFramebufferAttachmentParameteriv);
    }
    
    @Override
    public void glCreateRenderbuffers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateRenderbuffers = this._pat._addressof_glCreateRenderbuffers;
        if (addressof_glCreateRenderbuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateRenderbuffers"));
        }
        this.dispatch_glCreateRenderbuffers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateRenderbuffers);
    }
    
    private native void dispatch_glCreateRenderbuffers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateRenderbuffers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"renderbuffers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateRenderbuffers = this._pat._addressof_glCreateRenderbuffers;
        if (addressof_glCreateRenderbuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateRenderbuffers"));
        }
        this.dispatch_glCreateRenderbuffers1(n, array, 4 * n2, false, addressof_glCreateRenderbuffers);
    }
    
    @Override
    public void glNamedRenderbufferStorage(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glNamedRenderbufferStorage = this._pat._addressof_glNamedRenderbufferStorage;
        if (addressof_glNamedRenderbufferStorage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorage"));
        }
        this.dispatch_glNamedRenderbufferStorage1(n, n2, n3, n4, addressof_glNamedRenderbufferStorage);
    }
    
    private native void dispatch_glNamedRenderbufferStorage1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glNamedRenderbufferStorageMultisample(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glNamedRenderbufferStorageMultisample = this._pat._addressof_glNamedRenderbufferStorageMultisample;
        if (addressof_glNamedRenderbufferStorageMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageMultisample"));
        }
        this.dispatch_glNamedRenderbufferStorageMultisample1(n, n2, n3, n4, n5, addressof_glNamedRenderbufferStorageMultisample);
    }
    
    private native void dispatch_glNamedRenderbufferStorageMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glGetNamedRenderbufferParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedRenderbufferParameteriv = this._pat._addressof_glGetNamedRenderbufferParameteriv;
        if (addressof_glGetNamedRenderbufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameteriv"));
        }
        this.dispatch_glGetNamedRenderbufferParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedRenderbufferParameteriv);
    }
    
    private native void dispatch_glGetNamedRenderbufferParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedRenderbufferParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedRenderbufferParameteriv = this._pat._addressof_glGetNamedRenderbufferParameteriv;
        if (addressof_glGetNamedRenderbufferParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameteriv"));
        }
        this.dispatch_glGetNamedRenderbufferParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetNamedRenderbufferParameteriv);
    }
    
    @Override
    public void glCreateTextures(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateTextures = this._pat._addressof_glCreateTextures;
        if (addressof_glCreateTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateTextures"));
        }
        this.dispatch_glCreateTextures1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateTextures);
    }
    
    private native void dispatch_glCreateTextures1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glCreateTextures(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"textures_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateTextures = this._pat._addressof_glCreateTextures;
        if (addressof_glCreateTextures == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateTextures"));
        }
        this.dispatch_glCreateTextures1(n, n2, array, 4 * n3, false, addressof_glCreateTextures);
    }
    
    @Override
    public void glTextureBuffer(final int n, final int n2, final int n3) {
        final long addressof_glTextureBuffer = this._pat._addressof_glTextureBuffer;
        if (addressof_glTextureBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureBuffer"));
        }
        this.dispatch_glTextureBuffer1(n, n2, n3, addressof_glTextureBuffer);
    }
    
    private native void dispatch_glTextureBuffer1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTextureBufferRange(final int n, final int n2, final int n3, final long n4, final long n5) {
        final long addressof_glTextureBufferRange = this._pat._addressof_glTextureBufferRange;
        if (addressof_glTextureBufferRange == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureBufferRange"));
        }
        this.dispatch_glTextureBufferRange1(n, n2, n3, n4, n5, addressof_glTextureBufferRange);
    }
    
    private native void dispatch_glTextureBufferRange1(final int p0, final int p1, final int p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glTextureStorage1D(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glTextureStorage1D = this._pat._addressof_glTextureStorage1D;
        if (addressof_glTextureStorage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage1D"));
        }
        this.dispatch_glTextureStorage1D1(n, n2, n3, n4, addressof_glTextureStorage1D);
    }
    
    private native void dispatch_glTextureStorage1D1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glTextureStorage2D(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glTextureStorage2D = this._pat._addressof_glTextureStorage2D;
        if (addressof_glTextureStorage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2D"));
        }
        this.dispatch_glTextureStorage2D1(n, n2, n3, n4, n5, addressof_glTextureStorage2D);
    }
    
    private native void dispatch_glTextureStorage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glTextureStorage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glTextureStorage3D = this._pat._addressof_glTextureStorage3D;
        if (addressof_glTextureStorage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3D"));
        }
        this.dispatch_glTextureStorage3D1(n, n2, n3, n4, n5, n6, addressof_glTextureStorage3D);
    }
    
    private native void dispatch_glTextureStorage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glTextureStorage2DMultisample(final int n, final int n2, final int n3, final int n4, final int n5, final boolean b) {
        final long addressof_glTextureStorage2DMultisample = this._pat._addressof_glTextureStorage2DMultisample;
        if (addressof_glTextureStorage2DMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DMultisample"));
        }
        this.dispatch_glTextureStorage2DMultisample1(n, n2, n3, n4, n5, b, addressof_glTextureStorage2DMultisample);
    }
    
    private native void dispatch_glTextureStorage2DMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTextureStorage3DMultisample(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final boolean b) {
        final long addressof_glTextureStorage3DMultisample = this._pat._addressof_glTextureStorage3DMultisample;
        if (addressof_glTextureStorage3DMultisample == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DMultisample"));
        }
        this.dispatch_glTextureStorage3DMultisample1(n, n2, n3, n4, n5, n6, b, addressof_glTextureStorage3DMultisample);
    }
    
    private native void dispatch_glTextureStorage3DMultisample1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glTextureSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n5, n6, n4, 1, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureSubImage1D = this._pat._addressof_glTextureSubImage1D;
        if (addressof_glTextureSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1D"));
        }
        this.dispatch_glTextureSubImage1D1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureSubImage1D);
    }
    
    private native void dispatch_glTextureSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glTextureSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureSubImage1D = this._pat._addressof_glTextureSubImage1D;
        if (addressof_glTextureSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1D"));
        }
        this.dispatch_glTextureSubImage1D1(n, n2, n3, n4, n5, n6, n7, addressof_glTextureSubImage1D);
    }
    
    private native void dispatch_glTextureSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glTextureSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n7, n8, n5, n6, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureSubImage2D = this._pat._addressof_glTextureSubImage2D;
        if (addressof_glTextureSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2D"));
        }
        this.dispatch_glTextureSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureSubImage2D);
    }
    
    private native void dispatch_glTextureSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glTextureSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final long n9) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureSubImage2D = this._pat._addressof_glTextureSubImage2D;
        if (addressof_glTextureSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2D"));
        }
        this.dispatch_glTextureSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glTextureSubImage2D);
    }
    
    private native void dispatch_glTextureSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8, final long p9);
    
    @Override
    public void glTextureSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n9, n10, n6, n7, n8, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureSubImage3D = this._pat._addressof_glTextureSubImage3D;
        if (addressof_glTextureSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3D"));
        }
        this.dispatch_glTextureSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureSubImage3D);
    }
    
    private native void dispatch_glTextureSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glTextureSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final long n11) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureSubImage3D = this._pat._addressof_glTextureSubImage3D;
        if (addressof_glTextureSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3D"));
        }
        this.dispatch_glTextureSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, addressof_glTextureSubImage3D);
    }
    
    private native void dispatch_glTextureSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final long p10, final long p11);
    
    @Override
    public void glCompressedTextureSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureSubImage1D = this._pat._addressof_glCompressedTextureSubImage1D;
        if (addressof_glCompressedTextureSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage1D"));
        }
        this.dispatch_glCompressedTextureSubImage1D1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureSubImage1D);
    }
    
    private native void dispatch_glCompressedTextureSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glCompressedTextureSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureSubImage2D = this._pat._addressof_glCompressedTextureSubImage2D;
        if (addressof_glCompressedTextureSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage2D"));
        }
        this.dispatch_glCompressedTextureSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureSubImage2D);
    }
    
    private native void dispatch_glCompressedTextureSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glCompressedTextureSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureSubImage3D = this._pat._addressof_glCompressedTextureSubImage3D;
        if (addressof_glCompressedTextureSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage3D"));
        }
        this.dispatch_glCompressedTextureSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureSubImage3D);
    }
    
    private native void dispatch_glCompressedTextureSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glCopyTextureSubImage1D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glCopyTextureSubImage1D = this._pat._addressof_glCopyTextureSubImage1D;
        if (addressof_glCopyTextureSubImage1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage1D"));
        }
        this.dispatch_glCopyTextureSubImage1D1(n, n2, n3, n4, n5, n6, addressof_glCopyTextureSubImage1D);
    }
    
    private native void dispatch_glCopyTextureSubImage1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glCopyTextureSubImage2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glCopyTextureSubImage2D = this._pat._addressof_glCopyTextureSubImage2D;
        if (addressof_glCopyTextureSubImage2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage2D"));
        }
        this.dispatch_glCopyTextureSubImage2D1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glCopyTextureSubImage2D);
    }
    
    private native void dispatch_glCopyTextureSubImage2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glCopyTextureSubImage3D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9) {
        final long addressof_glCopyTextureSubImage3D = this._pat._addressof_glCopyTextureSubImage3D;
        if (addressof_glCopyTextureSubImage3D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage3D"));
        }
        this.dispatch_glCopyTextureSubImage3D1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCopyTextureSubImage3D);
    }
    
    private native void dispatch_glCopyTextureSubImage3D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glTextureParameterf(final int n, final int n2, final float n3) {
        final long addressof_glTextureParameterf = this._pat._addressof_glTextureParameterf;
        if (addressof_glTextureParameterf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterf"));
        }
        this.dispatch_glTextureParameterf1(n, n2, n3, addressof_glTextureParameterf);
    }
    
    private native void dispatch_glTextureParameterf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glTextureParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTextureParameterfv = this._pat._addressof_glTextureParameterfv;
        if (addressof_glTextureParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfv"));
        }
        this.dispatch_glTextureParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTextureParameterfv);
    }
    
    private native void dispatch_glTextureParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTextureParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameterfv = this._pat._addressof_glTextureParameterfv;
        if (addressof_glTextureParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfv"));
        }
        this.dispatch_glTextureParameterfv1(n, n2, array, 4 * n3, false, addressof_glTextureParameterfv);
    }
    
    @Override
    public void glTextureParameteri(final int n, final int n2, final int n3) {
        final long addressof_glTextureParameteri = this._pat._addressof_glTextureParameteri;
        if (addressof_glTextureParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteri"));
        }
        this.dispatch_glTextureParameteri1(n, n2, n3, addressof_glTextureParameteri);
    }
    
    private native void dispatch_glTextureParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glTextureParameterIiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTextureParameterIiv = this._pat._addressof_glTextureParameterIiv;
        if (addressof_glTextureParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIiv"));
        }
        this.dispatch_glTextureParameterIiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTextureParameterIiv);
    }
    
    private native void dispatch_glTextureParameterIiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTextureParameterIiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameterIiv = this._pat._addressof_glTextureParameterIiv;
        if (addressof_glTextureParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIiv"));
        }
        this.dispatch_glTextureParameterIiv1(n, n2, array, 4 * n3, false, addressof_glTextureParameterIiv);
    }
    
    @Override
    public void glTextureParameterIuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTextureParameterIuiv = this._pat._addressof_glTextureParameterIuiv;
        if (addressof_glTextureParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuiv"));
        }
        this.dispatch_glTextureParameterIuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTextureParameterIuiv);
    }
    
    private native void dispatch_glTextureParameterIuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTextureParameterIuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameterIuiv = this._pat._addressof_glTextureParameterIuiv;
        if (addressof_glTextureParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuiv"));
        }
        this.dispatch_glTextureParameterIuiv1(n, n2, array, 4 * n3, false, addressof_glTextureParameterIuiv);
    }
    
    @Override
    public void glTextureParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTextureParameteriv = this._pat._addressof_glTextureParameteriv;
        if (addressof_glTextureParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteriv"));
        }
        this.dispatch_glTextureParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTextureParameteriv);
    }
    
    private native void dispatch_glTextureParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glTextureParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameteriv = this._pat._addressof_glTextureParameteriv;
        if (addressof_glTextureParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteriv"));
        }
        this.dispatch_glTextureParameteriv1(n, n2, array, 4 * n3, false, addressof_glTextureParameteriv);
    }
    
    @Override
    public void glGenerateTextureMipmap(final int n) {
        final long addressof_glGenerateTextureMipmap = this._pat._addressof_glGenerateTextureMipmap;
        if (addressof_glGenerateTextureMipmap == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenerateTextureMipmap"));
        }
        this.dispatch_glGenerateTextureMipmap1(n, addressof_glGenerateTextureMipmap);
    }
    
    private native void dispatch_glGenerateTextureMipmap1(final int p0, final long p1);
    
    @Override
    public void glBindTextureUnit(final int n, final int n2) {
        final long addressof_glBindTextureUnit = this._pat._addressof_glBindTextureUnit;
        if (addressof_glBindTextureUnit == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTextureUnit"));
        }
        this.dispatch_glBindTextureUnit1(n, n2, addressof_glBindTextureUnit);
    }
    
    private native void dispatch_glBindTextureUnit1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetTextureImage(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetTextureImage = this._pat._addressof_glGetTextureImage;
        if (addressof_glGetTextureImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureImage"));
        }
        this.dispatch_glGetTextureImage1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetTextureImage);
    }
    
    private native void dispatch_glGetTextureImage1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetCompressedTextureImage(final int n, final int n2, final int n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetCompressedTextureImage = this._pat._addressof_glGetCompressedTextureImage;
        if (addressof_glGetCompressedTextureImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTextureImage"));
        }
        this.dispatch_glGetCompressedTextureImage1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetCompressedTextureImage);
    }
    
    private native void dispatch_glGetCompressedTextureImage1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTextureLevelParameterfv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTextureLevelParameterfv = this._pat._addressof_glGetTextureLevelParameterfv;
        if (addressof_glGetTextureLevelParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfv"));
        }
        this.dispatch_glGetTextureLevelParameterfv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTextureLevelParameterfv);
    }
    
    private native void dispatch_glGetTextureLevelParameterfv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTextureLevelParameterfv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureLevelParameterfv = this._pat._addressof_glGetTextureLevelParameterfv;
        if (addressof_glGetTextureLevelParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfv"));
        }
        this.dispatch_glGetTextureLevelParameterfv1(n, n2, n3, array, 4 * n4, false, addressof_glGetTextureLevelParameterfv);
    }
    
    @Override
    public void glGetTextureLevelParameteriv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureLevelParameteriv = this._pat._addressof_glGetTextureLevelParameteriv;
        if (addressof_glGetTextureLevelParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameteriv"));
        }
        this.dispatch_glGetTextureLevelParameteriv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureLevelParameteriv);
    }
    
    private native void dispatch_glGetTextureLevelParameteriv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTextureLevelParameteriv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureLevelParameteriv = this._pat._addressof_glGetTextureLevelParameteriv;
        if (addressof_glGetTextureLevelParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameteriv"));
        }
        this.dispatch_glGetTextureLevelParameteriv1(n, n2, n3, array, 4 * n4, false, addressof_glGetTextureLevelParameteriv);
    }
    
    @Override
    public void glGetTextureParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTextureParameterfv = this._pat._addressof_glGetTextureParameterfv;
        if (addressof_glGetTextureParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfv"));
        }
        this.dispatch_glGetTextureParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTextureParameterfv);
    }
    
    private native void dispatch_glGetTextureParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTextureParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameterfv = this._pat._addressof_glGetTextureParameterfv;
        if (addressof_glGetTextureParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfv"));
        }
        this.dispatch_glGetTextureParameterfv1(n, n2, array, 4 * n3, false, addressof_glGetTextureParameterfv);
    }
    
    @Override
    public void glGetTextureParameterIiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureParameterIiv = this._pat._addressof_glGetTextureParameterIiv;
        if (addressof_glGetTextureParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIiv"));
        }
        this.dispatch_glGetTextureParameterIiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureParameterIiv);
    }
    
    private native void dispatch_glGetTextureParameterIiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTextureParameterIiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameterIiv = this._pat._addressof_glGetTextureParameterIiv;
        if (addressof_glGetTextureParameterIiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIiv"));
        }
        this.dispatch_glGetTextureParameterIiv1(n, n2, array, 4 * n3, false, addressof_glGetTextureParameterIiv);
    }
    
    @Override
    public void glGetTextureParameterIuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureParameterIuiv = this._pat._addressof_glGetTextureParameterIuiv;
        if (addressof_glGetTextureParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuiv"));
        }
        this.dispatch_glGetTextureParameterIuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureParameterIuiv);
    }
    
    private native void dispatch_glGetTextureParameterIuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTextureParameterIuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameterIuiv = this._pat._addressof_glGetTextureParameterIuiv;
        if (addressof_glGetTextureParameterIuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuiv"));
        }
        this.dispatch_glGetTextureParameterIuiv1(n, n2, array, 4 * n3, false, addressof_glGetTextureParameterIuiv);
    }
    
    @Override
    public void glGetTextureParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureParameteriv = this._pat._addressof_glGetTextureParameteriv;
        if (addressof_glGetTextureParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameteriv"));
        }
        this.dispatch_glGetTextureParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureParameteriv);
    }
    
    private native void dispatch_glGetTextureParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetTextureParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameteriv = this._pat._addressof_glGetTextureParameteriv;
        if (addressof_glGetTextureParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameteriv"));
        }
        this.dispatch_glGetTextureParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetTextureParameteriv);
    }
    
    @Override
    public void glCreateVertexArrays(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateVertexArrays = this._pat._addressof_glCreateVertexArrays;
        if (addressof_glCreateVertexArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateVertexArrays"));
        }
        this.dispatch_glCreateVertexArrays1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateVertexArrays);
    }
    
    private native void dispatch_glCreateVertexArrays1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateVertexArrays(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"arrays_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateVertexArrays = this._pat._addressof_glCreateVertexArrays;
        if (addressof_glCreateVertexArrays == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateVertexArrays"));
        }
        this.dispatch_glCreateVertexArrays1(n, array, 4 * n2, false, addressof_glCreateVertexArrays);
    }
    
    @Override
    public void glDisableVertexArrayAttrib(final int n, final int n2) {
        final long addressof_glDisableVertexArrayAttrib = this._pat._addressof_glDisableVertexArrayAttrib;
        if (addressof_glDisableVertexArrayAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexArrayAttrib"));
        }
        this.dispatch_glDisableVertexArrayAttrib1(n, n2, addressof_glDisableVertexArrayAttrib);
    }
    
    private native void dispatch_glDisableVertexArrayAttrib1(final int p0, final int p1, final long p2);
    
    @Override
    public void glEnableVertexArrayAttrib(final int n, final int n2) {
        final long addressof_glEnableVertexArrayAttrib = this._pat._addressof_glEnableVertexArrayAttrib;
        if (addressof_glEnableVertexArrayAttrib == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexArrayAttrib"));
        }
        this.dispatch_glEnableVertexArrayAttrib1(n, n2, addressof_glEnableVertexArrayAttrib);
    }
    
    private native void dispatch_glEnableVertexArrayAttrib1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexArrayElementBuffer(final int n, final int n2) {
        final long addressof_glVertexArrayElementBuffer = this._pat._addressof_glVertexArrayElementBuffer;
        if (addressof_glVertexArrayElementBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayElementBuffer"));
        }
        this.dispatch_glVertexArrayElementBuffer1(n, n2, addressof_glVertexArrayElementBuffer);
    }
    
    private native void dispatch_glVertexArrayElementBuffer1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexArrayVertexBuffer(final int n, final int n2, final int n3, final long n4, final int n5) {
        final long addressof_glVertexArrayVertexBuffer = this._pat._addressof_glVertexArrayVertexBuffer;
        if (addressof_glVertexArrayVertexBuffer == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBuffer"));
        }
        this.dispatch_glVertexArrayVertexBuffer1(n, n2, n3, n4, n5, addressof_glVertexArrayVertexBuffer);
    }
    
    private native void dispatch_glVertexArrayVertexBuffer1(final int p0, final int p1, final int p2, final long p3, final int p4, final long p5);
    
    @Override
    public void glVertexArrayVertexBuffers(final int n, final int n2, final int n3, final IntBuffer intBuffer, final PointerBuffer pointerBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(pointerBuffer);
        final boolean direct3 = Buffers.isDirect(intBuffer2);
        final long addressof_glVertexArrayVertexBuffers = this._pat._addressof_glVertexArrayVertexBuffers;
        if (addressof_glVertexArrayVertexBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBuffers"));
        }
        this.dispatch_glVertexArrayVertexBuffers1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct2 ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct2, direct3 ? intBuffer2 : Buffers.getArray(intBuffer2), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct3, addressof_glVertexArrayVertexBuffers);
    }
    
    private native void dispatch_glVertexArrayVertexBuffers1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glVertexArrayVertexBuffers(final int n, final int n2, final int n3, final int[] array, final int n4, final PointerBuffer pointerBuffer, final int[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"buffers_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final boolean direct = Buffers.isDirect(pointerBuffer);
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"strides_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glVertexArrayVertexBuffers = this._pat._addressof_glVertexArrayVertexBuffers;
        if (addressof_glVertexArrayVertexBuffers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBuffers"));
        }
        this.dispatch_glVertexArrayVertexBuffers1(n, n2, n3, array, 4 * n4, false, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, array2, 4 * n5, false, addressof_glVertexArrayVertexBuffers);
    }
    
    @Override
    public void glVertexArrayAttribBinding(final int n, final int n2, final int n3) {
        final long addressof_glVertexArrayAttribBinding = this._pat._addressof_glVertexArrayAttribBinding;
        if (addressof_glVertexArrayAttribBinding == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribBinding"));
        }
        this.dispatch_glVertexArrayAttribBinding1(n, n2, n3, addressof_glVertexArrayAttribBinding);
    }
    
    private native void dispatch_glVertexArrayAttribBinding1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexArrayAttribFormat(final int n, final int n2, final int n3, final int n4, final boolean b, final int n5) {
        final long addressof_glVertexArrayAttribFormat = this._pat._addressof_glVertexArrayAttribFormat;
        if (addressof_glVertexArrayAttribFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribFormat"));
        }
        this.dispatch_glVertexArrayAttribFormat1(n, n2, n3, n4, b, n5, addressof_glVertexArrayAttribFormat);
    }
    
    private native void dispatch_glVertexArrayAttribFormat1(final int p0, final int p1, final int p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glVertexArrayAttribIFormat(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexArrayAttribIFormat = this._pat._addressof_glVertexArrayAttribIFormat;
        if (addressof_glVertexArrayAttribIFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribIFormat"));
        }
        this.dispatch_glVertexArrayAttribIFormat1(n, n2, n3, n4, n5, addressof_glVertexArrayAttribIFormat);
    }
    
    private native void dispatch_glVertexArrayAttribIFormat1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexArrayAttribLFormat(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexArrayAttribLFormat = this._pat._addressof_glVertexArrayAttribLFormat;
        if (addressof_glVertexArrayAttribLFormat == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribLFormat"));
        }
        this.dispatch_glVertexArrayAttribLFormat1(n, n2, n3, n4, n5, addressof_glVertexArrayAttribLFormat);
    }
    
    private native void dispatch_glVertexArrayAttribLFormat1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexArrayBindingDivisor(final int n, final int n2, final int n3) {
        final long addressof_glVertexArrayBindingDivisor = this._pat._addressof_glVertexArrayBindingDivisor;
        if (addressof_glVertexArrayBindingDivisor == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayBindingDivisor"));
        }
        this.dispatch_glVertexArrayBindingDivisor1(n, n2, n3, addressof_glVertexArrayBindingDivisor);
    }
    
    private native void dispatch_glVertexArrayBindingDivisor1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glGetVertexArrayiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexArrayiv = this._pat._addressof_glGetVertexArrayiv;
        if (addressof_glGetVertexArrayiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayiv"));
        }
        this.dispatch_glGetVertexArrayiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexArrayiv);
    }
    
    private native void dispatch_glGetVertexArrayiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexArrayiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexArrayiv = this._pat._addressof_glGetVertexArrayiv;
        if (addressof_glGetVertexArrayiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayiv"));
        }
        this.dispatch_glGetVertexArrayiv1(n, n2, array, 4 * n3, false, addressof_glGetVertexArrayiv);
    }
    
    @Override
    public void glGetVertexArrayIndexediv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexArrayIndexediv = this._pat._addressof_glGetVertexArrayIndexediv;
        if (addressof_glGetVertexArrayIndexediv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexediv"));
        }
        this.dispatch_glGetVertexArrayIndexediv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexArrayIndexediv);
    }
    
    private native void dispatch_glGetVertexArrayIndexediv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetVertexArrayIndexediv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"param_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexArrayIndexediv = this._pat._addressof_glGetVertexArrayIndexediv;
        if (addressof_glGetVertexArrayIndexediv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexediv"));
        }
        this.dispatch_glGetVertexArrayIndexediv1(n, n2, n3, array, 4 * n4, false, addressof_glGetVertexArrayIndexediv);
    }
    
    @Override
    public void glGetVertexArrayIndexed64iv(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetVertexArrayIndexed64iv = this._pat._addressof_glGetVertexArrayIndexed64iv;
        if (addressof_glGetVertexArrayIndexed64iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexed64iv"));
        }
        this.dispatch_glGetVertexArrayIndexed64iv1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetVertexArrayIndexed64iv);
    }
    
    private native void dispatch_glGetVertexArrayIndexed64iv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetVertexArrayIndexed64iv(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"param_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexArrayIndexed64iv = this._pat._addressof_glGetVertexArrayIndexed64iv;
        if (addressof_glGetVertexArrayIndexed64iv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexed64iv"));
        }
        this.dispatch_glGetVertexArrayIndexed64iv1(n, n2, n3, array, 8 * n4, false, addressof_glGetVertexArrayIndexed64iv);
    }
    
    @Override
    public void glCreateSamplers(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateSamplers = this._pat._addressof_glCreateSamplers;
        if (addressof_glCreateSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateSamplers"));
        }
        this.dispatch_glCreateSamplers1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateSamplers);
    }
    
    private native void dispatch_glCreateSamplers1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateSamplers(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"samplers_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateSamplers = this._pat._addressof_glCreateSamplers;
        if (addressof_glCreateSamplers == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateSamplers"));
        }
        this.dispatch_glCreateSamplers1(n, array, 4 * n2, false, addressof_glCreateSamplers);
    }
    
    @Override
    public void glCreateProgramPipelines(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateProgramPipelines = this._pat._addressof_glCreateProgramPipelines;
        if (addressof_glCreateProgramPipelines == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateProgramPipelines"));
        }
        this.dispatch_glCreateProgramPipelines1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateProgramPipelines);
    }
    
    private native void dispatch_glCreateProgramPipelines1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateProgramPipelines(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"pipelines_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateProgramPipelines = this._pat._addressof_glCreateProgramPipelines;
        if (addressof_glCreateProgramPipelines == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateProgramPipelines"));
        }
        this.dispatch_glCreateProgramPipelines1(n, array, 4 * n2, false, addressof_glCreateProgramPipelines);
    }
    
    @Override
    public void glCreateQueries(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateQueries = this._pat._addressof_glCreateQueries;
        if (addressof_glCreateQueries == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateQueries"));
        }
        this.dispatch_glCreateQueries1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateQueries);
    }
    
    private native void dispatch_glCreateQueries1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glCreateQueries(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"ids_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateQueries = this._pat._addressof_glCreateQueries;
        if (addressof_glCreateQueries == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateQueries"));
        }
        this.dispatch_glCreateQueries1(n, n2, array, 4 * n3, false, addressof_glCreateQueries);
    }
    
    @Override
    public void glGetQueryBufferObjecti64v(final int n, final int n2, final int n3, final long n4) {
        final long addressof_glGetQueryBufferObjecti64v = this._pat._addressof_glGetQueryBufferObjecti64v;
        if (addressof_glGetQueryBufferObjecti64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjecti64v"));
        }
        this.dispatch_glGetQueryBufferObjecti64v1(n, n2, n3, n4, addressof_glGetQueryBufferObjecti64v);
    }
    
    private native void dispatch_glGetQueryBufferObjecti64v1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glGetQueryBufferObjectiv(final int n, final int n2, final int n3, final long n4) {
        final long addressof_glGetQueryBufferObjectiv = this._pat._addressof_glGetQueryBufferObjectiv;
        if (addressof_glGetQueryBufferObjectiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjectiv"));
        }
        this.dispatch_glGetQueryBufferObjectiv1(n, n2, n3, n4, addressof_glGetQueryBufferObjectiv);
    }
    
    private native void dispatch_glGetQueryBufferObjectiv1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glGetQueryBufferObjectui64v(final int n, final int n2, final int n3, final long n4) {
        final long addressof_glGetQueryBufferObjectui64v = this._pat._addressof_glGetQueryBufferObjectui64v;
        if (addressof_glGetQueryBufferObjectui64v == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjectui64v"));
        }
        this.dispatch_glGetQueryBufferObjectui64v1(n, n2, n3, n4, addressof_glGetQueryBufferObjectui64v);
    }
    
    private native void dispatch_glGetQueryBufferObjectui64v1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glGetQueryBufferObjectuiv(final int n, final int n2, final int n3, final long n4) {
        final long addressof_glGetQueryBufferObjectuiv = this._pat._addressof_glGetQueryBufferObjectuiv;
        if (addressof_glGetQueryBufferObjectuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjectuiv"));
        }
        this.dispatch_glGetQueryBufferObjectuiv1(n, n2, n3, n4, addressof_glGetQueryBufferObjectuiv);
    }
    
    private native void dispatch_glGetQueryBufferObjectuiv1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glMemoryBarrierByRegion(final int n) {
        final long addressof_glMemoryBarrierByRegion = this._pat._addressof_glMemoryBarrierByRegion;
        if (addressof_glMemoryBarrierByRegion == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMemoryBarrierByRegion"));
        }
        this.dispatch_glMemoryBarrierByRegion1(n, addressof_glMemoryBarrierByRegion);
    }
    
    private native void dispatch_glMemoryBarrierByRegion1(final int p0, final long p1);
    
    @Override
    public void glGetTextureSubImage(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetTextureSubImage = this._pat._addressof_glGetTextureSubImage;
        if (addressof_glGetTextureSubImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureSubImage"));
        }
        this.dispatch_glGetTextureSubImage1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetTextureSubImage);
    }
    
    private native void dispatch_glGetTextureSubImage1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final Object p11, final int p12, final boolean p13, final long p14);
    
    @Override
    public void glGetCompressedTextureSubImage(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetCompressedTextureSubImage = this._pat._addressof_glGetCompressedTextureSubImage;
        if (addressof_glGetCompressedTextureSubImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTextureSubImage"));
        }
        this.dispatch_glGetCompressedTextureSubImage1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetCompressedTextureSubImage);
    }
    
    private native void dispatch_glGetCompressedTextureSubImage1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public int glGetGraphicsResetStatus() {
        final long addressof_glGetGraphicsResetStatus = this._pat._addressof_glGetGraphicsResetStatus;
        if (addressof_glGetGraphicsResetStatus == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetGraphicsResetStatus"));
        }
        return this.dispatch_glGetGraphicsResetStatus1(addressof_glGetGraphicsResetStatus);
    }
    
    private native int dispatch_glGetGraphicsResetStatus1(final long p0);
    
    @Override
    public void glGetnCompressedTexImage(final int n, final int n2, final int n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetnCompressedTexImage = this._pat._addressof_glGetnCompressedTexImage;
        if (addressof_glGetnCompressedTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnCompressedTexImage"));
        }
        this.dispatch_glGetnCompressedTexImage1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetnCompressedTexImage);
    }
    
    private native void dispatch_glGetnCompressedTexImage1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnTexImage(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetnTexImage = this._pat._addressof_glGetnTexImage;
        if (addressof_glGetnTexImage == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnTexImage"));
        }
        this.dispatch_glGetnTexImage1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetnTexImage);
    }
    
    private native void dispatch_glGetnTexImage1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetnUniformdv(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetnUniformdv = this._pat._addressof_glGetnUniformdv;
        if (addressof_glGetnUniformdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformdv"));
        }
        this.dispatch_glGetnUniformdv1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetnUniformdv);
    }
    
    private native void dispatch_glGetnUniformdv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnUniformdv(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnUniformdv = this._pat._addressof_glGetnUniformdv;
        if (addressof_glGetnUniformdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformdv"));
        }
        this.dispatch_glGetnUniformdv1(n, n2, n3, array, 8 * n4, false, addressof_glGetnUniformdv);
    }
    
    @Override
    public void glGetnUniformfv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetnUniformfv = this._pat._addressof_glGetnUniformfv;
        if (addressof_glGetnUniformfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
        }
        this.dispatch_glGetnUniformfv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetnUniformfv);
    }
    
    private native void dispatch_glGetnUniformfv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnUniformfv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnUniformfv = this._pat._addressof_glGetnUniformfv;
        if (addressof_glGetnUniformfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
        }
        this.dispatch_glGetnUniformfv1(n, n2, n3, array, 4 * n4, false, addressof_glGetnUniformfv);
    }
    
    @Override
    public void glGetnUniformiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetnUniformiv = this._pat._addressof_glGetnUniformiv;
        if (addressof_glGetnUniformiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
        }
        this.dispatch_glGetnUniformiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetnUniformiv);
    }
    
    private native void dispatch_glGetnUniformiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnUniformiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnUniformiv = this._pat._addressof_glGetnUniformiv;
        if (addressof_glGetnUniformiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
        }
        this.dispatch_glGetnUniformiv1(n, n2, n3, array, 4 * n4, false, addressof_glGetnUniformiv);
    }
    
    @Override
    public void glGetnUniformuiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetnUniformuiv = this._pat._addressof_glGetnUniformuiv;
        if (addressof_glGetnUniformuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformuiv"));
        }
        this.dispatch_glGetnUniformuiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetnUniformuiv);
    }
    
    private native void dispatch_glGetnUniformuiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnUniformuiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnUniformuiv = this._pat._addressof_glGetnUniformuiv;
        if (addressof_glGetnUniformuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformuiv"));
        }
        this.dispatch_glGetnUniformuiv1(n, n2, n3, array, 4 * n4, false, addressof_glGetnUniformuiv);
    }
    
    @Override
    public void glReadnPixels(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glReadnPixels = this._pat._addressof_glReadnPixels;
        if (addressof_glReadnPixels == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glReadnPixels"));
        }
        this.dispatch_glReadnPixels1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glReadnPixels);
    }
    
    private native void dispatch_glReadnPixels1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glGetnMapdv(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetnMapdv = this._pat._addressof_glGetnMapdv;
        if (addressof_glGetnMapdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnMapdv"));
        }
        this.dispatch_glGetnMapdv1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetnMapdv);
    }
    
    private native void dispatch_glGetnMapdv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnMapdv(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"v_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnMapdv = this._pat._addressof_glGetnMapdv;
        if (addressof_glGetnMapdv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnMapdv"));
        }
        this.dispatch_glGetnMapdv1(n, n2, n3, array, 8 * n4, false, addressof_glGetnMapdv);
    }
    
    @Override
    public void glGetnMapfv(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetnMapfv = this._pat._addressof_glGetnMapfv;
        if (addressof_glGetnMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnMapfv"));
        }
        this.dispatch_glGetnMapfv1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetnMapfv);
    }
    
    private native void dispatch_glGetnMapfv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnMapfv(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"v_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnMapfv = this._pat._addressof_glGetnMapfv;
        if (addressof_glGetnMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnMapfv"));
        }
        this.dispatch_glGetnMapfv1(n, n2, n3, array, 4 * n4, false, addressof_glGetnMapfv);
    }
    
    @Override
    public void glGetnMapiv(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetnMapiv = this._pat._addressof_glGetnMapiv;
        if (addressof_glGetnMapiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnMapiv"));
        }
        this.dispatch_glGetnMapiv1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetnMapiv);
    }
    
    private native void dispatch_glGetnMapiv1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnMapiv(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"v_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnMapiv = this._pat._addressof_glGetnMapiv;
        if (addressof_glGetnMapiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnMapiv"));
        }
        this.dispatch_glGetnMapiv1(n, n2, n3, array, 4 * n4, false, addressof_glGetnMapiv);
    }
    
    @Override
    public void glGetnPixelMapfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetnPixelMapfv = this._pat._addressof_glGetnPixelMapfv;
        if (addressof_glGetnPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapfv"));
        }
        this.dispatch_glGetnPixelMapfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetnPixelMapfv);
    }
    
    private native void dispatch_glGetnPixelMapfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetnPixelMapfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"values_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnPixelMapfv = this._pat._addressof_glGetnPixelMapfv;
        if (addressof_glGetnPixelMapfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapfv"));
        }
        this.dispatch_glGetnPixelMapfv1(n, n2, array, 4 * n3, false, addressof_glGetnPixelMapfv);
    }
    
    @Override
    public void glGetnPixelMapuiv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetnPixelMapuiv = this._pat._addressof_glGetnPixelMapuiv;
        if (addressof_glGetnPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapuiv"));
        }
        this.dispatch_glGetnPixelMapuiv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetnPixelMapuiv);
    }
    
    private native void dispatch_glGetnPixelMapuiv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetnPixelMapuiv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"values_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnPixelMapuiv = this._pat._addressof_glGetnPixelMapuiv;
        if (addressof_glGetnPixelMapuiv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapuiv"));
        }
        this.dispatch_glGetnPixelMapuiv1(n, n2, array, 4 * n3, false, addressof_glGetnPixelMapuiv);
    }
    
    @Override
    public void glGetnPixelMapusv(final int n, final int n2, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glGetnPixelMapusv = this._pat._addressof_glGetnPixelMapusv;
        if (addressof_glGetnPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapusv"));
        }
        this.dispatch_glGetnPixelMapusv1(n, n2, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glGetnPixelMapusv);
    }
    
    private native void dispatch_glGetnPixelMapusv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetnPixelMapusv(final int n, final int n2, final short[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"values_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnPixelMapusv = this._pat._addressof_glGetnPixelMapusv;
        if (addressof_glGetnPixelMapusv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapusv"));
        }
        this.dispatch_glGetnPixelMapusv1(n, n2, array, 2 * n3, false, addressof_glGetnPixelMapusv);
    }
    
    @Override
    public void glGetnPolygonStipple(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetnPolygonStipple = this._pat._addressof_glGetnPolygonStipple;
        if (addressof_glGetnPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPolygonStipple"));
        }
        this.dispatch_glGetnPolygonStipple1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetnPolygonStipple);
    }
    
    private native void dispatch_glGetnPolygonStipple1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetnPolygonStipple(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"pattern_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnPolygonStipple = this._pat._addressof_glGetnPolygonStipple;
        if (addressof_glGetnPolygonStipple == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnPolygonStipple"));
        }
        this.dispatch_glGetnPolygonStipple1(n, array, n2, false, addressof_glGetnPolygonStipple);
    }
    
    @Override
    public void glGetnColorTable(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetnColorTable = this._pat._addressof_glGetnColorTable;
        if (addressof_glGetnColorTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnColorTable"));
        }
        this.dispatch_glGetnColorTable1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetnColorTable);
    }
    
    private native void dispatch_glGetnColorTable1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetnConvolutionFilter(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetnConvolutionFilter = this._pat._addressof_glGetnConvolutionFilter;
        if (addressof_glGetnConvolutionFilter == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnConvolutionFilter"));
        }
        this.dispatch_glGetnConvolutionFilter1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetnConvolutionFilter);
    }
    
    private native void dispatch_glGetnConvolutionFilter1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetnSeparableFilter(final int n, final int n2, final int n3, final int n4, final Buffer buffer, final int n5, final Buffer buffer2, final Buffer buffer3) {
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(buffer2);
        final boolean direct3 = Buffers.isDirect(buffer3);
        final long addressof_glGetnSeparableFilter = this._pat._addressof_glGetnSeparableFilter;
        if (addressof_glGetnSeparableFilter == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnSeparableFilter"));
        }
        this.dispatch_glGetnSeparableFilter1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n5, direct2 ? buffer2 : Buffers.getArray(buffer2), direct2 ? Buffers.getDirectBufferByteOffset(buffer2) : Buffers.getIndirectBufferByteOffset(buffer2), direct2, direct3 ? buffer3 : Buffers.getArray(buffer3), direct3 ? Buffers.getDirectBufferByteOffset(buffer3) : Buffers.getIndirectBufferByteOffset(buffer3), direct3, addressof_glGetnSeparableFilter);
    }
    
    private native void dispatch_glGetnSeparableFilter1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final int p7, final Object p8, final int p9, final boolean p10, final Object p11, final int p12, final boolean p13, final long p14);
    
    @Override
    public void glGetnHistogram(final int n, final boolean b, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetnHistogram = this._pat._addressof_glGetnHistogram;
        if (addressof_glGetnHistogram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnHistogram"));
        }
        this.dispatch_glGetnHistogram1(n, b, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetnHistogram);
    }
    
    private native void dispatch_glGetnHistogram1(final int p0, final boolean p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetnMinmax(final int n, final boolean b, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetnMinmax = this._pat._addressof_glGetnMinmax;
        if (addressof_glGetnMinmax == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnMinmax"));
        }
        this.dispatch_glGetnMinmax1(n, b, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetnMinmax);
    }
    
    private native void dispatch_glGetnMinmax1(final int p0, final boolean p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glTextureBarrier() {
        final long addressof_glTextureBarrier = this._pat._addressof_glTextureBarrier;
        if (addressof_glTextureBarrier == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureBarrier"));
        }
        this.dispatch_glTextureBarrier1(addressof_glTextureBarrier);
    }
    
    private native void dispatch_glTextureBarrier1(final long p0);
    
    @Override
    public void glPrimitiveBoundingBox(final float n, final float n2, final float n3, final float n4, final float n5, final float n6, final float n7, final float n8) {
        final long addressof_glPrimitiveBoundingBox = this._pat._addressof_glPrimitiveBoundingBox;
        if (addressof_glPrimitiveBoundingBox == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveBoundingBox"));
        }
        this.dispatch_glPrimitiveBoundingBox1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glPrimitiveBoundingBox);
    }
    
    private native void dispatch_glPrimitiveBoundingBox1(final float p0, final float p1, final float p2, final float p3, final float p4, final float p5, final float p6, final float p7, final long p8);
    
    @Override
    public long glGetTextureHandleARB(final int n) {
        final long addressof_glGetTextureHandleARB = this._pat._addressof_glGetTextureHandleARB;
        if (addressof_glGetTextureHandleARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureHandleARB"));
        }
        return this.dispatch_glGetTextureHandleARB1(n, addressof_glGetTextureHandleARB);
    }
    
    private native long dispatch_glGetTextureHandleARB1(final int p0, final long p1);
    
    @Override
    public long glGetTextureSamplerHandleARB(final int n, final int n2) {
        final long addressof_glGetTextureSamplerHandleARB = this._pat._addressof_glGetTextureSamplerHandleARB;
        if (addressof_glGetTextureSamplerHandleARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureSamplerHandleARB"));
        }
        return this.dispatch_glGetTextureSamplerHandleARB1(n, n2, addressof_glGetTextureSamplerHandleARB);
    }
    
    private native long dispatch_glGetTextureSamplerHandleARB1(final int p0, final int p1, final long p2);
    
    @Override
    public void glMakeTextureHandleResidentARB(final long n) {
        final long addressof_glMakeTextureHandleResidentARB = this._pat._addressof_glMakeTextureHandleResidentARB;
        if (addressof_glMakeTextureHandleResidentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeTextureHandleResidentARB"));
        }
        this.dispatch_glMakeTextureHandleResidentARB1(n, addressof_glMakeTextureHandleResidentARB);
    }
    
    private native void dispatch_glMakeTextureHandleResidentARB1(final long p0, final long p1);
    
    @Override
    public void glMakeTextureHandleNonResidentARB(final long n) {
        final long addressof_glMakeTextureHandleNonResidentARB = this._pat._addressof_glMakeTextureHandleNonResidentARB;
        if (addressof_glMakeTextureHandleNonResidentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeTextureHandleNonResidentARB"));
        }
        this.dispatch_glMakeTextureHandleNonResidentARB1(n, addressof_glMakeTextureHandleNonResidentARB);
    }
    
    private native void dispatch_glMakeTextureHandleNonResidentARB1(final long p0, final long p1);
    
    @Override
    public long glGetImageHandleARB(final int n, final int n2, final boolean b, final int n3, final int n4) {
        final long addressof_glGetImageHandleARB = this._pat._addressof_glGetImageHandleARB;
        if (addressof_glGetImageHandleARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetImageHandleARB"));
        }
        return this.dispatch_glGetImageHandleARB1(n, n2, b, n3, n4, addressof_glGetImageHandleARB);
    }
    
    private native long dispatch_glGetImageHandleARB1(final int p0, final int p1, final boolean p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glMakeImageHandleResidentARB(final long n, final int n2) {
        final long addressof_glMakeImageHandleResidentARB = this._pat._addressof_glMakeImageHandleResidentARB;
        if (addressof_glMakeImageHandleResidentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeImageHandleResidentARB"));
        }
        this.dispatch_glMakeImageHandleResidentARB1(n, n2, addressof_glMakeImageHandleResidentARB);
    }
    
    private native void dispatch_glMakeImageHandleResidentARB1(final long p0, final int p1, final long p2);
    
    @Override
    public void glMakeImageHandleNonResidentARB(final long n) {
        final long addressof_glMakeImageHandleNonResidentARB = this._pat._addressof_glMakeImageHandleNonResidentARB;
        if (addressof_glMakeImageHandleNonResidentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeImageHandleNonResidentARB"));
        }
        this.dispatch_glMakeImageHandleNonResidentARB1(n, addressof_glMakeImageHandleNonResidentARB);
    }
    
    private native void dispatch_glMakeImageHandleNonResidentARB1(final long p0, final long p1);
    
    @Override
    public void glUniformHandleui64ARB(final int n, final long n2) {
        final long addressof_glUniformHandleui64ARB = this._pat._addressof_glUniformHandleui64ARB;
        if (addressof_glUniformHandleui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformHandleui64ARB"));
        }
        this.dispatch_glUniformHandleui64ARB1(n, n2, addressof_glUniformHandleui64ARB);
    }
    
    private native void dispatch_glUniformHandleui64ARB1(final int p0, final long p1, final long p2);
    
    @Override
    public void glUniformHandleui64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniformHandleui64vARB = this._pat._addressof_glUniformHandleui64vARB;
        if (addressof_glUniformHandleui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformHandleui64vARB"));
        }
        this.dispatch_glUniformHandleui64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniformHandleui64vARB);
    }
    
    private native void dispatch_glUniformHandleui64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniformHandleui64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformHandleui64vARB = this._pat._addressof_glUniformHandleui64vARB;
        if (addressof_glUniformHandleui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformHandleui64vARB"));
        }
        this.dispatch_glUniformHandleui64vARB1(n, n2, array, 8 * n3, false, addressof_glUniformHandleui64vARB);
    }
    
    @Override
    public void glProgramUniformHandleui64ARB(final int n, final int n2, final long n3) {
        final long addressof_glProgramUniformHandleui64ARB = this._pat._addressof_glProgramUniformHandleui64ARB;
        if (addressof_glProgramUniformHandleui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformHandleui64ARB"));
        }
        this.dispatch_glProgramUniformHandleui64ARB1(n, n2, n3, addressof_glProgramUniformHandleui64ARB);
    }
    
    private native void dispatch_glProgramUniformHandleui64ARB1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glProgramUniformHandleui64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniformHandleui64vARB = this._pat._addressof_glProgramUniformHandleui64vARB;
        if (addressof_glProgramUniformHandleui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformHandleui64vARB"));
        }
        this.dispatch_glProgramUniformHandleui64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniformHandleui64vARB);
    }
    
    private native void dispatch_glProgramUniformHandleui64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniformHandleui64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"values_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformHandleui64vARB = this._pat._addressof_glProgramUniformHandleui64vARB;
        if (addressof_glProgramUniformHandleui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformHandleui64vARB"));
        }
        this.dispatch_glProgramUniformHandleui64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniformHandleui64vARB);
    }
    
    @Override
    public boolean glIsTextureHandleResidentARB(final long n) {
        final long addressof_glIsTextureHandleResidentARB = this._pat._addressof_glIsTextureHandleResidentARB;
        if (addressof_glIsTextureHandleResidentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsTextureHandleResidentARB"));
        }
        return this.dispatch_glIsTextureHandleResidentARB1(n, addressof_glIsTextureHandleResidentARB);
    }
    
    private native boolean dispatch_glIsTextureHandleResidentARB1(final long p0, final long p1);
    
    @Override
    public boolean glIsImageHandleResidentARB(final long n) {
        final long addressof_glIsImageHandleResidentARB = this._pat._addressof_glIsImageHandleResidentARB;
        if (addressof_glIsImageHandleResidentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsImageHandleResidentARB"));
        }
        return this.dispatch_glIsImageHandleResidentARB1(n, addressof_glIsImageHandleResidentARB);
    }
    
    private native boolean dispatch_glIsImageHandleResidentARB1(final long p0, final long p1);
    
    @Override
    public void glVertexAttribL1ui64ARB(final int n, final long n2) {
        final long addressof_glVertexAttribL1ui64ARB = this._pat._addressof_glVertexAttribL1ui64ARB;
        if (addressof_glVertexAttribL1ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64ARB"));
        }
        this.dispatch_glVertexAttribL1ui64ARB1(n, n2, addressof_glVertexAttribL1ui64ARB);
    }
    
    private native void dispatch_glVertexAttribL1ui64ARB1(final int p0, final long p1, final long p2);
    
    @Override
    public void glVertexAttribL1ui64vARB(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL1ui64vARB = this._pat._addressof_glVertexAttribL1ui64vARB;
        if (addressof_glVertexAttribL1ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vARB"));
        }
        this.dispatch_glVertexAttribL1ui64vARB1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL1ui64vARB);
    }
    
    private native void dispatch_glVertexAttribL1ui64vARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL1ui64vARB(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL1ui64vARB = this._pat._addressof_glVertexAttribL1ui64vARB;
        if (addressof_glVertexAttribL1ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vARB"));
        }
        this.dispatch_glVertexAttribL1ui64vARB1(n, array, 8 * n2, false, addressof_glVertexAttribL1ui64vARB);
    }
    
    @Override
    public void glGetVertexAttribLui64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetVertexAttribLui64vARB = this._pat._addressof_glGetVertexAttribLui64vARB;
        if (addressof_glGetVertexAttribLui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vARB"));
        }
        this.dispatch_glGetVertexAttribLui64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetVertexAttribLui64vARB);
    }
    
    private native void dispatch_glGetVertexAttribLui64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribLui64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribLui64vARB = this._pat._addressof_glGetVertexAttribLui64vARB;
        if (addressof_glGetVertexAttribLui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vARB"));
        }
        this.dispatch_glGetVertexAttribLui64vARB1(n, n2, array, 8 * n3, false, addressof_glGetVertexAttribLui64vARB);
    }
    
    @Override
    public long glCreateSyncFromCLeventARB(final long n, final long n2, final int n3) {
        final long addressof_glCreateSyncFromCLeventARB = this._pat._addressof_glCreateSyncFromCLeventARB;
        if (addressof_glCreateSyncFromCLeventARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateSyncFromCLeventARB"));
        }
        return this.dispatch_glCreateSyncFromCLeventARB1(n, n2, n3, addressof_glCreateSyncFromCLeventARB);
    }
    
    private native long dispatch_glCreateSyncFromCLeventARB1(final long p0, final long p1, final int p2, final long p3);
    
    @Override
    public void glDispatchComputeGroupSizeARB(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glDispatchComputeGroupSizeARB = this._pat._addressof_glDispatchComputeGroupSizeARB;
        if (addressof_glDispatchComputeGroupSizeARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDispatchComputeGroupSizeARB"));
        }
        this.dispatch_glDispatchComputeGroupSizeARB1(n, n2, n3, n4, n5, n6, addressof_glDispatchComputeGroupSizeARB);
    }
    
    private native void dispatch_glDispatchComputeGroupSizeARB1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramStringARB(final int n, final int n2, final int n3, final String s) {
        final long addressof_glProgramStringARB = this._pat._addressof_glProgramStringARB;
        if (addressof_glProgramStringARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramStringARB"));
        }
        this.dispatch_glProgramStringARB1(n, n2, n3, s, addressof_glProgramStringARB);
    }
    
    private native void dispatch_glProgramStringARB1(final int p0, final int p1, final int p2, final String p3, final long p4);
    
    @Override
    public void glBindProgramARB(final int n, final int n2) {
        final long addressof_glBindProgramARB = this._pat._addressof_glBindProgramARB;
        if (addressof_glBindProgramARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindProgramARB"));
        }
        this.dispatch_glBindProgramARB1(n, n2, addressof_glBindProgramARB);
    }
    
    private native void dispatch_glBindProgramARB1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDeleteProgramsARB(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteProgramsARB = this._pat._addressof_glDeleteProgramsARB;
        if (addressof_glDeleteProgramsARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramsARB"));
        }
        this.dispatch_glDeleteProgramsARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteProgramsARB);
    }
    
    private native void dispatch_glDeleteProgramsARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteProgramsARB(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"programs_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteProgramsARB = this._pat._addressof_glDeleteProgramsARB;
        if (addressof_glDeleteProgramsARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramsARB"));
        }
        this.dispatch_glDeleteProgramsARB1(n, array, 4 * n2, false, addressof_glDeleteProgramsARB);
    }
    
    @Override
    public void glGenProgramsARB(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenProgramsARB = this._pat._addressof_glGenProgramsARB;
        if (addressof_glGenProgramsARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenProgramsARB"));
        }
        this.dispatch_glGenProgramsARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenProgramsARB);
    }
    
    private native void dispatch_glGenProgramsARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenProgramsARB(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"programs_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenProgramsARB = this._pat._addressof_glGenProgramsARB;
        if (addressof_glGenProgramsARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenProgramsARB"));
        }
        this.dispatch_glGenProgramsARB1(n, array, 4 * n2, false, addressof_glGenProgramsARB);
    }
    
    @Override
    public void glProgramEnvParameter4dARB(final int n, final int n2, final double n3, final double n4, final double n5, final double n6) {
        final long addressof_glProgramEnvParameter4dARB = this._pat._addressof_glProgramEnvParameter4dARB;
        if (addressof_glProgramEnvParameter4dARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4dARB"));
        }
        this.dispatch_glProgramEnvParameter4dARB1(n, n2, n3, n4, n5, n6, addressof_glProgramEnvParameter4dARB);
    }
    
    private native void dispatch_glProgramEnvParameter4dARB1(final int p0, final int p1, final double p2, final double p3, final double p4, final double p5, final long p6);
    
    @Override
    public void glProgramEnvParameter4dvARB(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramEnvParameter4dvARB = this._pat._addressof_glProgramEnvParameter4dvARB;
        if (addressof_glProgramEnvParameter4dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4dvARB"));
        }
        this.dispatch_glProgramEnvParameter4dvARB1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramEnvParameter4dvARB);
    }
    
    private native void dispatch_glProgramEnvParameter4dvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramEnvParameter4dvARB(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramEnvParameter4dvARB = this._pat._addressof_glProgramEnvParameter4dvARB;
        if (addressof_glProgramEnvParameter4dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4dvARB"));
        }
        this.dispatch_glProgramEnvParameter4dvARB1(n, n2, array, 8 * n3, false, addressof_glProgramEnvParameter4dvARB);
    }
    
    @Override
    public void glProgramEnvParameter4fARB(final int n, final int n2, final float n3, final float n4, final float n5, final float n6) {
        final long addressof_glProgramEnvParameter4fARB = this._pat._addressof_glProgramEnvParameter4fARB;
        if (addressof_glProgramEnvParameter4fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4fARB"));
        }
        this.dispatch_glProgramEnvParameter4fARB1(n, n2, n3, n4, n5, n6, addressof_glProgramEnvParameter4fARB);
    }
    
    private native void dispatch_glProgramEnvParameter4fARB1(final int p0, final int p1, final float p2, final float p3, final float p4, final float p5, final long p6);
    
    @Override
    public void glProgramEnvParameter4fvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramEnvParameter4fvARB = this._pat._addressof_glProgramEnvParameter4fvARB;
        if (addressof_glProgramEnvParameter4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4fvARB"));
        }
        this.dispatch_glProgramEnvParameter4fvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramEnvParameter4fvARB);
    }
    
    private native void dispatch_glProgramEnvParameter4fvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramEnvParameter4fvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramEnvParameter4fvARB = this._pat._addressof_glProgramEnvParameter4fvARB;
        if (addressof_glProgramEnvParameter4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4fvARB"));
        }
        this.dispatch_glProgramEnvParameter4fvARB1(n, n2, array, 4 * n3, false, addressof_glProgramEnvParameter4fvARB);
    }
    
    @Override
    public void glProgramLocalParameter4dARB(final int n, final int n2, final double n3, final double n4, final double n5, final double n6) {
        final long addressof_glProgramLocalParameter4dARB = this._pat._addressof_glProgramLocalParameter4dARB;
        if (addressof_glProgramLocalParameter4dARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4dARB"));
        }
        this.dispatch_glProgramLocalParameter4dARB1(n, n2, n3, n4, n5, n6, addressof_glProgramLocalParameter4dARB);
    }
    
    private native void dispatch_glProgramLocalParameter4dARB1(final int p0, final int p1, final double p2, final double p3, final double p4, final double p5, final long p6);
    
    @Override
    public void glProgramLocalParameter4dvARB(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramLocalParameter4dvARB = this._pat._addressof_glProgramLocalParameter4dvARB;
        if (addressof_glProgramLocalParameter4dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4dvARB"));
        }
        this.dispatch_glProgramLocalParameter4dvARB1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramLocalParameter4dvARB);
    }
    
    private native void dispatch_glProgramLocalParameter4dvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramLocalParameter4dvARB(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramLocalParameter4dvARB = this._pat._addressof_glProgramLocalParameter4dvARB;
        if (addressof_glProgramLocalParameter4dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4dvARB"));
        }
        this.dispatch_glProgramLocalParameter4dvARB1(n, n2, array, 8 * n3, false, addressof_glProgramLocalParameter4dvARB);
    }
    
    @Override
    public void glProgramLocalParameter4fARB(final int n, final int n2, final float n3, final float n4, final float n5, final float n6) {
        final long addressof_glProgramLocalParameter4fARB = this._pat._addressof_glProgramLocalParameter4fARB;
        if (addressof_glProgramLocalParameter4fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4fARB"));
        }
        this.dispatch_glProgramLocalParameter4fARB1(n, n2, n3, n4, n5, n6, addressof_glProgramLocalParameter4fARB);
    }
    
    private native void dispatch_glProgramLocalParameter4fARB1(final int p0, final int p1, final float p2, final float p3, final float p4, final float p5, final long p6);
    
    @Override
    public void glProgramLocalParameter4fvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramLocalParameter4fvARB = this._pat._addressof_glProgramLocalParameter4fvARB;
        if (addressof_glProgramLocalParameter4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4fvARB"));
        }
        this.dispatch_glProgramLocalParameter4fvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramLocalParameter4fvARB);
    }
    
    private native void dispatch_glProgramLocalParameter4fvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramLocalParameter4fvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramLocalParameter4fvARB = this._pat._addressof_glProgramLocalParameter4fvARB;
        if (addressof_glProgramLocalParameter4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4fvARB"));
        }
        this.dispatch_glProgramLocalParameter4fvARB1(n, n2, array, 4 * n3, false, addressof_glProgramLocalParameter4fvARB);
    }
    
    @Override
    public void glGetProgramEnvParameterdvARB(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetProgramEnvParameterdvARB = this._pat._addressof_glGetProgramEnvParameterdvARB;
        if (addressof_glGetProgramEnvParameterdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterdvARB"));
        }
        this.dispatch_glGetProgramEnvParameterdvARB1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetProgramEnvParameterdvARB);
    }
    
    private native void dispatch_glGetProgramEnvParameterdvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramEnvParameterdvARB(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramEnvParameterdvARB = this._pat._addressof_glGetProgramEnvParameterdvARB;
        if (addressof_glGetProgramEnvParameterdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterdvARB"));
        }
        this.dispatch_glGetProgramEnvParameterdvARB1(n, n2, array, 8 * n3, false, addressof_glGetProgramEnvParameterdvARB);
    }
    
    @Override
    public void glGetProgramEnvParameterfvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetProgramEnvParameterfvARB = this._pat._addressof_glGetProgramEnvParameterfvARB;
        if (addressof_glGetProgramEnvParameterfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterfvARB"));
        }
        this.dispatch_glGetProgramEnvParameterfvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetProgramEnvParameterfvARB);
    }
    
    private native void dispatch_glGetProgramEnvParameterfvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramEnvParameterfvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramEnvParameterfvARB = this._pat._addressof_glGetProgramEnvParameterfvARB;
        if (addressof_glGetProgramEnvParameterfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterfvARB"));
        }
        this.dispatch_glGetProgramEnvParameterfvARB1(n, n2, array, 4 * n3, false, addressof_glGetProgramEnvParameterfvARB);
    }
    
    @Override
    public void glGetProgramLocalParameterdvARB(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetProgramLocalParameterdvARB = this._pat._addressof_glGetProgramLocalParameterdvARB;
        if (addressof_glGetProgramLocalParameterdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterdvARB"));
        }
        this.dispatch_glGetProgramLocalParameterdvARB1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetProgramLocalParameterdvARB);
    }
    
    private native void dispatch_glGetProgramLocalParameterdvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramLocalParameterdvARB(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramLocalParameterdvARB = this._pat._addressof_glGetProgramLocalParameterdvARB;
        if (addressof_glGetProgramLocalParameterdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterdvARB"));
        }
        this.dispatch_glGetProgramLocalParameterdvARB1(n, n2, array, 8 * n3, false, addressof_glGetProgramLocalParameterdvARB);
    }
    
    @Override
    public void glGetProgramLocalParameterfvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetProgramLocalParameterfvARB = this._pat._addressof_glGetProgramLocalParameterfvARB;
        if (addressof_glGetProgramLocalParameterfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterfvARB"));
        }
        this.dispatch_glGetProgramLocalParameterfvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetProgramLocalParameterfvARB);
    }
    
    private native void dispatch_glGetProgramLocalParameterfvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramLocalParameterfvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramLocalParameterfvARB = this._pat._addressof_glGetProgramLocalParameterfvARB;
        if (addressof_glGetProgramLocalParameterfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterfvARB"));
        }
        this.dispatch_glGetProgramLocalParameterfvARB1(n, n2, array, 4 * n3, false, addressof_glGetProgramLocalParameterfvARB);
    }
    
    @Override
    public void glGetProgramivARB(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramivARB = this._pat._addressof_glGetProgramivARB;
        if (addressof_glGetProgramivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramivARB"));
        }
        this.dispatch_glGetProgramivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramivARB);
    }
    
    private native void dispatch_glGetProgramivARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramivARB(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramivARB = this._pat._addressof_glGetProgramivARB;
        if (addressof_glGetProgramivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramivARB"));
        }
        this.dispatch_glGetProgramivARB1(n, n2, array, 4 * n3, false, addressof_glGetProgramivARB);
    }
    
    @Override
    public void glGetProgramStringARB(final int n, final int n2, final Buffer buffer) {
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"string\" is not a direct buffer");
        }
        final long addressof_glGetProgramStringARB = this._pat._addressof_glGetProgramStringARB;
        if (addressof_glGetProgramStringARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramStringARB"));
        }
        this.dispatch_glGetProgramStringARB0(n, n2, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glGetProgramStringARB);
    }
    
    private native void dispatch_glGetProgramStringARB0(final int p0, final int p1, final Object p2, final int p3, final long p4);
    
    @Override
    public boolean glIsProgramARB(final int n) {
        final long addressof_glIsProgramARB = this._pat._addressof_glIsProgramARB;
        if (addressof_glIsProgramARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsProgramARB"));
        }
        return this.dispatch_glIsProgramARB1(n, addressof_glIsProgramARB);
    }
    
    private native boolean dispatch_glIsProgramARB1(final int p0, final long p1);
    
    @Override
    public void glProgramParameteriARB(final int n, final int n2, final int n3) {
        final long addressof_glProgramParameteriARB = this._pat._addressof_glProgramParameteriARB;
        if (addressof_glProgramParameteriARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramParameteriARB"));
        }
        this.dispatch_glProgramParameteriARB1(n, n2, n3, addressof_glProgramParameteriARB);
    }
    
    private native void dispatch_glProgramParameteriARB1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glFramebufferTextureARB(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glFramebufferTextureARB = this._pat._addressof_glFramebufferTextureARB;
        if (addressof_glFramebufferTextureARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureARB"));
        }
        this.dispatch_glFramebufferTextureARB1(n, n2, n3, n4, addressof_glFramebufferTextureARB);
    }
    
    private native void dispatch_glFramebufferTextureARB1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glFramebufferTextureLayerARB(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glFramebufferTextureLayerARB = this._pat._addressof_glFramebufferTextureLayerARB;
        if (addressof_glFramebufferTextureLayerARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureLayerARB"));
        }
        this.dispatch_glFramebufferTextureLayerARB1(n, n2, n3, n4, n5, addressof_glFramebufferTextureLayerARB);
    }
    
    private native void dispatch_glFramebufferTextureLayerARB1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glFramebufferTextureFaceARB(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glFramebufferTextureFaceARB = this._pat._addressof_glFramebufferTextureFaceARB;
        if (addressof_glFramebufferTextureFaceARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureFaceARB"));
        }
        this.dispatch_glFramebufferTextureFaceARB1(n, n2, n3, n4, n5, addressof_glFramebufferTextureFaceARB);
    }
    
    private native void dispatch_glFramebufferTextureFaceARB1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glUniform1i64ARB(final int n, final long n2) {
        final long addressof_glUniform1i64ARB = this._pat._addressof_glUniform1i64ARB;
        if (addressof_glUniform1i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64ARB"));
        }
        this.dispatch_glUniform1i64ARB1(n, n2, addressof_glUniform1i64ARB);
    }
    
    private native void dispatch_glUniform1i64ARB1(final int p0, final long p1, final long p2);
    
    @Override
    public void glUniform2i64ARB(final int n, final long n2, final long n3) {
        final long addressof_glUniform2i64ARB = this._pat._addressof_glUniform2i64ARB;
        if (addressof_glUniform2i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64ARB"));
        }
        this.dispatch_glUniform2i64ARB1(n, n2, n3, addressof_glUniform2i64ARB);
    }
    
    private native void dispatch_glUniform2i64ARB1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glUniform3i64ARB(final int n, final long n2, final long n3, final long n4) {
        final long addressof_glUniform3i64ARB = this._pat._addressof_glUniform3i64ARB;
        if (addressof_glUniform3i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64ARB"));
        }
        this.dispatch_glUniform3i64ARB1(n, n2, n3, n4, addressof_glUniform3i64ARB);
    }
    
    private native void dispatch_glUniform3i64ARB1(final int p0, final long p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glUniform4i64ARB(final int n, final long n2, final long n3, final long n4, final long n5) {
        final long addressof_glUniform4i64ARB = this._pat._addressof_glUniform4i64ARB;
        if (addressof_glUniform4i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64ARB"));
        }
        this.dispatch_glUniform4i64ARB1(n, n2, n3, n4, n5, addressof_glUniform4i64ARB);
    }
    
    private native void dispatch_glUniform4i64ARB1(final int p0, final long p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glUniform1i64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform1i64vARB = this._pat._addressof_glUniform1i64vARB;
        if (addressof_glUniform1i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vARB"));
        }
        this.dispatch_glUniform1i64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform1i64vARB);
    }
    
    private native void dispatch_glUniform1i64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1i64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1i64vARB = this._pat._addressof_glUniform1i64vARB;
        if (addressof_glUniform1i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vARB"));
        }
        this.dispatch_glUniform1i64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform1i64vARB);
    }
    
    @Override
    public void glUniform2i64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform2i64vARB = this._pat._addressof_glUniform2i64vARB;
        if (addressof_glUniform2i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vARB"));
        }
        this.dispatch_glUniform2i64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform2i64vARB);
    }
    
    private native void dispatch_glUniform2i64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2i64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2i64vARB = this._pat._addressof_glUniform2i64vARB;
        if (addressof_glUniform2i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vARB"));
        }
        this.dispatch_glUniform2i64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform2i64vARB);
    }
    
    @Override
    public void glUniform3i64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform3i64vARB = this._pat._addressof_glUniform3i64vARB;
        if (addressof_glUniform3i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vARB"));
        }
        this.dispatch_glUniform3i64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform3i64vARB);
    }
    
    private native void dispatch_glUniform3i64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3i64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3i64vARB = this._pat._addressof_glUniform3i64vARB;
        if (addressof_glUniform3i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vARB"));
        }
        this.dispatch_glUniform3i64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform3i64vARB);
    }
    
    @Override
    public void glUniform4i64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform4i64vARB = this._pat._addressof_glUniform4i64vARB;
        if (addressof_glUniform4i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vARB"));
        }
        this.dispatch_glUniform4i64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform4i64vARB);
    }
    
    private native void dispatch_glUniform4i64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4i64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4i64vARB = this._pat._addressof_glUniform4i64vARB;
        if (addressof_glUniform4i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vARB"));
        }
        this.dispatch_glUniform4i64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform4i64vARB);
    }
    
    @Override
    public void glUniform1ui64ARB(final int n, final long n2) {
        final long addressof_glUniform1ui64ARB = this._pat._addressof_glUniform1ui64ARB;
        if (addressof_glUniform1ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64ARB"));
        }
        this.dispatch_glUniform1ui64ARB1(n, n2, addressof_glUniform1ui64ARB);
    }
    
    private native void dispatch_glUniform1ui64ARB1(final int p0, final long p1, final long p2);
    
    @Override
    public void glUniform2ui64ARB(final int n, final long n2, final long n3) {
        final long addressof_glUniform2ui64ARB = this._pat._addressof_glUniform2ui64ARB;
        if (addressof_glUniform2ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64ARB"));
        }
        this.dispatch_glUniform2ui64ARB1(n, n2, n3, addressof_glUniform2ui64ARB);
    }
    
    private native void dispatch_glUniform2ui64ARB1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glUniform3ui64ARB(final int n, final long n2, final long n3, final long n4) {
        final long addressof_glUniform3ui64ARB = this._pat._addressof_glUniform3ui64ARB;
        if (addressof_glUniform3ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64ARB"));
        }
        this.dispatch_glUniform3ui64ARB1(n, n2, n3, n4, addressof_glUniform3ui64ARB);
    }
    
    private native void dispatch_glUniform3ui64ARB1(final int p0, final long p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glUniform4ui64ARB(final int n, final long n2, final long n3, final long n4, final long n5) {
        final long addressof_glUniform4ui64ARB = this._pat._addressof_glUniform4ui64ARB;
        if (addressof_glUniform4ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64ARB"));
        }
        this.dispatch_glUniform4ui64ARB1(n, n2, n3, n4, n5, addressof_glUniform4ui64ARB);
    }
    
    private native void dispatch_glUniform4ui64ARB1(final int p0, final long p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glUniform1ui64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform1ui64vARB = this._pat._addressof_glUniform1ui64vARB;
        if (addressof_glUniform1ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vARB"));
        }
        this.dispatch_glUniform1ui64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform1ui64vARB);
    }
    
    private native void dispatch_glUniform1ui64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1ui64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1ui64vARB = this._pat._addressof_glUniform1ui64vARB;
        if (addressof_glUniform1ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vARB"));
        }
        this.dispatch_glUniform1ui64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform1ui64vARB);
    }
    
    @Override
    public void glUniform2ui64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform2ui64vARB = this._pat._addressof_glUniform2ui64vARB;
        if (addressof_glUniform2ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vARB"));
        }
        this.dispatch_glUniform2ui64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform2ui64vARB);
    }
    
    private native void dispatch_glUniform2ui64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2ui64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2ui64vARB = this._pat._addressof_glUniform2ui64vARB;
        if (addressof_glUniform2ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vARB"));
        }
        this.dispatch_glUniform2ui64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform2ui64vARB);
    }
    
    @Override
    public void glUniform3ui64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform3ui64vARB = this._pat._addressof_glUniform3ui64vARB;
        if (addressof_glUniform3ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vARB"));
        }
        this.dispatch_glUniform3ui64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform3ui64vARB);
    }
    
    private native void dispatch_glUniform3ui64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3ui64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3ui64vARB = this._pat._addressof_glUniform3ui64vARB;
        if (addressof_glUniform3ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vARB"));
        }
        this.dispatch_glUniform3ui64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform3ui64vARB);
    }
    
    @Override
    public void glUniform4ui64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform4ui64vARB = this._pat._addressof_glUniform4ui64vARB;
        if (addressof_glUniform4ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vARB"));
        }
        this.dispatch_glUniform4ui64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform4ui64vARB);
    }
    
    private native void dispatch_glUniform4ui64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4ui64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4ui64vARB = this._pat._addressof_glUniform4ui64vARB;
        if (addressof_glUniform4ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vARB"));
        }
        this.dispatch_glUniform4ui64vARB1(n, n2, array, 8 * n3, false, addressof_glUniform4ui64vARB);
    }
    
    @Override
    public void glGetUniformi64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetUniformi64vARB = this._pat._addressof_glGetUniformi64vARB;
        if (addressof_glGetUniformi64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vARB"));
        }
        this.dispatch_glGetUniformi64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetUniformi64vARB);
    }
    
    private native void dispatch_glGetUniformi64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformi64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformi64vARB = this._pat._addressof_glGetUniformi64vARB;
        if (addressof_glGetUniformi64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vARB"));
        }
        this.dispatch_glGetUniformi64vARB1(n, n2, array, 8 * n3, false, addressof_glGetUniformi64vARB);
    }
    
    @Override
    public void glGetUniformui64vARB(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetUniformui64vARB = this._pat._addressof_glGetUniformui64vARB;
        if (addressof_glGetUniformui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vARB"));
        }
        this.dispatch_glGetUniformui64vARB1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetUniformui64vARB);
    }
    
    private native void dispatch_glGetUniformui64vARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformui64vARB(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformui64vARB = this._pat._addressof_glGetUniformui64vARB;
        if (addressof_glGetUniformui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vARB"));
        }
        this.dispatch_glGetUniformui64vARB1(n, n2, array, 8 * n3, false, addressof_glGetUniformui64vARB);
    }
    
    @Override
    public void glGetnUniformi64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetnUniformi64vARB = this._pat._addressof_glGetnUniformi64vARB;
        if (addressof_glGetnUniformi64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformi64vARB"));
        }
        this.dispatch_glGetnUniformi64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetnUniformi64vARB);
    }
    
    private native void dispatch_glGetnUniformi64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnUniformi64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnUniformi64vARB = this._pat._addressof_glGetnUniformi64vARB;
        if (addressof_glGetnUniformi64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformi64vARB"));
        }
        this.dispatch_glGetnUniformi64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glGetnUniformi64vARB);
    }
    
    @Override
    public void glGetnUniformui64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetnUniformui64vARB = this._pat._addressof_glGetnUniformui64vARB;
        if (addressof_glGetnUniformui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformui64vARB"));
        }
        this.dispatch_glGetnUniformui64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetnUniformui64vARB);
    }
    
    private native void dispatch_glGetnUniformui64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetnUniformui64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetnUniformui64vARB = this._pat._addressof_glGetnUniformui64vARB;
        if (addressof_glGetnUniformui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformui64vARB"));
        }
        this.dispatch_glGetnUniformui64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glGetnUniformui64vARB);
    }
    
    @Override
    public void glProgramUniform1i64ARB(final int n, final int n2, final long n3) {
        final long addressof_glProgramUniform1i64ARB = this._pat._addressof_glProgramUniform1i64ARB;
        if (addressof_glProgramUniform1i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64ARB"));
        }
        this.dispatch_glProgramUniform1i64ARB1(n, n2, n3, addressof_glProgramUniform1i64ARB);
    }
    
    private native void dispatch_glProgramUniform1i64ARB1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glProgramUniform2i64ARB(final int n, final int n2, final long n3, final long n4) {
        final long addressof_glProgramUniform2i64ARB = this._pat._addressof_glProgramUniform2i64ARB;
        if (addressof_glProgramUniform2i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64ARB"));
        }
        this.dispatch_glProgramUniform2i64ARB1(n, n2, n3, n4, addressof_glProgramUniform2i64ARB);
    }
    
    private native void dispatch_glProgramUniform2i64ARB1(final int p0, final int p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glProgramUniform3i64ARB(final int n, final int n2, final long n3, final long n4, final long n5) {
        final long addressof_glProgramUniform3i64ARB = this._pat._addressof_glProgramUniform3i64ARB;
        if (addressof_glProgramUniform3i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64ARB"));
        }
        this.dispatch_glProgramUniform3i64ARB1(n, n2, n3, n4, n5, addressof_glProgramUniform3i64ARB);
    }
    
    private native void dispatch_glProgramUniform3i64ARB1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glProgramUniform4i64ARB(final int n, final int n2, final long n3, final long n4, final long n5, final long n6) {
        final long addressof_glProgramUniform4i64ARB = this._pat._addressof_glProgramUniform4i64ARB;
        if (addressof_glProgramUniform4i64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64ARB"));
        }
        this.dispatch_glProgramUniform4i64ARB1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4i64ARB);
    }
    
    private native void dispatch_glProgramUniform4i64ARB1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5, final long p6);
    
    @Override
    public void glProgramUniform1i64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform1i64vARB = this._pat._addressof_glProgramUniform1i64vARB;
        if (addressof_glProgramUniform1i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vARB"));
        }
        this.dispatch_glProgramUniform1i64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform1i64vARB);
    }
    
    private native void dispatch_glProgramUniform1i64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1i64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1i64vARB = this._pat._addressof_glProgramUniform1i64vARB;
        if (addressof_glProgramUniform1i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vARB"));
        }
        this.dispatch_glProgramUniform1i64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform1i64vARB);
    }
    
    @Override
    public void glProgramUniform2i64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform2i64vARB = this._pat._addressof_glProgramUniform2i64vARB;
        if (addressof_glProgramUniform2i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vARB"));
        }
        this.dispatch_glProgramUniform2i64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform2i64vARB);
    }
    
    private native void dispatch_glProgramUniform2i64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2i64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2i64vARB = this._pat._addressof_glProgramUniform2i64vARB;
        if (addressof_glProgramUniform2i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vARB"));
        }
        this.dispatch_glProgramUniform2i64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform2i64vARB);
    }
    
    @Override
    public void glProgramUniform3i64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform3i64vARB = this._pat._addressof_glProgramUniform3i64vARB;
        if (addressof_glProgramUniform3i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vARB"));
        }
        this.dispatch_glProgramUniform3i64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform3i64vARB);
    }
    
    private native void dispatch_glProgramUniform3i64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3i64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3i64vARB = this._pat._addressof_glProgramUniform3i64vARB;
        if (addressof_glProgramUniform3i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vARB"));
        }
        this.dispatch_glProgramUniform3i64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform3i64vARB);
    }
    
    @Override
    public void glProgramUniform4i64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform4i64vARB = this._pat._addressof_glProgramUniform4i64vARB;
        if (addressof_glProgramUniform4i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vARB"));
        }
        this.dispatch_glProgramUniform4i64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform4i64vARB);
    }
    
    private native void dispatch_glProgramUniform4i64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4i64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4i64vARB = this._pat._addressof_glProgramUniform4i64vARB;
        if (addressof_glProgramUniform4i64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vARB"));
        }
        this.dispatch_glProgramUniform4i64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform4i64vARB);
    }
    
    @Override
    public void glProgramUniform1ui64ARB(final int n, final int n2, final long n3) {
        final long addressof_glProgramUniform1ui64ARB = this._pat._addressof_glProgramUniform1ui64ARB;
        if (addressof_glProgramUniform1ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64ARB"));
        }
        this.dispatch_glProgramUniform1ui64ARB1(n, n2, n3, addressof_glProgramUniform1ui64ARB);
    }
    
    private native void dispatch_glProgramUniform1ui64ARB1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glProgramUniform2ui64ARB(final int n, final int n2, final long n3, final long n4) {
        final long addressof_glProgramUniform2ui64ARB = this._pat._addressof_glProgramUniform2ui64ARB;
        if (addressof_glProgramUniform2ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64ARB"));
        }
        this.dispatch_glProgramUniform2ui64ARB1(n, n2, n3, n4, addressof_glProgramUniform2ui64ARB);
    }
    
    private native void dispatch_glProgramUniform2ui64ARB1(final int p0, final int p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glProgramUniform3ui64ARB(final int n, final int n2, final long n3, final long n4, final long n5) {
        final long addressof_glProgramUniform3ui64ARB = this._pat._addressof_glProgramUniform3ui64ARB;
        if (addressof_glProgramUniform3ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64ARB"));
        }
        this.dispatch_glProgramUniform3ui64ARB1(n, n2, n3, n4, n5, addressof_glProgramUniform3ui64ARB);
    }
    
    private native void dispatch_glProgramUniform3ui64ARB1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glProgramUniform4ui64ARB(final int n, final int n2, final long n3, final long n4, final long n5, final long n6) {
        final long addressof_glProgramUniform4ui64ARB = this._pat._addressof_glProgramUniform4ui64ARB;
        if (addressof_glProgramUniform4ui64ARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64ARB"));
        }
        this.dispatch_glProgramUniform4ui64ARB1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4ui64ARB);
    }
    
    private native void dispatch_glProgramUniform4ui64ARB1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5, final long p6);
    
    @Override
    public void glProgramUniform1ui64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform1ui64vARB = this._pat._addressof_glProgramUniform1ui64vARB;
        if (addressof_glProgramUniform1ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vARB"));
        }
        this.dispatch_glProgramUniform1ui64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform1ui64vARB);
    }
    
    private native void dispatch_glProgramUniform1ui64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1ui64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1ui64vARB = this._pat._addressof_glProgramUniform1ui64vARB;
        if (addressof_glProgramUniform1ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vARB"));
        }
        this.dispatch_glProgramUniform1ui64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform1ui64vARB);
    }
    
    @Override
    public void glProgramUniform2ui64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform2ui64vARB = this._pat._addressof_glProgramUniform2ui64vARB;
        if (addressof_glProgramUniform2ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vARB"));
        }
        this.dispatch_glProgramUniform2ui64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform2ui64vARB);
    }
    
    private native void dispatch_glProgramUniform2ui64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2ui64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2ui64vARB = this._pat._addressof_glProgramUniform2ui64vARB;
        if (addressof_glProgramUniform2ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vARB"));
        }
        this.dispatch_glProgramUniform2ui64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform2ui64vARB);
    }
    
    @Override
    public void glProgramUniform3ui64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform3ui64vARB = this._pat._addressof_glProgramUniform3ui64vARB;
        if (addressof_glProgramUniform3ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vARB"));
        }
        this.dispatch_glProgramUniform3ui64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform3ui64vARB);
    }
    
    private native void dispatch_glProgramUniform3ui64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3ui64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3ui64vARB = this._pat._addressof_glProgramUniform3ui64vARB;
        if (addressof_glProgramUniform3ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vARB"));
        }
        this.dispatch_glProgramUniform3ui64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform3ui64vARB);
    }
    
    @Override
    public void glProgramUniform4ui64vARB(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform4ui64vARB = this._pat._addressof_glProgramUniform4ui64vARB;
        if (addressof_glProgramUniform4ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vARB"));
        }
        this.dispatch_glProgramUniform4ui64vARB1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform4ui64vARB);
    }
    
    private native void dispatch_glProgramUniform4ui64vARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4ui64vARB(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4ui64vARB = this._pat._addressof_glProgramUniform4ui64vARB;
        if (addressof_glProgramUniform4ui64vARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vARB"));
        }
        this.dispatch_glProgramUniform4ui64vARB1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform4ui64vARB);
    }
    
    @Override
    public void glColorTable(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n4, n5, n3, 1, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glColorTable = this._pat._addressof_glColorTable;
        if (addressof_glColorTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorTable"));
        }
        this.dispatch_glColorTable1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glColorTable);
    }
    
    private native void dispatch_glColorTable1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glColorTable(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        this.checkUnpackPBOBound(true);
        final long addressof_glColorTable = this._pat._addressof_glColorTable;
        if (addressof_glColorTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorTable"));
        }
        this.dispatch_glColorTable1(n, n2, n3, n4, n5, n6, addressof_glColorTable);
    }
    
    private native void dispatch_glColorTable1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glColorTableParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glColorTableParameterfv = this._pat._addressof_glColorTableParameterfv;
        if (addressof_glColorTableParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameterfv"));
        }
        this.dispatch_glColorTableParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glColorTableParameterfv);
    }
    
    private native void dispatch_glColorTableParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glColorTableParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColorTableParameterfv = this._pat._addressof_glColorTableParameterfv;
        if (addressof_glColorTableParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameterfv"));
        }
        this.dispatch_glColorTableParameterfv1(n, n2, array, 4 * n3, false, addressof_glColorTableParameterfv);
    }
    
    @Override
    public void glColorTableParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glColorTableParameteriv = this._pat._addressof_glColorTableParameteriv;
        if (addressof_glColorTableParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameteriv"));
        }
        this.dispatch_glColorTableParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glColorTableParameteriv);
    }
    
    private native void dispatch_glColorTableParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glColorTableParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColorTableParameteriv = this._pat._addressof_glColorTableParameteriv;
        if (addressof_glColorTableParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameteriv"));
        }
        this.dispatch_glColorTableParameteriv1(n, n2, array, 4 * n3, false, addressof_glColorTableParameteriv);
    }
    
    @Override
    public void glCopyColorTable(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glCopyColorTable = this._pat._addressof_glCopyColorTable;
        if (addressof_glCopyColorTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyColorTable"));
        }
        this.dispatch_glCopyColorTable1(n, n2, n3, n4, n5, addressof_glCopyColorTable);
    }
    
    private native void dispatch_glCopyColorTable1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glGetColorTable(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetColorTable = this._pat._addressof_glGetColorTable;
        if (addressof_glGetColorTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetColorTable"));
        }
        this.dispatch_glGetColorTable1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetColorTable);
    }
    
    private native void dispatch_glGetColorTable1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetColorTable(final int n, final int n2, final int n3, final long n4) {
        this.checkPackPBOBound(true);
        final long addressof_glGetColorTable = this._pat._addressof_glGetColorTable;
        if (addressof_glGetColorTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetColorTable"));
        }
        this.dispatch_glGetColorTable1(n, n2, n3, n4, addressof_glGetColorTable);
    }
    
    private native void dispatch_glGetColorTable1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glGetColorTableParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetColorTableParameterfv = this._pat._addressof_glGetColorTableParameterfv;
        if (addressof_glGetColorTableParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameterfv"));
        }
        this.dispatch_glGetColorTableParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetColorTableParameterfv);
    }
    
    private native void dispatch_glGetColorTableParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetColorTableParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetColorTableParameterfv = this._pat._addressof_glGetColorTableParameterfv;
        if (addressof_glGetColorTableParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameterfv"));
        }
        this.dispatch_glGetColorTableParameterfv1(n, n2, array, 4 * n3, false, addressof_glGetColorTableParameterfv);
    }
    
    @Override
    public void glGetColorTableParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetColorTableParameteriv = this._pat._addressof_glGetColorTableParameteriv;
        if (addressof_glGetColorTableParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameteriv"));
        }
        this.dispatch_glGetColorTableParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetColorTableParameteriv);
    }
    
    private native void dispatch_glGetColorTableParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetColorTableParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetColorTableParameteriv = this._pat._addressof_glGetColorTableParameteriv;
        if (addressof_glGetColorTableParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameteriv"));
        }
        this.dispatch_glGetColorTableParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetColorTableParameteriv);
    }
    
    @Override
    public void glColorSubTable(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glColorSubTable = this._pat._addressof_glColorSubTable;
        if (addressof_glColorSubTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorSubTable"));
        }
        this.dispatch_glColorSubTable1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glColorSubTable);
    }
    
    private native void dispatch_glColorSubTable1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glColorSubTable(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        this.checkUnpackPBOBound(true);
        final long addressof_glColorSubTable = this._pat._addressof_glColorSubTable;
        if (addressof_glColorSubTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorSubTable"));
        }
        this.dispatch_glColorSubTable1(n, n2, n3, n4, n5, n6, addressof_glColorSubTable);
    }
    
    private native void dispatch_glColorSubTable1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glCopyColorSubTable(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glCopyColorSubTable = this._pat._addressof_glCopyColorSubTable;
        if (addressof_glCopyColorSubTable == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyColorSubTable"));
        }
        this.dispatch_glCopyColorSubTable1(n, n2, n3, n4, n5, addressof_glCopyColorSubTable);
    }
    
    private native void dispatch_glCopyColorSubTable1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glConvolutionFilter1D(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n4, n5, n3, 1, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glConvolutionFilter1D = this._pat._addressof_glConvolutionFilter1D;
        if (addressof_glConvolutionFilter1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter1D"));
        }
        this.dispatch_glConvolutionFilter1D1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glConvolutionFilter1D);
    }
    
    private native void dispatch_glConvolutionFilter1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glConvolutionFilter1D(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        this.checkUnpackPBOBound(true);
        final long addressof_glConvolutionFilter1D = this._pat._addressof_glConvolutionFilter1D;
        if (addressof_glConvolutionFilter1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter1D"));
        }
        this.dispatch_glConvolutionFilter1D1(n, n2, n3, n4, n5, n6, addressof_glConvolutionFilter1D);
    }
    
    private native void dispatch_glConvolutionFilter1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glConvolutionFilter2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n5, n6, n3, n4, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glConvolutionFilter2D = this._pat._addressof_glConvolutionFilter2D;
        if (addressof_glConvolutionFilter2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter2D"));
        }
        this.dispatch_glConvolutionFilter2D1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glConvolutionFilter2D);
    }
    
    private native void dispatch_glConvolutionFilter2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glConvolutionFilter2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        this.checkUnpackPBOBound(true);
        final long addressof_glConvolutionFilter2D = this._pat._addressof_glConvolutionFilter2D;
        if (addressof_glConvolutionFilter2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter2D"));
        }
        this.dispatch_glConvolutionFilter2D1(n, n2, n3, n4, n5, n6, n7, addressof_glConvolutionFilter2D);
    }
    
    private native void dispatch_glConvolutionFilter2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glConvolutionParameterf(final int n, final int n2, final float n3) {
        final long addressof_glConvolutionParameterf = this._pat._addressof_glConvolutionParameterf;
        if (addressof_glConvolutionParameterf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameterf"));
        }
        this.dispatch_glConvolutionParameterf1(n, n2, n3, addressof_glConvolutionParameterf);
    }
    
    private native void dispatch_glConvolutionParameterf1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glConvolutionParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glConvolutionParameterfv = this._pat._addressof_glConvolutionParameterfv;
        if (addressof_glConvolutionParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameterfv"));
        }
        this.dispatch_glConvolutionParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glConvolutionParameterfv);
    }
    
    private native void dispatch_glConvolutionParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glConvolutionParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glConvolutionParameterfv = this._pat._addressof_glConvolutionParameterfv;
        if (addressof_glConvolutionParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameterfv"));
        }
        this.dispatch_glConvolutionParameterfv1(n, n2, array, 4 * n3, false, addressof_glConvolutionParameterfv);
    }
    
    @Override
    public void glConvolutionParameteri(final int n, final int n2, final int n3) {
        final long addressof_glConvolutionParameteri = this._pat._addressof_glConvolutionParameteri;
        if (addressof_glConvolutionParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameteri"));
        }
        this.dispatch_glConvolutionParameteri1(n, n2, n3, addressof_glConvolutionParameteri);
    }
    
    private native void dispatch_glConvolutionParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glConvolutionParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glConvolutionParameteriv = this._pat._addressof_glConvolutionParameteriv;
        if (addressof_glConvolutionParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameteriv"));
        }
        this.dispatch_glConvolutionParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glConvolutionParameteriv);
    }
    
    private native void dispatch_glConvolutionParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glConvolutionParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glConvolutionParameteriv = this._pat._addressof_glConvolutionParameteriv;
        if (addressof_glConvolutionParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameteriv"));
        }
        this.dispatch_glConvolutionParameteriv1(n, n2, array, 4 * n3, false, addressof_glConvolutionParameteriv);
    }
    
    @Override
    public void glCopyConvolutionFilter1D(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glCopyConvolutionFilter1D = this._pat._addressof_glCopyConvolutionFilter1D;
        if (addressof_glCopyConvolutionFilter1D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyConvolutionFilter1D"));
        }
        this.dispatch_glCopyConvolutionFilter1D1(n, n2, n3, n4, n5, addressof_glCopyConvolutionFilter1D);
    }
    
    private native void dispatch_glCopyConvolutionFilter1D1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glCopyConvolutionFilter2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glCopyConvolutionFilter2D = this._pat._addressof_glCopyConvolutionFilter2D;
        if (addressof_glCopyConvolutionFilter2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyConvolutionFilter2D"));
        }
        this.dispatch_glCopyConvolutionFilter2D1(n, n2, n3, n4, n5, n6, addressof_glCopyConvolutionFilter2D);
    }
    
    private native void dispatch_glCopyConvolutionFilter2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glGetConvolutionFilter(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetConvolutionFilter = this._pat._addressof_glGetConvolutionFilter;
        if (addressof_glGetConvolutionFilter == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionFilter"));
        }
        this.dispatch_glGetConvolutionFilter1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetConvolutionFilter);
    }
    
    private native void dispatch_glGetConvolutionFilter1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetConvolutionFilter(final int n, final int n2, final int n3, final long n4) {
        this.checkPackPBOBound(true);
        final long addressof_glGetConvolutionFilter = this._pat._addressof_glGetConvolutionFilter;
        if (addressof_glGetConvolutionFilter == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionFilter"));
        }
        this.dispatch_glGetConvolutionFilter1(n, n2, n3, n4, addressof_glGetConvolutionFilter);
    }
    
    private native void dispatch_glGetConvolutionFilter1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glGetConvolutionParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetConvolutionParameterfv = this._pat._addressof_glGetConvolutionParameterfv;
        if (addressof_glGetConvolutionParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameterfv"));
        }
        this.dispatch_glGetConvolutionParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetConvolutionParameterfv);
    }
    
    private native void dispatch_glGetConvolutionParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetConvolutionParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetConvolutionParameterfv = this._pat._addressof_glGetConvolutionParameterfv;
        if (addressof_glGetConvolutionParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameterfv"));
        }
        this.dispatch_glGetConvolutionParameterfv1(n, n2, array, 4 * n3, false, addressof_glGetConvolutionParameterfv);
    }
    
    @Override
    public void glGetConvolutionParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetConvolutionParameteriv = this._pat._addressof_glGetConvolutionParameteriv;
        if (addressof_glGetConvolutionParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameteriv"));
        }
        this.dispatch_glGetConvolutionParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetConvolutionParameteriv);
    }
    
    private native void dispatch_glGetConvolutionParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetConvolutionParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetConvolutionParameteriv = this._pat._addressof_glGetConvolutionParameteriv;
        if (addressof_glGetConvolutionParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameteriv"));
        }
        this.dispatch_glGetConvolutionParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetConvolutionParameteriv);
    }
    
    @Override
    public void glGetSeparableFilter(final int n, final int n2, final int n3, final Buffer buffer, final Buffer buffer2, final Buffer buffer3) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(buffer2);
        final boolean direct3 = Buffers.isDirect(buffer3);
        final long addressof_glGetSeparableFilter = this._pat._addressof_glGetSeparableFilter;
        if (addressof_glGetSeparableFilter == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSeparableFilter"));
        }
        this.dispatch_glGetSeparableFilter1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, direct2 ? buffer2 : Buffers.getArray(buffer2), direct2 ? Buffers.getDirectBufferByteOffset(buffer2) : Buffers.getIndirectBufferByteOffset(buffer2), direct2, direct3 ? buffer3 : Buffers.getArray(buffer3), direct3 ? Buffers.getDirectBufferByteOffset(buffer3) : Buffers.getIndirectBufferByteOffset(buffer3), direct3, addressof_glGetSeparableFilter);
    }
    
    private native void dispatch_glGetSeparableFilter1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glGetSeparableFilter(final int n, final int n2, final int n3, final long n4, final long n5, final long n6) {
        this.checkPackPBOBound(true);
        final long addressof_glGetSeparableFilter = this._pat._addressof_glGetSeparableFilter;
        if (addressof_glGetSeparableFilter == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetSeparableFilter"));
        }
        this.dispatch_glGetSeparableFilter1(n, n2, n3, n4, n5, n6, addressof_glGetSeparableFilter);
    }
    
    private native void dispatch_glGetSeparableFilter1(final int p0, final int p1, final int p2, final long p3, final long p4, final long p5, final long p6);
    
    @Override
    public void glSeparableFilter2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final Buffer buffer, final Buffer buffer2) {
        this.checkUnpackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(buffer2);
        final long addressof_glSeparableFilter2D = this._pat._addressof_glSeparableFilter2D;
        if (addressof_glSeparableFilter2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSeparableFilter2D"));
        }
        this.dispatch_glSeparableFilter2D1(n, n2, n3, n4, n5, n6, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, direct2 ? buffer2 : Buffers.getArray(buffer2), direct2 ? Buffers.getDirectBufferByteOffset(buffer2) : Buffers.getIndirectBufferByteOffset(buffer2), direct2, addressof_glSeparableFilter2D);
    }
    
    private native void dispatch_glSeparableFilter2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glSeparableFilter2D(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7, final long n8) {
        this.checkUnpackPBOBound(true);
        final long addressof_glSeparableFilter2D = this._pat._addressof_glSeparableFilter2D;
        if (addressof_glSeparableFilter2D == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSeparableFilter2D"));
        }
        this.dispatch_glSeparableFilter2D1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glSeparableFilter2D);
    }
    
    private native void dispatch_glSeparableFilter2D1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7, final long p8);
    
    @Override
    public void glGetHistogram(final int n, final boolean b, final int n2, final int n3, final Buffer buffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetHistogram = this._pat._addressof_glGetHistogram;
        if (addressof_glGetHistogram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetHistogram"));
        }
        this.dispatch_glGetHistogram1(n, b, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetHistogram);
    }
    
    private native void dispatch_glGetHistogram1(final int p0, final boolean p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetHistogram(final int n, final boolean b, final int n2, final int n3, final long n4) {
        this.checkPackPBOBound(true);
        final long addressof_glGetHistogram = this._pat._addressof_glGetHistogram;
        if (addressof_glGetHistogram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetHistogram"));
        }
        this.dispatch_glGetHistogram1(n, b, n2, n3, n4, addressof_glGetHistogram);
    }
    
    private native void dispatch_glGetHistogram1(final int p0, final boolean p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glGetHistogramParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetHistogramParameterfv = this._pat._addressof_glGetHistogramParameterfv;
        if (addressof_glGetHistogramParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameterfv"));
        }
        this.dispatch_glGetHistogramParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetHistogramParameterfv);
    }
    
    private native void dispatch_glGetHistogramParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetHistogramParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetHistogramParameterfv = this._pat._addressof_glGetHistogramParameterfv;
        if (addressof_glGetHistogramParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameterfv"));
        }
        this.dispatch_glGetHistogramParameterfv1(n, n2, array, 4 * n3, false, addressof_glGetHistogramParameterfv);
    }
    
    @Override
    public void glGetHistogramParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetHistogramParameteriv = this._pat._addressof_glGetHistogramParameteriv;
        if (addressof_glGetHistogramParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameteriv"));
        }
        this.dispatch_glGetHistogramParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetHistogramParameteriv);
    }
    
    private native void dispatch_glGetHistogramParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetHistogramParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetHistogramParameteriv = this._pat._addressof_glGetHistogramParameteriv;
        if (addressof_glGetHistogramParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameteriv"));
        }
        this.dispatch_glGetHistogramParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetHistogramParameteriv);
    }
    
    @Override
    public void glGetMinmax(final int n, final boolean b, final int n2, final int n3, final Buffer buffer) {
        this.checkPackPBOUnbound(true);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetMinmax = this._pat._addressof_glGetMinmax;
        if (addressof_glGetMinmax == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMinmax"));
        }
        this.dispatch_glGetMinmax1(n, b, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetMinmax);
    }
    
    private native void dispatch_glGetMinmax1(final int p0, final boolean p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetMinmax(final int n, final boolean b, final int n2, final int n3, final long n4) {
        this.checkPackPBOBound(true);
        final long addressof_glGetMinmax = this._pat._addressof_glGetMinmax;
        if (addressof_glGetMinmax == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMinmax"));
        }
        this.dispatch_glGetMinmax1(n, b, n2, n3, n4, addressof_glGetMinmax);
    }
    
    private native void dispatch_glGetMinmax1(final int p0, final boolean p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glGetMinmaxParameterfv(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMinmaxParameterfv = this._pat._addressof_glGetMinmaxParameterfv;
        if (addressof_glGetMinmaxParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameterfv"));
        }
        this.dispatch_glGetMinmaxParameterfv1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMinmaxParameterfv);
    }
    
    private native void dispatch_glGetMinmaxParameterfv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMinmaxParameterfv(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMinmaxParameterfv = this._pat._addressof_glGetMinmaxParameterfv;
        if (addressof_glGetMinmaxParameterfv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameterfv"));
        }
        this.dispatch_glGetMinmaxParameterfv1(n, n2, array, 4 * n3, false, addressof_glGetMinmaxParameterfv);
    }
    
    @Override
    public void glGetMinmaxParameteriv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMinmaxParameteriv = this._pat._addressof_glGetMinmaxParameteriv;
        if (addressof_glGetMinmaxParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameteriv"));
        }
        this.dispatch_glGetMinmaxParameteriv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMinmaxParameteriv);
    }
    
    private native void dispatch_glGetMinmaxParameteriv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMinmaxParameteriv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMinmaxParameteriv = this._pat._addressof_glGetMinmaxParameteriv;
        if (addressof_glGetMinmaxParameteriv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameteriv"));
        }
        this.dispatch_glGetMinmaxParameteriv1(n, n2, array, 4 * n3, false, addressof_glGetMinmaxParameteriv);
    }
    
    @Override
    public void glHistogram(final int n, final int n2, final int n3, final boolean b) {
        final long addressof_glHistogram = this._pat._addressof_glHistogram;
        if (addressof_glHistogram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glHistogram"));
        }
        this.dispatch_glHistogram1(n, n2, n3, b, addressof_glHistogram);
    }
    
    private native void dispatch_glHistogram1(final int p0, final int p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMinmax(final int n, final int n2, final boolean b) {
        final long addressof_glMinmax = this._pat._addressof_glMinmax;
        if (addressof_glMinmax == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMinmax"));
        }
        this.dispatch_glMinmax1(n, n2, b, addressof_glMinmax);
    }
    
    private native void dispatch_glMinmax1(final int p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glResetHistogram(final int n) {
        final long addressof_glResetHistogram = this._pat._addressof_glResetHistogram;
        if (addressof_glResetHistogram == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glResetHistogram"));
        }
        this.dispatch_glResetHistogram1(n, addressof_glResetHistogram);
    }
    
    private native void dispatch_glResetHistogram1(final int p0, final long p1);
    
    @Override
    public void glResetMinmax(final int n) {
        final long addressof_glResetMinmax = this._pat._addressof_glResetMinmax;
        if (addressof_glResetMinmax == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glResetMinmax"));
        }
        this.dispatch_glResetMinmax1(n, addressof_glResetMinmax);
    }
    
    private native void dispatch_glResetMinmax1(final int p0, final long p1);
    
    @Override
    public void glMultiDrawArraysIndirectCountARB(final int n, final long n2, final long n3, final int n4, final int n5) {
        final long addressof_glMultiDrawArraysIndirectCountARB = this._pat._addressof_glMultiDrawArraysIndirectCountARB;
        if (addressof_glMultiDrawArraysIndirectCountARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectCountARB"));
        }
        this.dispatch_glMultiDrawArraysIndirectCountARB1(n, n2, n3, n4, n5, addressof_glMultiDrawArraysIndirectCountARB);
    }
    
    private native void dispatch_glMultiDrawArraysIndirectCountARB1(final int p0, final long p1, final long p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glMultiDrawElementsIndirectCountARB(final int n, final int n2, final long n3, final long n4, final int n5, final int n6) {
        final long addressof_glMultiDrawElementsIndirectCountARB = this._pat._addressof_glMultiDrawElementsIndirectCountARB;
        if (addressof_glMultiDrawElementsIndirectCountARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectCountARB"));
        }
        this.dispatch_glMultiDrawElementsIndirectCountARB1(n, n2, n3, n4, n5, n6, addressof_glMultiDrawElementsIndirectCountARB);
    }
    
    private native void dispatch_glMultiDrawElementsIndirectCountARB1(final int p0, final int p1, final long p2, final long p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glCurrentPaletteMatrixARB(final int n) {
        final long addressof_glCurrentPaletteMatrixARB = this._pat._addressof_glCurrentPaletteMatrixARB;
        if (addressof_glCurrentPaletteMatrixARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCurrentPaletteMatrixARB"));
        }
        this.dispatch_glCurrentPaletteMatrixARB1(n, addressof_glCurrentPaletteMatrixARB);
    }
    
    private native void dispatch_glCurrentPaletteMatrixARB1(final int p0, final long p1);
    
    @Override
    public void glMatrixIndexubvARB(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glMatrixIndexubvARB = this._pat._addressof_glMatrixIndexubvARB;
        if (addressof_glMatrixIndexubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexubvARB"));
        }
        this.dispatch_glMatrixIndexubvARB1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glMatrixIndexubvARB);
    }
    
    private native void dispatch_glMatrixIndexubvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixIndexubvARB(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"indices_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixIndexubvARB = this._pat._addressof_glMatrixIndexubvARB;
        if (addressof_glMatrixIndexubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexubvARB"));
        }
        this.dispatch_glMatrixIndexubvARB1(n, array, n2, false, addressof_glMatrixIndexubvARB);
    }
    
    @Override
    public void glMatrixIndexusvARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMatrixIndexusvARB = this._pat._addressof_glMatrixIndexusvARB;
        if (addressof_glMatrixIndexusvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexusvARB"));
        }
        this.dispatch_glMatrixIndexusvARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMatrixIndexusvARB);
    }
    
    private native void dispatch_glMatrixIndexusvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixIndexusvARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"indices_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixIndexusvARB = this._pat._addressof_glMatrixIndexusvARB;
        if (addressof_glMatrixIndexusvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexusvARB"));
        }
        this.dispatch_glMatrixIndexusvARB1(n, array, 2 * n2, false, addressof_glMatrixIndexusvARB);
    }
    
    @Override
    public void glMatrixIndexuivARB(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMatrixIndexuivARB = this._pat._addressof_glMatrixIndexuivARB;
        if (addressof_glMatrixIndexuivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexuivARB"));
        }
        this.dispatch_glMatrixIndexuivARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMatrixIndexuivARB);
    }
    
    private native void dispatch_glMatrixIndexuivARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixIndexuivARB(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"indices_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixIndexuivARB = this._pat._addressof_glMatrixIndexuivARB;
        if (addressof_glMatrixIndexuivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexuivARB"));
        }
        this.dispatch_glMatrixIndexuivARB1(n, array, 4 * n2, false, addressof_glMatrixIndexuivARB);
    }
    
    @Override
    public void glMatrixIndexPointerARB(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glMatrixIndexPointerARB = this._pat._addressof_glMatrixIndexPointerARB;
        if (addressof_glMatrixIndexPointerARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexPointerARB"));
        }
        this.dispatch_glMatrixIndexPointerARB0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glMatrixIndexPointerARB);
    }
    
    private native void dispatch_glMatrixIndexPointerARB0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glMatrixIndexPointerARB(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glMatrixIndexPointerARB = this._pat._addressof_glMatrixIndexPointerARB;
        if (addressof_glMatrixIndexPointerARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexPointerARB"));
        }
        this.dispatch_glMatrixIndexPointerARB0(n, n2, n3, n4, addressof_glMatrixIndexPointerARB);
    }
    
    private native void dispatch_glMatrixIndexPointerARB0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glMaxShaderCompilerThreadsARB(final int n) {
        final long addressof_glMaxShaderCompilerThreadsARB = this._pat._addressof_glMaxShaderCompilerThreadsARB;
        if (addressof_glMaxShaderCompilerThreadsARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMaxShaderCompilerThreadsARB"));
        }
        this.dispatch_glMaxShaderCompilerThreadsARB1(n, addressof_glMaxShaderCompilerThreadsARB);
    }
    
    private native void dispatch_glMaxShaderCompilerThreadsARB1(final int p0, final long p1);
    
    @Override
    public void glFramebufferSampleLocationsfvARB(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glFramebufferSampleLocationsfvARB = this._pat._addressof_glFramebufferSampleLocationsfvARB;
        if (addressof_glFramebufferSampleLocationsfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvARB"));
        }
        this.dispatch_glFramebufferSampleLocationsfvARB1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glFramebufferSampleLocationsfvARB);
    }
    
    private native void dispatch_glFramebufferSampleLocationsfvARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glFramebufferSampleLocationsfvARB(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"v_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFramebufferSampleLocationsfvARB = this._pat._addressof_glFramebufferSampleLocationsfvARB;
        if (addressof_glFramebufferSampleLocationsfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvARB"));
        }
        this.dispatch_glFramebufferSampleLocationsfvARB1(n, n2, n3, array, 4 * n4, false, addressof_glFramebufferSampleLocationsfvARB);
    }
    
    @Override
    public void glNamedFramebufferSampleLocationsfvARB(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glNamedFramebufferSampleLocationsfvARB = this._pat._addressof_glNamedFramebufferSampleLocationsfvARB;
        if (addressof_glNamedFramebufferSampleLocationsfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvARB"));
        }
        this.dispatch_glNamedFramebufferSampleLocationsfvARB1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glNamedFramebufferSampleLocationsfvARB);
    }
    
    private native void dispatch_glNamedFramebufferSampleLocationsfvARB1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glNamedFramebufferSampleLocationsfvARB(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"v_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedFramebufferSampleLocationsfvARB = this._pat._addressof_glNamedFramebufferSampleLocationsfvARB;
        if (addressof_glNamedFramebufferSampleLocationsfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvARB"));
        }
        this.dispatch_glNamedFramebufferSampleLocationsfvARB1(n, n2, n3, array, 4 * n4, false, addressof_glNamedFramebufferSampleLocationsfvARB);
    }
    
    @Override
    public void glEvaluateDepthValuesARB() {
        final long addressof_glEvaluateDepthValuesARB = this._pat._addressof_glEvaluateDepthValuesARB;
        if (addressof_glEvaluateDepthValuesARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvaluateDepthValuesARB"));
        }
        this.dispatch_glEvaluateDepthValuesARB1(addressof_glEvaluateDepthValuesARB);
    }
    
    private native void dispatch_glEvaluateDepthValuesARB1(final long p0);
    
    @Override
    public void glDeleteObjectARB(final long n) {
        final long addressof_glDeleteObjectARB = this._pat._addressof_glDeleteObjectARB;
        if (addressof_glDeleteObjectARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteObjectARB"));
        }
        this.dispatch_glDeleteObjectARB1(n, addressof_glDeleteObjectARB);
    }
    
    private native void dispatch_glDeleteObjectARB1(final long p0, final long p1);
    
    @Override
    public long glGetHandleARB(final int n) {
        final long addressof_glGetHandleARB = this._pat._addressof_glGetHandleARB;
        if (addressof_glGetHandleARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetHandleARB"));
        }
        return this.dispatch_glGetHandleARB1(n, addressof_glGetHandleARB);
    }
    
    private native long dispatch_glGetHandleARB1(final int p0, final long p1);
    
    @Override
    public void glDetachObjectARB(final long n, final long n2) {
        final long addressof_glDetachObjectARB = this._pat._addressof_glDetachObjectARB;
        if (addressof_glDetachObjectARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDetachObjectARB"));
        }
        this.dispatch_glDetachObjectARB1(n, n2, addressof_glDetachObjectARB);
    }
    
    private native void dispatch_glDetachObjectARB1(final long p0, final long p1, final long p2);
    
    @Override
    public long glCreateShaderObjectARB(final int n) {
        final long addressof_glCreateShaderObjectARB = this._pat._addressof_glCreateShaderObjectARB;
        if (addressof_glCreateShaderObjectARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateShaderObjectARB"));
        }
        return this.dispatch_glCreateShaderObjectARB1(n, addressof_glCreateShaderObjectARB);
    }
    
    private native long dispatch_glCreateShaderObjectARB1(final int p0, final long p1);
    
    @Override
    public void glShaderSourceARB(final long n, final int n2, final String[] array, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glShaderSourceARB = this._pat._addressof_glShaderSourceARB;
        if (addressof_glShaderSourceARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderSourceARB"));
        }
        this.dispatch_glShaderSourceARB1(n, n2, array, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glShaderSourceARB);
    }
    
    private native void dispatch_glShaderSourceARB1(final long p0, final int p1, final String[] p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glShaderSourceARB(final long n, final int n2, final String[] array, final int[] array2, final int n3) {
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glShaderSourceARB = this._pat._addressof_glShaderSourceARB;
        if (addressof_glShaderSourceARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderSourceARB"));
        }
        this.dispatch_glShaderSourceARB1(n, n2, array, array2, 4 * n3, false, addressof_glShaderSourceARB);
    }
    
    @Override
    public void glCompileShaderARB(final long n) {
        final long addressof_glCompileShaderARB = this._pat._addressof_glCompileShaderARB;
        if (addressof_glCompileShaderARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompileShaderARB"));
        }
        this.dispatch_glCompileShaderARB1(n, addressof_glCompileShaderARB);
    }
    
    private native void dispatch_glCompileShaderARB1(final long p0, final long p1);
    
    @Override
    public long glCreateProgramObjectARB() {
        final long addressof_glCreateProgramObjectARB = this._pat._addressof_glCreateProgramObjectARB;
        if (addressof_glCreateProgramObjectARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateProgramObjectARB"));
        }
        return this.dispatch_glCreateProgramObjectARB1(addressof_glCreateProgramObjectARB);
    }
    
    private native long dispatch_glCreateProgramObjectARB1(final long p0);
    
    @Override
    public void glAttachObjectARB(final long n, final long n2) {
        final long addressof_glAttachObjectARB = this._pat._addressof_glAttachObjectARB;
        if (addressof_glAttachObjectARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glAttachObjectARB"));
        }
        this.dispatch_glAttachObjectARB1(n, n2, addressof_glAttachObjectARB);
    }
    
    private native void dispatch_glAttachObjectARB1(final long p0, final long p1, final long p2);
    
    @Override
    public void glLinkProgramARB(final long n) {
        final long addressof_glLinkProgramARB = this._pat._addressof_glLinkProgramARB;
        if (addressof_glLinkProgramARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLinkProgramARB"));
        }
        this.dispatch_glLinkProgramARB1(n, addressof_glLinkProgramARB);
    }
    
    private native void dispatch_glLinkProgramARB1(final long p0, final long p1);
    
    @Override
    public void glUseProgramObjectARB(final long n) {
        final long addressof_glUseProgramObjectARB = this._pat._addressof_glUseProgramObjectARB;
        if (addressof_glUseProgramObjectARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUseProgramObjectARB"));
        }
        this.dispatch_glUseProgramObjectARB1(n, addressof_glUseProgramObjectARB);
    }
    
    private native void dispatch_glUseProgramObjectARB1(final long p0, final long p1);
    
    @Override
    public void glValidateProgramARB(final long n) {
        final long addressof_glValidateProgramARB = this._pat._addressof_glValidateProgramARB;
        if (addressof_glValidateProgramARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glValidateProgramARB"));
        }
        this.dispatch_glValidateProgramARB1(n, addressof_glValidateProgramARB);
    }
    
    private native void dispatch_glValidateProgramARB1(final long p0, final long p1);
    
    @Override
    public void glUniform1fARB(final int n, final float n2) {
        final long addressof_glUniform1fARB = this._pat._addressof_glUniform1fARB;
        if (addressof_glUniform1fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1fARB"));
        }
        this.dispatch_glUniform1fARB1(n, n2, addressof_glUniform1fARB);
    }
    
    private native void dispatch_glUniform1fARB1(final int p0, final float p1, final long p2);
    
    @Override
    public void glUniform2fARB(final int n, final float n2, final float n3) {
        final long addressof_glUniform2fARB = this._pat._addressof_glUniform2fARB;
        if (addressof_glUniform2fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2fARB"));
        }
        this.dispatch_glUniform2fARB1(n, n2, n3, addressof_glUniform2fARB);
    }
    
    private native void dispatch_glUniform2fARB1(final int p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glUniform3fARB(final int n, final float n2, final float n3, final float n4) {
        final long addressof_glUniform3fARB = this._pat._addressof_glUniform3fARB;
        if (addressof_glUniform3fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3fARB"));
        }
        this.dispatch_glUniform3fARB1(n, n2, n3, n4, addressof_glUniform3fARB);
    }
    
    private native void dispatch_glUniform3fARB1(final int p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glUniform4fARB(final int n, final float n2, final float n3, final float n4, final float n5) {
        final long addressof_glUniform4fARB = this._pat._addressof_glUniform4fARB;
        if (addressof_glUniform4fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4fARB"));
        }
        this.dispatch_glUniform4fARB1(n, n2, n3, n4, n5, addressof_glUniform4fARB);
    }
    
    private native void dispatch_glUniform4fARB1(final int p0, final float p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glUniform1iARB(final int n, final int n2) {
        final long addressof_glUniform1iARB = this._pat._addressof_glUniform1iARB;
        if (addressof_glUniform1iARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1iARB"));
        }
        this.dispatch_glUniform1iARB1(n, n2, addressof_glUniform1iARB);
    }
    
    private native void dispatch_glUniform1iARB1(final int p0, final int p1, final long p2);
    
    @Override
    public void glUniform2iARB(final int n, final int n2, final int n3) {
        final long addressof_glUniform2iARB = this._pat._addressof_glUniform2iARB;
        if (addressof_glUniform2iARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2iARB"));
        }
        this.dispatch_glUniform2iARB1(n, n2, n3, addressof_glUniform2iARB);
    }
    
    private native void dispatch_glUniform2iARB1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glUniform3iARB(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glUniform3iARB = this._pat._addressof_glUniform3iARB;
        if (addressof_glUniform3iARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3iARB"));
        }
        this.dispatch_glUniform3iARB1(n, n2, n3, n4, addressof_glUniform3iARB);
    }
    
    private native void dispatch_glUniform3iARB1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glUniform4iARB(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glUniform4iARB = this._pat._addressof_glUniform4iARB;
        if (addressof_glUniform4iARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4iARB"));
        }
        this.dispatch_glUniform4iARB1(n, n2, n3, n4, n5, addressof_glUniform4iARB);
    }
    
    private native void dispatch_glUniform4iARB1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glUniform1fvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform1fvARB = this._pat._addressof_glUniform1fvARB;
        if (addressof_glUniform1fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1fvARB"));
        }
        this.dispatch_glUniform1fvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform1fvARB);
    }
    
    private native void dispatch_glUniform1fvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1fvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1fvARB = this._pat._addressof_glUniform1fvARB;
        if (addressof_glUniform1fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1fvARB"));
        }
        this.dispatch_glUniform1fvARB1(n, n2, array, 4 * n3, false, addressof_glUniform1fvARB);
    }
    
    @Override
    public void glUniform2fvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform2fvARB = this._pat._addressof_glUniform2fvARB;
        if (addressof_glUniform2fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2fvARB"));
        }
        this.dispatch_glUniform2fvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform2fvARB);
    }
    
    private native void dispatch_glUniform2fvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2fvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2fvARB = this._pat._addressof_glUniform2fvARB;
        if (addressof_glUniform2fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2fvARB"));
        }
        this.dispatch_glUniform2fvARB1(n, n2, array, 4 * n3, false, addressof_glUniform2fvARB);
    }
    
    @Override
    public void glUniform3fvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform3fvARB = this._pat._addressof_glUniform3fvARB;
        if (addressof_glUniform3fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3fvARB"));
        }
        this.dispatch_glUniform3fvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform3fvARB);
    }
    
    private native void dispatch_glUniform3fvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3fvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3fvARB = this._pat._addressof_glUniform3fvARB;
        if (addressof_glUniform3fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3fvARB"));
        }
        this.dispatch_glUniform3fvARB1(n, n2, array, 4 * n3, false, addressof_glUniform3fvARB);
    }
    
    @Override
    public void glUniform4fvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniform4fvARB = this._pat._addressof_glUniform4fvARB;
        if (addressof_glUniform4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4fvARB"));
        }
        this.dispatch_glUniform4fvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniform4fvARB);
    }
    
    private native void dispatch_glUniform4fvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4fvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4fvARB = this._pat._addressof_glUniform4fvARB;
        if (addressof_glUniform4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4fvARB"));
        }
        this.dispatch_glUniform4fvARB1(n, n2, array, 4 * n3, false, addressof_glUniform4fvARB);
    }
    
    @Override
    public void glUniform1ivARB(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform1ivARB = this._pat._addressof_glUniform1ivARB;
        if (addressof_glUniform1ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ivARB"));
        }
        this.dispatch_glUniform1ivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform1ivARB);
    }
    
    private native void dispatch_glUniform1ivARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1ivARB(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1ivARB = this._pat._addressof_glUniform1ivARB;
        if (addressof_glUniform1ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ivARB"));
        }
        this.dispatch_glUniform1ivARB1(n, n2, array, 4 * n3, false, addressof_glUniform1ivARB);
    }
    
    @Override
    public void glUniform2ivARB(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform2ivARB = this._pat._addressof_glUniform2ivARB;
        if (addressof_glUniform2ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ivARB"));
        }
        this.dispatch_glUniform2ivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform2ivARB);
    }
    
    private native void dispatch_glUniform2ivARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2ivARB(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2ivARB = this._pat._addressof_glUniform2ivARB;
        if (addressof_glUniform2ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ivARB"));
        }
        this.dispatch_glUniform2ivARB1(n, n2, array, 4 * n3, false, addressof_glUniform2ivARB);
    }
    
    @Override
    public void glUniform3ivARB(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform3ivARB = this._pat._addressof_glUniform3ivARB;
        if (addressof_glUniform3ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ivARB"));
        }
        this.dispatch_glUniform3ivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform3ivARB);
    }
    
    private native void dispatch_glUniform3ivARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3ivARB(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3ivARB = this._pat._addressof_glUniform3ivARB;
        if (addressof_glUniform3ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ivARB"));
        }
        this.dispatch_glUniform3ivARB1(n, n2, array, 4 * n3, false, addressof_glUniform3ivARB);
    }
    
    @Override
    public void glUniform4ivARB(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glUniform4ivARB = this._pat._addressof_glUniform4ivARB;
        if (addressof_glUniform4ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ivARB"));
        }
        this.dispatch_glUniform4ivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glUniform4ivARB);
    }
    
    private native void dispatch_glUniform4ivARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4ivARB(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4ivARB = this._pat._addressof_glUniform4ivARB;
        if (addressof_glUniform4ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ivARB"));
        }
        this.dispatch_glUniform4ivARB1(n, n2, array, 4 * n3, false, addressof_glUniform4ivARB);
    }
    
    @Override
    public void glUniformMatrix2fvARB(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix2fvARB = this._pat._addressof_glUniformMatrix2fvARB;
        if (addressof_glUniformMatrix2fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fvARB"));
        }
        this.dispatch_glUniformMatrix2fvARB1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix2fvARB);
    }
    
    private native void dispatch_glUniformMatrix2fvARB1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix2fvARB(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix2fvARB = this._pat._addressof_glUniformMatrix2fvARB;
        if (addressof_glUniformMatrix2fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fvARB"));
        }
        this.dispatch_glUniformMatrix2fvARB1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix2fvARB);
    }
    
    @Override
    public void glUniformMatrix3fvARB(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix3fvARB = this._pat._addressof_glUniformMatrix3fvARB;
        if (addressof_glUniformMatrix3fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fvARB"));
        }
        this.dispatch_glUniformMatrix3fvARB1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix3fvARB);
    }
    
    private native void dispatch_glUniformMatrix3fvARB1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix3fvARB(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix3fvARB = this._pat._addressof_glUniformMatrix3fvARB;
        if (addressof_glUniformMatrix3fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fvARB"));
        }
        this.dispatch_glUniformMatrix3fvARB1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix3fvARB);
    }
    
    @Override
    public void glUniformMatrix4fvARB(final int n, final int n2, final boolean b, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glUniformMatrix4fvARB = this._pat._addressof_glUniformMatrix4fvARB;
        if (addressof_glUniformMatrix4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fvARB"));
        }
        this.dispatch_glUniformMatrix4fvARB1(n, n2, b, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glUniformMatrix4fvARB);
    }
    
    private native void dispatch_glUniformMatrix4fvARB1(final int p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glUniformMatrix4fvARB(final int n, final int n2, final boolean b, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformMatrix4fvARB = this._pat._addressof_glUniformMatrix4fvARB;
        if (addressof_glUniformMatrix4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fvARB"));
        }
        this.dispatch_glUniformMatrix4fvARB1(n, n2, b, array, 4 * n3, false, addressof_glUniformMatrix4fvARB);
    }
    
    @Override
    public void glGetObjectParameterfvARB(final long n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetObjectParameterfvARB = this._pat._addressof_glGetObjectParameterfvARB;
        if (addressof_glGetObjectParameterfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterfvARB"));
        }
        this.dispatch_glGetObjectParameterfvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetObjectParameterfvARB);
    }
    
    private native void dispatch_glGetObjectParameterfvARB1(final long p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetObjectParameterfvARB(final long n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetObjectParameterfvARB = this._pat._addressof_glGetObjectParameterfvARB;
        if (addressof_glGetObjectParameterfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterfvARB"));
        }
        this.dispatch_glGetObjectParameterfvARB1(n, n2, array, 4 * n3, false, addressof_glGetObjectParameterfvARB);
    }
    
    @Override
    public void glGetObjectParameterivARB(final long n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetObjectParameterivARB = this._pat._addressof_glGetObjectParameterivARB;
        if (addressof_glGetObjectParameterivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivARB"));
        }
        this.dispatch_glGetObjectParameterivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetObjectParameterivARB);
    }
    
    private native void dispatch_glGetObjectParameterivARB1(final long p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetObjectParameterivARB(final long n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetObjectParameterivARB = this._pat._addressof_glGetObjectParameterivARB;
        if (addressof_glGetObjectParameterivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivARB"));
        }
        this.dispatch_glGetObjectParameterivARB1(n, n2, array, 4 * n3, false, addressof_glGetObjectParameterivARB);
    }
    
    @Override
    public void glGetInfoLogARB(final long n, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetInfoLogARB = this._pat._addressof_glGetInfoLogARB;
        if (addressof_glGetInfoLogARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInfoLogARB"));
        }
        this.dispatch_glGetInfoLogARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetInfoLogARB);
    }
    
    private native void dispatch_glGetInfoLogARB1(final long p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetInfoLogARB(final long n, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"infoLog_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetInfoLogARB = this._pat._addressof_glGetInfoLogARB;
        if (addressof_glGetInfoLogARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInfoLogARB"));
        }
        this.dispatch_glGetInfoLogARB1(n, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetInfoLogARB);
    }
    
    @Override
    public void glGetAttachedObjectsARB(final long n, final int n2, final IntBuffer intBuffer, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(longBuffer);
        final long addressof_glGetAttachedObjectsARB = this._pat._addressof_glGetAttachedObjectsARB;
        if (addressof_glGetAttachedObjectsARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedObjectsARB"));
        }
        this.dispatch_glGetAttachedObjectsARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? longBuffer : Buffers.getArray(longBuffer), direct2 ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct2, addressof_glGetAttachedObjectsARB);
    }
    
    private native void dispatch_glGetAttachedObjectsARB1(final long p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetAttachedObjectsARB(final long n, final int n2, final int[] array, final int n3, final long[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"count_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"obj_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetAttachedObjectsARB = this._pat._addressof_glGetAttachedObjectsARB;
        if (addressof_glGetAttachedObjectsARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedObjectsARB"));
        }
        this.dispatch_glGetAttachedObjectsARB1(n, n2, array, 4 * n3, false, array2, 8 * n4, false, addressof_glGetAttachedObjectsARB);
    }
    
    @Override
    public int glGetUniformLocationARB(final long n, final String s) {
        final long addressof_glGetUniformLocationARB = this._pat._addressof_glGetUniformLocationARB;
        if (addressof_glGetUniformLocationARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformLocationARB"));
        }
        return this.dispatch_glGetUniformLocationARB1(n, s, addressof_glGetUniformLocationARB);
    }
    
    private native int dispatch_glGetUniformLocationARB1(final long p0, final String p1, final long p2);
    
    @Override
    public void glGetActiveUniformARB(final long n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final boolean direct4 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetActiveUniformARB = this._pat._addressof_glGetActiveUniformARB;
        if (addressof_glGetActiveUniformARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformARB"));
        }
        this.dispatch_glGetActiveUniformARB1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, direct4 ? byteBuffer : Buffers.getArray(byteBuffer), direct4 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct4, addressof_glGetActiveUniformARB);
    }
    
    private native void dispatch_glGetActiveUniformARB1(final long p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final Object p12, final int p13, final boolean p14, final long p15);
    
    @Override
    public void glGetActiveUniformARB(final long n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5, final int[] array3, final int n6, final byte[] array4, final int n7) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"size_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n6) {
            throw new GLException("array offset argument \"type_offset\" (" + n6 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n7) {
            throw new GLException("array offset argument \"name_offset\" (" + n7 + ") equals or exceeds array length (" + array4.length + ")");
        }
        final long addressof_glGetActiveUniformARB = this._pat._addressof_glGetActiveUniformARB;
        if (addressof_glGetActiveUniformARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformARB"));
        }
        this.dispatch_glGetActiveUniformARB1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, array3, 4 * n6, false, array4, n7, false, addressof_glGetActiveUniformARB);
    }
    
    @Override
    public void glGetUniformfvARB(final long n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetUniformfvARB = this._pat._addressof_glGetUniformfvARB;
        if (addressof_glGetUniformfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfvARB"));
        }
        this.dispatch_glGetUniformfvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetUniformfvARB);
    }
    
    private native void dispatch_glGetUniformfvARB1(final long p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformfvARB(final long n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformfvARB = this._pat._addressof_glGetUniformfvARB;
        if (addressof_glGetUniformfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfvARB"));
        }
        this.dispatch_glGetUniformfvARB1(n, n2, array, 4 * n3, false, addressof_glGetUniformfvARB);
    }
    
    @Override
    public void glGetUniformivARB(final long n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetUniformivARB = this._pat._addressof_glGetUniformivARB;
        if (addressof_glGetUniformivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformivARB"));
        }
        this.dispatch_glGetUniformivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetUniformivARB);
    }
    
    private native void dispatch_glGetUniformivARB1(final long p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformivARB(final long n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformivARB = this._pat._addressof_glGetUniformivARB;
        if (addressof_glGetUniformivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformivARB"));
        }
        this.dispatch_glGetUniformivARB1(n, n2, array, 4 * n3, false, addressof_glGetUniformivARB);
    }
    
    @Override
    public void glGetShaderSourceARB(final long n, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetShaderSourceARB = this._pat._addressof_glGetShaderSourceARB;
        if (addressof_glGetShaderSourceARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSourceARB"));
        }
        this.dispatch_glGetShaderSourceARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetShaderSourceARB);
    }
    
    private native void dispatch_glGetShaderSourceARB1(final long p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetShaderSourceARB(final long n, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"source_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetShaderSourceARB = this._pat._addressof_glGetShaderSourceARB;
        if (addressof_glGetShaderSourceARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSourceARB"));
        }
        this.dispatch_glGetShaderSourceARB1(n, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetShaderSourceARB);
    }
    
    @Override
    public void glNamedStringARB(final int n, final int n2, final String s, final int n3, final String s2) {
        final long addressof_glNamedStringARB = this._pat._addressof_glNamedStringARB;
        if (addressof_glNamedStringARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedStringARB"));
        }
        this.dispatch_glNamedStringARB1(n, n2, s, n3, s2, addressof_glNamedStringARB);
    }
    
    private native void dispatch_glNamedStringARB1(final int p0, final int p1, final String p2, final int p3, final String p4, final long p5);
    
    @Override
    public void glDeleteNamedStringARB(final int n, final String s) {
        final long addressof_glDeleteNamedStringARB = this._pat._addressof_glDeleteNamedStringARB;
        if (addressof_glDeleteNamedStringARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteNamedStringARB"));
        }
        this.dispatch_glDeleteNamedStringARB1(n, s, addressof_glDeleteNamedStringARB);
    }
    
    private native void dispatch_glDeleteNamedStringARB1(final int p0, final String p1, final long p2);
    
    @Override
    public void glCompileShaderIncludeARB(final int n, final int n2, final String[] array, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCompileShaderIncludeARB = this._pat._addressof_glCompileShaderIncludeARB;
        if (addressof_glCompileShaderIncludeARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompileShaderIncludeARB"));
        }
        this.dispatch_glCompileShaderIncludeARB1(n, n2, array, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCompileShaderIncludeARB);
    }
    
    private native void dispatch_glCompileShaderIncludeARB1(final int p0, final int p1, final String[] p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glCompileShaderIncludeARB(final int n, final int n2, final String[] array, final int[] array2, final int n3) {
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glCompileShaderIncludeARB = this._pat._addressof_glCompileShaderIncludeARB;
        if (addressof_glCompileShaderIncludeARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompileShaderIncludeARB"));
        }
        this.dispatch_glCompileShaderIncludeARB1(n, n2, array, array2, 4 * n3, false, addressof_glCompileShaderIncludeARB);
    }
    
    @Override
    public boolean glIsNamedStringARB(final int n, final String s) {
        final long addressof_glIsNamedStringARB = this._pat._addressof_glIsNamedStringARB;
        if (addressof_glIsNamedStringARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsNamedStringARB"));
        }
        return this.dispatch_glIsNamedStringARB1(n, s, addressof_glIsNamedStringARB);
    }
    
    private native boolean dispatch_glIsNamedStringARB1(final int p0, final String p1, final long p2);
    
    @Override
    public void glGetNamedStringARB(final int n, final String s, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetNamedStringARB = this._pat._addressof_glGetNamedStringARB;
        if (addressof_glGetNamedStringARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringARB"));
        }
        this.dispatch_glGetNamedStringARB1(n, s, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetNamedStringARB);
    }
    
    private native void dispatch_glGetNamedStringARB1(final int p0, final String p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetNamedStringARB(final int n, final String s, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"stringlen_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"string_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetNamedStringARB = this._pat._addressof_glGetNamedStringARB;
        if (addressof_glGetNamedStringARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringARB"));
        }
        this.dispatch_glGetNamedStringARB1(n, s, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetNamedStringARB);
    }
    
    @Override
    public void glGetNamedStringivARB(final int n, final String s, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedStringivARB = this._pat._addressof_glGetNamedStringivARB;
        if (addressof_glGetNamedStringivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringivARB"));
        }
        this.dispatch_glGetNamedStringivARB1(n, s, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedStringivARB);
    }
    
    private native void dispatch_glGetNamedStringivARB1(final int p0, final String p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedStringivARB(final int n, final String s, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedStringivARB = this._pat._addressof_glGetNamedStringivARB;
        if (addressof_glGetNamedStringivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringivARB"));
        }
        this.dispatch_glGetNamedStringivARB1(n, s, n2, array, 4 * n3, false, addressof_glGetNamedStringivARB);
    }
    
    @Override
    public void glBufferPageCommitmentARB(final int n, final long n2, final long n3, final boolean b) {
        final long addressof_glBufferPageCommitmentARB = this._pat._addressof_glBufferPageCommitmentARB;
        if (addressof_glBufferPageCommitmentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBufferPageCommitmentARB"));
        }
        this.dispatch_glBufferPageCommitmentARB1(n, n2, n3, b, addressof_glBufferPageCommitmentARB);
    }
    
    private native void dispatch_glBufferPageCommitmentARB1(final int p0, final long p1, final long p2, final boolean p3, final long p4);
    
    @Override
    public void glNamedBufferPageCommitmentEXT(final int n, final long n2, final long n3, final boolean b) {
        final long addressof_glNamedBufferPageCommitmentEXT = this._pat._addressof_glNamedBufferPageCommitmentEXT;
        if (addressof_glNamedBufferPageCommitmentEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferPageCommitmentEXT"));
        }
        this.dispatch_glNamedBufferPageCommitmentEXT1(n, n2, n3, b, addressof_glNamedBufferPageCommitmentEXT);
    }
    
    private native void dispatch_glNamedBufferPageCommitmentEXT1(final int p0, final long p1, final long p2, final boolean p3, final long p4);
    
    @Override
    public void glNamedBufferPageCommitmentARB(final int n, final long n2, final long n3, final boolean b) {
        final long addressof_glNamedBufferPageCommitmentARB = this._pat._addressof_glNamedBufferPageCommitmentARB;
        if (addressof_glNamedBufferPageCommitmentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferPageCommitmentARB"));
        }
        this.dispatch_glNamedBufferPageCommitmentARB1(n, n2, n3, b, addressof_glNamedBufferPageCommitmentARB);
    }
    
    private native void dispatch_glNamedBufferPageCommitmentARB1(final int p0, final long p1, final long p2, final boolean p3, final long p4);
    
    @Override
    public void glTexPageCommitmentARB(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final boolean b) {
        final long addressof_glTexPageCommitmentARB = this._pat._addressof_glTexPageCommitmentARB;
        if (addressof_glTexPageCommitmentARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexPageCommitmentARB"));
        }
        this.dispatch_glTexPageCommitmentARB1(n, n2, n3, n4, n5, n6, n7, n8, b, addressof_glTexPageCommitmentARB);
    }
    
    private native void dispatch_glTexPageCommitmentARB1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glWeightbvARB(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glWeightbvARB = this._pat._addressof_glWeightbvARB;
        if (addressof_glWeightbvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightbvARB"));
        }
        this.dispatch_glWeightbvARB1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glWeightbvARB);
    }
    
    private native void dispatch_glWeightbvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightbvARB(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightbvARB = this._pat._addressof_glWeightbvARB;
        if (addressof_glWeightbvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightbvARB"));
        }
        this.dispatch_glWeightbvARB1(n, array, n2, false, addressof_glWeightbvARB);
    }
    
    @Override
    public void glWeightsvARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glWeightsvARB = this._pat._addressof_glWeightsvARB;
        if (addressof_glWeightsvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightsvARB"));
        }
        this.dispatch_glWeightsvARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glWeightsvARB);
    }
    
    private native void dispatch_glWeightsvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightsvARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightsvARB = this._pat._addressof_glWeightsvARB;
        if (addressof_glWeightsvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightsvARB"));
        }
        this.dispatch_glWeightsvARB1(n, array, 2 * n2, false, addressof_glWeightsvARB);
    }
    
    @Override
    public void glWeightivARB(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glWeightivARB = this._pat._addressof_glWeightivARB;
        if (addressof_glWeightivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightivARB"));
        }
        this.dispatch_glWeightivARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glWeightivARB);
    }
    
    private native void dispatch_glWeightivARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightivARB(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightivARB = this._pat._addressof_glWeightivARB;
        if (addressof_glWeightivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightivARB"));
        }
        this.dispatch_glWeightivARB1(n, array, 4 * n2, false, addressof_glWeightivARB);
    }
    
    @Override
    public void glWeightfvARB(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glWeightfvARB = this._pat._addressof_glWeightfvARB;
        if (addressof_glWeightfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightfvARB"));
        }
        this.dispatch_glWeightfvARB1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glWeightfvARB);
    }
    
    private native void dispatch_glWeightfvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightfvARB(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightfvARB = this._pat._addressof_glWeightfvARB;
        if (addressof_glWeightfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightfvARB"));
        }
        this.dispatch_glWeightfvARB1(n, array, 4 * n2, false, addressof_glWeightfvARB);
    }
    
    @Override
    public void glWeightdvARB(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glWeightdvARB = this._pat._addressof_glWeightdvARB;
        if (addressof_glWeightdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightdvARB"));
        }
        this.dispatch_glWeightdvARB1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glWeightdvARB);
    }
    
    private native void dispatch_glWeightdvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightdvARB(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightdvARB = this._pat._addressof_glWeightdvARB;
        if (addressof_glWeightdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightdvARB"));
        }
        this.dispatch_glWeightdvARB1(n, array, 8 * n2, false, addressof_glWeightdvARB);
    }
    
    @Override
    public void glWeightubvARB(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glWeightubvARB = this._pat._addressof_glWeightubvARB;
        if (addressof_glWeightubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightubvARB"));
        }
        this.dispatch_glWeightubvARB1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glWeightubvARB);
    }
    
    private native void dispatch_glWeightubvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightubvARB(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightubvARB = this._pat._addressof_glWeightubvARB;
        if (addressof_glWeightubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightubvARB"));
        }
        this.dispatch_glWeightubvARB1(n, array, n2, false, addressof_glWeightubvARB);
    }
    
    @Override
    public void glWeightusvARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glWeightusvARB = this._pat._addressof_glWeightusvARB;
        if (addressof_glWeightusvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightusvARB"));
        }
        this.dispatch_glWeightusvARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glWeightusvARB);
    }
    
    private native void dispatch_glWeightusvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightusvARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightusvARB = this._pat._addressof_glWeightusvARB;
        if (addressof_glWeightusvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightusvARB"));
        }
        this.dispatch_glWeightusvARB1(n, array, 2 * n2, false, addressof_glWeightusvARB);
    }
    
    @Override
    public void glWeightuivARB(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glWeightuivARB = this._pat._addressof_glWeightuivARB;
        if (addressof_glWeightuivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightuivARB"));
        }
        this.dispatch_glWeightuivARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glWeightuivARB);
    }
    
    private native void dispatch_glWeightuivARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glWeightuivARB(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"weights_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glWeightuivARB = this._pat._addressof_glWeightuivARB;
        if (addressof_glWeightuivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightuivARB"));
        }
        this.dispatch_glWeightuivARB1(n, array, 4 * n2, false, addressof_glWeightuivARB);
    }
    
    @Override
    public void glWeightPointerARB(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glWeightPointerARB = this._pat._addressof_glWeightPointerARB;
        if (addressof_glWeightPointerARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightPointerARB"));
        }
        this.dispatch_glWeightPointerARB0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glWeightPointerARB);
    }
    
    private native void dispatch_glWeightPointerARB0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glWeightPointerARB(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glWeightPointerARB = this._pat._addressof_glWeightPointerARB;
        if (addressof_glWeightPointerARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWeightPointerARB"));
        }
        this.dispatch_glWeightPointerARB0(n, n2, n3, n4, addressof_glWeightPointerARB);
    }
    
    private native void dispatch_glWeightPointerARB0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glVertexBlendARB(final int n) {
        final long addressof_glVertexBlendARB = this._pat._addressof_glVertexBlendARB;
        if (addressof_glVertexBlendARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexBlendARB"));
        }
        this.dispatch_glVertexBlendARB1(n, addressof_glVertexBlendARB);
    }
    
    private native void dispatch_glVertexBlendARB1(final int p0, final long p1);
    
    @Override
    public void glVertexAttrib1dARB(final int n, final double n2) {
        final long addressof_glVertexAttrib1dARB = this._pat._addressof_glVertexAttrib1dARB;
        if (addressof_glVertexAttrib1dARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dARB"));
        }
        this.dispatch_glVertexAttrib1dARB1(n, n2, addressof_glVertexAttrib1dARB);
    }
    
    private native void dispatch_glVertexAttrib1dARB1(final int p0, final double p1, final long p2);
    
    @Override
    public void glVertexAttrib1dvARB(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib1dvARB = this._pat._addressof_glVertexAttrib1dvARB;
        if (addressof_glVertexAttrib1dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dvARB"));
        }
        this.dispatch_glVertexAttrib1dvARB1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib1dvARB);
    }
    
    private native void dispatch_glVertexAttrib1dvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib1dvARB(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib1dvARB = this._pat._addressof_glVertexAttrib1dvARB;
        if (addressof_glVertexAttrib1dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dvARB"));
        }
        this.dispatch_glVertexAttrib1dvARB1(n, array, 8 * n2, false, addressof_glVertexAttrib1dvARB);
    }
    
    @Override
    public void glVertexAttrib1fARB(final int n, final float n2) {
        final long addressof_glVertexAttrib1fARB = this._pat._addressof_glVertexAttrib1fARB;
        if (addressof_glVertexAttrib1fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fARB"));
        }
        this.dispatch_glVertexAttrib1fARB1(n, n2, addressof_glVertexAttrib1fARB);
    }
    
    private native void dispatch_glVertexAttrib1fARB1(final int p0, final float p1, final long p2);
    
    @Override
    public void glVertexAttrib1fvARB(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib1fvARB = this._pat._addressof_glVertexAttrib1fvARB;
        if (addressof_glVertexAttrib1fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fvARB"));
        }
        this.dispatch_glVertexAttrib1fvARB1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib1fvARB);
    }
    
    private native void dispatch_glVertexAttrib1fvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib1fvARB(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib1fvARB = this._pat._addressof_glVertexAttrib1fvARB;
        if (addressof_glVertexAttrib1fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fvARB"));
        }
        this.dispatch_glVertexAttrib1fvARB1(n, array, 4 * n2, false, addressof_glVertexAttrib1fvARB);
    }
    
    @Override
    public void glVertexAttrib1sARB(final int n, final short n2) {
        final long addressof_glVertexAttrib1sARB = this._pat._addressof_glVertexAttrib1sARB;
        if (addressof_glVertexAttrib1sARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1sARB"));
        }
        this.dispatch_glVertexAttrib1sARB1(n, n2, addressof_glVertexAttrib1sARB);
    }
    
    private native void dispatch_glVertexAttrib1sARB1(final int p0, final short p1, final long p2);
    
    @Override
    public void glVertexAttrib1svARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib1svARB = this._pat._addressof_glVertexAttrib1svARB;
        if (addressof_glVertexAttrib1svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1svARB"));
        }
        this.dispatch_glVertexAttrib1svARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib1svARB);
    }
    
    private native void dispatch_glVertexAttrib1svARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib1svARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib1svARB = this._pat._addressof_glVertexAttrib1svARB;
        if (addressof_glVertexAttrib1svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1svARB"));
        }
        this.dispatch_glVertexAttrib1svARB1(n, array, 2 * n2, false, addressof_glVertexAttrib1svARB);
    }
    
    @Override
    public void glVertexAttrib2dARB(final int n, final double n2, final double n3) {
        final long addressof_glVertexAttrib2dARB = this._pat._addressof_glVertexAttrib2dARB;
        if (addressof_glVertexAttrib2dARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dARB"));
        }
        this.dispatch_glVertexAttrib2dARB1(n, n2, n3, addressof_glVertexAttrib2dARB);
    }
    
    private native void dispatch_glVertexAttrib2dARB1(final int p0, final double p1, final double p2, final long p3);
    
    @Override
    public void glVertexAttrib2dvARB(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib2dvARB = this._pat._addressof_glVertexAttrib2dvARB;
        if (addressof_glVertexAttrib2dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dvARB"));
        }
        this.dispatch_glVertexAttrib2dvARB1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib2dvARB);
    }
    
    private native void dispatch_glVertexAttrib2dvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib2dvARB(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib2dvARB = this._pat._addressof_glVertexAttrib2dvARB;
        if (addressof_glVertexAttrib2dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dvARB"));
        }
        this.dispatch_glVertexAttrib2dvARB1(n, array, 8 * n2, false, addressof_glVertexAttrib2dvARB);
    }
    
    @Override
    public void glVertexAttrib2fARB(final int n, final float n2, final float n3) {
        final long addressof_glVertexAttrib2fARB = this._pat._addressof_glVertexAttrib2fARB;
        if (addressof_glVertexAttrib2fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fARB"));
        }
        this.dispatch_glVertexAttrib2fARB1(n, n2, n3, addressof_glVertexAttrib2fARB);
    }
    
    private native void dispatch_glVertexAttrib2fARB1(final int p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glVertexAttrib2fvARB(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib2fvARB = this._pat._addressof_glVertexAttrib2fvARB;
        if (addressof_glVertexAttrib2fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fvARB"));
        }
        this.dispatch_glVertexAttrib2fvARB1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib2fvARB);
    }
    
    private native void dispatch_glVertexAttrib2fvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib2fvARB(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib2fvARB = this._pat._addressof_glVertexAttrib2fvARB;
        if (addressof_glVertexAttrib2fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fvARB"));
        }
        this.dispatch_glVertexAttrib2fvARB1(n, array, 4 * n2, false, addressof_glVertexAttrib2fvARB);
    }
    
    @Override
    public void glVertexAttrib2sARB(final int n, final short n2, final short n3) {
        final long addressof_glVertexAttrib2sARB = this._pat._addressof_glVertexAttrib2sARB;
        if (addressof_glVertexAttrib2sARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2sARB"));
        }
        this.dispatch_glVertexAttrib2sARB1(n, n2, n3, addressof_glVertexAttrib2sARB);
    }
    
    private native void dispatch_glVertexAttrib2sARB1(final int p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glVertexAttrib2svARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib2svARB = this._pat._addressof_glVertexAttrib2svARB;
        if (addressof_glVertexAttrib2svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2svARB"));
        }
        this.dispatch_glVertexAttrib2svARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib2svARB);
    }
    
    private native void dispatch_glVertexAttrib2svARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib2svARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib2svARB = this._pat._addressof_glVertexAttrib2svARB;
        if (addressof_glVertexAttrib2svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2svARB"));
        }
        this.dispatch_glVertexAttrib2svARB1(n, array, 2 * n2, false, addressof_glVertexAttrib2svARB);
    }
    
    @Override
    public void glVertexAttrib3dARB(final int n, final double n2, final double n3, final double n4) {
        final long addressof_glVertexAttrib3dARB = this._pat._addressof_glVertexAttrib3dARB;
        if (addressof_glVertexAttrib3dARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dARB"));
        }
        this.dispatch_glVertexAttrib3dARB1(n, n2, n3, n4, addressof_glVertexAttrib3dARB);
    }
    
    private native void dispatch_glVertexAttrib3dARB1(final int p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glVertexAttrib3dvARB(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib3dvARB = this._pat._addressof_glVertexAttrib3dvARB;
        if (addressof_glVertexAttrib3dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dvARB"));
        }
        this.dispatch_glVertexAttrib3dvARB1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib3dvARB);
    }
    
    private native void dispatch_glVertexAttrib3dvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib3dvARB(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib3dvARB = this._pat._addressof_glVertexAttrib3dvARB;
        if (addressof_glVertexAttrib3dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dvARB"));
        }
        this.dispatch_glVertexAttrib3dvARB1(n, array, 8 * n2, false, addressof_glVertexAttrib3dvARB);
    }
    
    @Override
    public void glVertexAttrib3fARB(final int n, final float n2, final float n3, final float n4) {
        final long addressof_glVertexAttrib3fARB = this._pat._addressof_glVertexAttrib3fARB;
        if (addressof_glVertexAttrib3fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fARB"));
        }
        this.dispatch_glVertexAttrib3fARB1(n, n2, n3, n4, addressof_glVertexAttrib3fARB);
    }
    
    private native void dispatch_glVertexAttrib3fARB1(final int p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glVertexAttrib3fvARB(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib3fvARB = this._pat._addressof_glVertexAttrib3fvARB;
        if (addressof_glVertexAttrib3fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fvARB"));
        }
        this.dispatch_glVertexAttrib3fvARB1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib3fvARB);
    }
    
    private native void dispatch_glVertexAttrib3fvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib3fvARB(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib3fvARB = this._pat._addressof_glVertexAttrib3fvARB;
        if (addressof_glVertexAttrib3fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fvARB"));
        }
        this.dispatch_glVertexAttrib3fvARB1(n, array, 4 * n2, false, addressof_glVertexAttrib3fvARB);
    }
    
    @Override
    public void glVertexAttrib3sARB(final int n, final short n2, final short n3, final short n4) {
        final long addressof_glVertexAttrib3sARB = this._pat._addressof_glVertexAttrib3sARB;
        if (addressof_glVertexAttrib3sARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3sARB"));
        }
        this.dispatch_glVertexAttrib3sARB1(n, n2, n3, n4, addressof_glVertexAttrib3sARB);
    }
    
    private native void dispatch_glVertexAttrib3sARB1(final int p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glVertexAttrib3svARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib3svARB = this._pat._addressof_glVertexAttrib3svARB;
        if (addressof_glVertexAttrib3svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3svARB"));
        }
        this.dispatch_glVertexAttrib3svARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib3svARB);
    }
    
    private native void dispatch_glVertexAttrib3svARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib3svARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib3svARB = this._pat._addressof_glVertexAttrib3svARB;
        if (addressof_glVertexAttrib3svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3svARB"));
        }
        this.dispatch_glVertexAttrib3svARB1(n, array, 2 * n2, false, addressof_glVertexAttrib3svARB);
    }
    
    @Override
    public void glVertexAttrib4NbvARB(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4NbvARB = this._pat._addressof_glVertexAttrib4NbvARB;
        if (addressof_glVertexAttrib4NbvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NbvARB"));
        }
        this.dispatch_glVertexAttrib4NbvARB1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4NbvARB);
    }
    
    private native void dispatch_glVertexAttrib4NbvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4NbvARB(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4NbvARB = this._pat._addressof_glVertexAttrib4NbvARB;
        if (addressof_glVertexAttrib4NbvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NbvARB"));
        }
        this.dispatch_glVertexAttrib4NbvARB1(n, array, n2, false, addressof_glVertexAttrib4NbvARB);
    }
    
    @Override
    public void glVertexAttrib4NivARB(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4NivARB = this._pat._addressof_glVertexAttrib4NivARB;
        if (addressof_glVertexAttrib4NivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NivARB"));
        }
        this.dispatch_glVertexAttrib4NivARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4NivARB);
    }
    
    private native void dispatch_glVertexAttrib4NivARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4NivARB(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4NivARB = this._pat._addressof_glVertexAttrib4NivARB;
        if (addressof_glVertexAttrib4NivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NivARB"));
        }
        this.dispatch_glVertexAttrib4NivARB1(n, array, 4 * n2, false, addressof_glVertexAttrib4NivARB);
    }
    
    @Override
    public void glVertexAttrib4NsvARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4NsvARB = this._pat._addressof_glVertexAttrib4NsvARB;
        if (addressof_glVertexAttrib4NsvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NsvARB"));
        }
        this.dispatch_glVertexAttrib4NsvARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4NsvARB);
    }
    
    private native void dispatch_glVertexAttrib4NsvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4NsvARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4NsvARB = this._pat._addressof_glVertexAttrib4NsvARB;
        if (addressof_glVertexAttrib4NsvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NsvARB"));
        }
        this.dispatch_glVertexAttrib4NsvARB1(n, array, 2 * n2, false, addressof_glVertexAttrib4NsvARB);
    }
    
    @Override
    public void glVertexAttrib4NubARB(final int n, final byte b, final byte b2, final byte b3, final byte b4) {
        final long addressof_glVertexAttrib4NubARB = this._pat._addressof_glVertexAttrib4NubARB;
        if (addressof_glVertexAttrib4NubARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NubARB"));
        }
        this.dispatch_glVertexAttrib4NubARB1(n, b, b2, b3, b4, addressof_glVertexAttrib4NubARB);
    }
    
    private native void dispatch_glVertexAttrib4NubARB1(final int p0, final byte p1, final byte p2, final byte p3, final byte p4, final long p5);
    
    @Override
    public void glVertexAttrib4NubvARB(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4NubvARB = this._pat._addressof_glVertexAttrib4NubvARB;
        if (addressof_glVertexAttrib4NubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NubvARB"));
        }
        this.dispatch_glVertexAttrib4NubvARB1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4NubvARB);
    }
    
    private native void dispatch_glVertexAttrib4NubvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4NubvARB(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4NubvARB = this._pat._addressof_glVertexAttrib4NubvARB;
        if (addressof_glVertexAttrib4NubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NubvARB"));
        }
        this.dispatch_glVertexAttrib4NubvARB1(n, array, n2, false, addressof_glVertexAttrib4NubvARB);
    }
    
    @Override
    public void glVertexAttrib4NuivARB(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4NuivARB = this._pat._addressof_glVertexAttrib4NuivARB;
        if (addressof_glVertexAttrib4NuivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NuivARB"));
        }
        this.dispatch_glVertexAttrib4NuivARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4NuivARB);
    }
    
    private native void dispatch_glVertexAttrib4NuivARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4NuivARB(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4NuivARB = this._pat._addressof_glVertexAttrib4NuivARB;
        if (addressof_glVertexAttrib4NuivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NuivARB"));
        }
        this.dispatch_glVertexAttrib4NuivARB1(n, array, 4 * n2, false, addressof_glVertexAttrib4NuivARB);
    }
    
    @Override
    public void glVertexAttrib4NusvARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4NusvARB = this._pat._addressof_glVertexAttrib4NusvARB;
        if (addressof_glVertexAttrib4NusvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NusvARB"));
        }
        this.dispatch_glVertexAttrib4NusvARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4NusvARB);
    }
    
    private native void dispatch_glVertexAttrib4NusvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4NusvARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4NusvARB = this._pat._addressof_glVertexAttrib4NusvARB;
        if (addressof_glVertexAttrib4NusvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NusvARB"));
        }
        this.dispatch_glVertexAttrib4NusvARB1(n, array, 2 * n2, false, addressof_glVertexAttrib4NusvARB);
    }
    
    @Override
    public void glVertexAttrib4bvARB(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4bvARB = this._pat._addressof_glVertexAttrib4bvARB;
        if (addressof_glVertexAttrib4bvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bvARB"));
        }
        this.dispatch_glVertexAttrib4bvARB1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4bvARB);
    }
    
    private native void dispatch_glVertexAttrib4bvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4bvARB(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4bvARB = this._pat._addressof_glVertexAttrib4bvARB;
        if (addressof_glVertexAttrib4bvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bvARB"));
        }
        this.dispatch_glVertexAttrib4bvARB1(n, array, n2, false, addressof_glVertexAttrib4bvARB);
    }
    
    @Override
    public void glVertexAttrib4dARB(final int n, final double n2, final double n3, final double n4, final double n5) {
        final long addressof_glVertexAttrib4dARB = this._pat._addressof_glVertexAttrib4dARB;
        if (addressof_glVertexAttrib4dARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dARB"));
        }
        this.dispatch_glVertexAttrib4dARB1(n, n2, n3, n4, n5, addressof_glVertexAttrib4dARB);
    }
    
    private native void dispatch_glVertexAttrib4dARB1(final int p0, final double p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glVertexAttrib4dvARB(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVertexAttrib4dvARB = this._pat._addressof_glVertexAttrib4dvARB;
        if (addressof_glVertexAttrib4dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dvARB"));
        }
        this.dispatch_glVertexAttrib4dvARB1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVertexAttrib4dvARB);
    }
    
    private native void dispatch_glVertexAttrib4dvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4dvARB(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4dvARB = this._pat._addressof_glVertexAttrib4dvARB;
        if (addressof_glVertexAttrib4dvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dvARB"));
        }
        this.dispatch_glVertexAttrib4dvARB1(n, array, 8 * n2, false, addressof_glVertexAttrib4dvARB);
    }
    
    @Override
    public void glVertexAttrib4fARB(final int n, final float n2, final float n3, final float n4, final float n5) {
        final long addressof_glVertexAttrib4fARB = this._pat._addressof_glVertexAttrib4fARB;
        if (addressof_glVertexAttrib4fARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fARB"));
        }
        this.dispatch_glVertexAttrib4fARB1(n, n2, n3, n4, n5, addressof_glVertexAttrib4fARB);
    }
    
    private native void dispatch_glVertexAttrib4fARB1(final int p0, final float p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glVertexAttrib4fvARB(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexAttrib4fvARB = this._pat._addressof_glVertexAttrib4fvARB;
        if (addressof_glVertexAttrib4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fvARB"));
        }
        this.dispatch_glVertexAttrib4fvARB1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexAttrib4fvARB);
    }
    
    private native void dispatch_glVertexAttrib4fvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4fvARB(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4fvARB = this._pat._addressof_glVertexAttrib4fvARB;
        if (addressof_glVertexAttrib4fvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fvARB"));
        }
        this.dispatch_glVertexAttrib4fvARB1(n, array, 4 * n2, false, addressof_glVertexAttrib4fvARB);
    }
    
    @Override
    public void glVertexAttrib4ivARB(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4ivARB = this._pat._addressof_glVertexAttrib4ivARB;
        if (addressof_glVertexAttrib4ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ivARB"));
        }
        this.dispatch_glVertexAttrib4ivARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4ivARB);
    }
    
    private native void dispatch_glVertexAttrib4ivARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4ivARB(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4ivARB = this._pat._addressof_glVertexAttrib4ivARB;
        if (addressof_glVertexAttrib4ivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ivARB"));
        }
        this.dispatch_glVertexAttrib4ivARB1(n, array, 4 * n2, false, addressof_glVertexAttrib4ivARB);
    }
    
    @Override
    public void glVertexAttrib4sARB(final int n, final short n2, final short n3, final short n4, final short n5) {
        final long addressof_glVertexAttrib4sARB = this._pat._addressof_glVertexAttrib4sARB;
        if (addressof_glVertexAttrib4sARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4sARB"));
        }
        this.dispatch_glVertexAttrib4sARB1(n, n2, n3, n4, n5, addressof_glVertexAttrib4sARB);
    }
    
    private native void dispatch_glVertexAttrib4sARB1(final int p0, final short p1, final short p2, final short p3, final short p4, final long p5);
    
    @Override
    public void glVertexAttrib4svARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4svARB = this._pat._addressof_glVertexAttrib4svARB;
        if (addressof_glVertexAttrib4svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4svARB"));
        }
        this.dispatch_glVertexAttrib4svARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4svARB);
    }
    
    private native void dispatch_glVertexAttrib4svARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4svARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4svARB = this._pat._addressof_glVertexAttrib4svARB;
        if (addressof_glVertexAttrib4svARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4svARB"));
        }
        this.dispatch_glVertexAttrib4svARB1(n, array, 2 * n2, false, addressof_glVertexAttrib4svARB);
    }
    
    @Override
    public void glVertexAttrib4ubvARB(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttrib4ubvARB = this._pat._addressof_glVertexAttrib4ubvARB;
        if (addressof_glVertexAttrib4ubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubvARB"));
        }
        this.dispatch_glVertexAttrib4ubvARB1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttrib4ubvARB);
    }
    
    private native void dispatch_glVertexAttrib4ubvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4ubvARB(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4ubvARB = this._pat._addressof_glVertexAttrib4ubvARB;
        if (addressof_glVertexAttrib4ubvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubvARB"));
        }
        this.dispatch_glVertexAttrib4ubvARB1(n, array, n2, false, addressof_glVertexAttrib4ubvARB);
    }
    
    @Override
    public void glVertexAttrib4uivARB(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttrib4uivARB = this._pat._addressof_glVertexAttrib4uivARB;
        if (addressof_glVertexAttrib4uivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uivARB"));
        }
        this.dispatch_glVertexAttrib4uivARB1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttrib4uivARB);
    }
    
    private native void dispatch_glVertexAttrib4uivARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4uivARB(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4uivARB = this._pat._addressof_glVertexAttrib4uivARB;
        if (addressof_glVertexAttrib4uivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uivARB"));
        }
        this.dispatch_glVertexAttrib4uivARB1(n, array, 4 * n2, false, addressof_glVertexAttrib4uivARB);
    }
    
    @Override
    public void glVertexAttrib4usvARB(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4usvARB = this._pat._addressof_glVertexAttrib4usvARB;
        if (addressof_glVertexAttrib4usvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usvARB"));
        }
        this.dispatch_glVertexAttrib4usvARB1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4usvARB);
    }
    
    private native void dispatch_glVertexAttrib4usvARB1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4usvARB(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4usvARB = this._pat._addressof_glVertexAttrib4usvARB;
        if (addressof_glVertexAttrib4usvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usvARB"));
        }
        this.dispatch_glVertexAttrib4usvARB1(n, array, 2 * n2, false, addressof_glVertexAttrib4usvARB);
    }
    
    @Override
    public void glVertexAttribPointerARB(final int n, final int n2, final int n3, final boolean b, final int n4, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glVertexAttribPointerARB = this._pat._addressof_glVertexAttribPointerARB;
        if (addressof_glVertexAttribPointerARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointerARB"));
        }
        this.dispatch_glVertexAttribPointerARB1(n, n2, n3, b, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glVertexAttribPointerARB);
    }
    
    private native void dispatch_glVertexAttribPointerARB1(final int p0, final int p1, final int p2, final boolean p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glVertexAttribPointerARB(final int n, final int n2, final int n3, final boolean b, final int n4, final long n5) {
        this.checkArrayVBOBound(true);
        final long addressof_glVertexAttribPointerARB = this._pat._addressof_glVertexAttribPointerARB;
        if (addressof_glVertexAttribPointerARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointerARB"));
        }
        this.dispatch_glVertexAttribPointerARB1(n, n2, n3, b, n4, n5, addressof_glVertexAttribPointerARB);
    }
    
    private native void dispatch_glVertexAttribPointerARB1(final int p0, final int p1, final int p2, final boolean p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glEnableVertexAttribArrayARB(final int n) {
        final long addressof_glEnableVertexAttribArrayARB = this._pat._addressof_glEnableVertexAttribArrayARB;
        if (addressof_glEnableVertexAttribArrayARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribArrayARB"));
        }
        this.dispatch_glEnableVertexAttribArrayARB1(n, addressof_glEnableVertexAttribArrayARB);
    }
    
    private native void dispatch_glEnableVertexAttribArrayARB1(final int p0, final long p1);
    
    @Override
    public void glDisableVertexAttribArrayARB(final int n) {
        final long addressof_glDisableVertexAttribArrayARB = this._pat._addressof_glDisableVertexAttribArrayARB;
        if (addressof_glDisableVertexAttribArrayARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribArrayARB"));
        }
        this.dispatch_glDisableVertexAttribArrayARB1(n, addressof_glDisableVertexAttribArrayARB);
    }
    
    private native void dispatch_glDisableVertexAttribArrayARB1(final int p0, final long p1);
    
    @Override
    public void glGetVertexAttribdvARB(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetVertexAttribdvARB = this._pat._addressof_glGetVertexAttribdvARB;
        if (addressof_glGetVertexAttribdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdvARB"));
        }
        this.dispatch_glGetVertexAttribdvARB1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetVertexAttribdvARB);
    }
    
    private native void dispatch_glGetVertexAttribdvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribdvARB(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribdvARB = this._pat._addressof_glGetVertexAttribdvARB;
        if (addressof_glGetVertexAttribdvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdvARB"));
        }
        this.dispatch_glGetVertexAttribdvARB1(n, n2, array, 8 * n3, false, addressof_glGetVertexAttribdvARB);
    }
    
    @Override
    public void glGetVertexAttribfvARB(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetVertexAttribfvARB = this._pat._addressof_glGetVertexAttribfvARB;
        if (addressof_glGetVertexAttribfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfvARB"));
        }
        this.dispatch_glGetVertexAttribfvARB1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetVertexAttribfvARB);
    }
    
    private native void dispatch_glGetVertexAttribfvARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribfvARB(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribfvARB = this._pat._addressof_glGetVertexAttribfvARB;
        if (addressof_glGetVertexAttribfvARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfvARB"));
        }
        this.dispatch_glGetVertexAttribfvARB1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribfvARB);
    }
    
    @Override
    public void glGetVertexAttribivARB(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexAttribivARB = this._pat._addressof_glGetVertexAttribivARB;
        if (addressof_glGetVertexAttribivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribivARB"));
        }
        this.dispatch_glGetVertexAttribivARB1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexAttribivARB);
    }
    
    private native void dispatch_glGetVertexAttribivARB1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribivARB(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribivARB = this._pat._addressof_glGetVertexAttribivARB;
        if (addressof_glGetVertexAttribivARB == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribivARB"));
        }
        this.dispatch_glGetVertexAttribivARB1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribivARB);
    }
    
    @Override
    public void glBlendBarrier() {
        final long addressof_glBlendBarrier = this._pat._addressof_glBlendBarrier;
        if (addressof_glBlendBarrier == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendBarrier"));
        }
        this.dispatch_glBlendBarrier1(addressof_glBlendBarrier);
    }
    
    private native void dispatch_glBlendBarrier1(final long p0);
    
    @Override
    public void glMultiTexCoord1bOES(final int n, final byte b) {
        final long addressof_glMultiTexCoord1bOES = this._pat._addressof_glMultiTexCoord1bOES;
        if (addressof_glMultiTexCoord1bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1bOES"));
        }
        this.dispatch_glMultiTexCoord1bOES1(n, b, addressof_glMultiTexCoord1bOES);
    }
    
    private native void dispatch_glMultiTexCoord1bOES1(final int p0, final byte p1, final long p2);
    
    @Override
    public void glMultiTexCoord1bvOES(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glMultiTexCoord1bvOES = this._pat._addressof_glMultiTexCoord1bvOES;
        if (addressof_glMultiTexCoord1bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1bvOES"));
        }
        this.dispatch_glMultiTexCoord1bvOES1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glMultiTexCoord1bvOES);
    }
    
    private native void dispatch_glMultiTexCoord1bvOES1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord1bvOES(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord1bvOES = this._pat._addressof_glMultiTexCoord1bvOES;
        if (addressof_glMultiTexCoord1bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1bvOES"));
        }
        this.dispatch_glMultiTexCoord1bvOES1(n, array, n2, false, addressof_glMultiTexCoord1bvOES);
    }
    
    @Override
    public void glMultiTexCoord2bOES(final int n, final byte b, final byte b2) {
        final long addressof_glMultiTexCoord2bOES = this._pat._addressof_glMultiTexCoord2bOES;
        if (addressof_glMultiTexCoord2bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2bOES"));
        }
        this.dispatch_glMultiTexCoord2bOES1(n, b, b2, addressof_glMultiTexCoord2bOES);
    }
    
    private native void dispatch_glMultiTexCoord2bOES1(final int p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glMultiTexCoord2bvOES(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glMultiTexCoord2bvOES = this._pat._addressof_glMultiTexCoord2bvOES;
        if (addressof_glMultiTexCoord2bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2bvOES"));
        }
        this.dispatch_glMultiTexCoord2bvOES1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glMultiTexCoord2bvOES);
    }
    
    private native void dispatch_glMultiTexCoord2bvOES1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord2bvOES(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord2bvOES = this._pat._addressof_glMultiTexCoord2bvOES;
        if (addressof_glMultiTexCoord2bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2bvOES"));
        }
        this.dispatch_glMultiTexCoord2bvOES1(n, array, n2, false, addressof_glMultiTexCoord2bvOES);
    }
    
    @Override
    public void glMultiTexCoord3bOES(final int n, final byte b, final byte b2, final byte b3) {
        final long addressof_glMultiTexCoord3bOES = this._pat._addressof_glMultiTexCoord3bOES;
        if (addressof_glMultiTexCoord3bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3bOES"));
        }
        this.dispatch_glMultiTexCoord3bOES1(n, b, b2, b3, addressof_glMultiTexCoord3bOES);
    }
    
    private native void dispatch_glMultiTexCoord3bOES1(final int p0, final byte p1, final byte p2, final byte p3, final long p4);
    
    @Override
    public void glMultiTexCoord3bvOES(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glMultiTexCoord3bvOES = this._pat._addressof_glMultiTexCoord3bvOES;
        if (addressof_glMultiTexCoord3bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3bvOES"));
        }
        this.dispatch_glMultiTexCoord3bvOES1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glMultiTexCoord3bvOES);
    }
    
    private native void dispatch_glMultiTexCoord3bvOES1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord3bvOES(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord3bvOES = this._pat._addressof_glMultiTexCoord3bvOES;
        if (addressof_glMultiTexCoord3bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3bvOES"));
        }
        this.dispatch_glMultiTexCoord3bvOES1(n, array, n2, false, addressof_glMultiTexCoord3bvOES);
    }
    
    @Override
    public void glMultiTexCoord4bOES(final int n, final byte b, final byte b2, final byte b3, final byte b4) {
        final long addressof_glMultiTexCoord4bOES = this._pat._addressof_glMultiTexCoord4bOES;
        if (addressof_glMultiTexCoord4bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4bOES"));
        }
        this.dispatch_glMultiTexCoord4bOES1(n, b, b2, b3, b4, addressof_glMultiTexCoord4bOES);
    }
    
    private native void dispatch_glMultiTexCoord4bOES1(final int p0, final byte p1, final byte p2, final byte p3, final byte p4, final long p5);
    
    @Override
    public void glMultiTexCoord4bvOES(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glMultiTexCoord4bvOES = this._pat._addressof_glMultiTexCoord4bvOES;
        if (addressof_glMultiTexCoord4bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4bvOES"));
        }
        this.dispatch_glMultiTexCoord4bvOES1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glMultiTexCoord4bvOES);
    }
    
    private native void dispatch_glMultiTexCoord4bvOES1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord4bvOES(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"coords_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord4bvOES = this._pat._addressof_glMultiTexCoord4bvOES;
        if (addressof_glMultiTexCoord4bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4bvOES"));
        }
        this.dispatch_glMultiTexCoord4bvOES1(n, array, n2, false, addressof_glMultiTexCoord4bvOES);
    }
    
    @Override
    public void glTexCoord1bOES(final byte b) {
        final long addressof_glTexCoord1bOES = this._pat._addressof_glTexCoord1bOES;
        if (addressof_glTexCoord1bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1bOES"));
        }
        this.dispatch_glTexCoord1bOES1(b, addressof_glTexCoord1bOES);
    }
    
    private native void dispatch_glTexCoord1bOES1(final byte p0, final long p1);
    
    @Override
    public void glTexCoord1bvOES(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glTexCoord1bvOES = this._pat._addressof_glTexCoord1bvOES;
        if (addressof_glTexCoord1bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1bvOES"));
        }
        this.dispatch_glTexCoord1bvOES1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glTexCoord1bvOES);
    }
    
    private native void dispatch_glTexCoord1bvOES1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord1bvOES(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coords_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord1bvOES = this._pat._addressof_glTexCoord1bvOES;
        if (addressof_glTexCoord1bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1bvOES"));
        }
        this.dispatch_glTexCoord1bvOES1(array, n, false, addressof_glTexCoord1bvOES);
    }
    
    @Override
    public void glTexCoord2bOES(final byte b, final byte b2) {
        final long addressof_glTexCoord2bOES = this._pat._addressof_glTexCoord2bOES;
        if (addressof_glTexCoord2bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2bOES"));
        }
        this.dispatch_glTexCoord2bOES1(b, b2, addressof_glTexCoord2bOES);
    }
    
    private native void dispatch_glTexCoord2bOES1(final byte p0, final byte p1, final long p2);
    
    @Override
    public void glTexCoord2bvOES(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glTexCoord2bvOES = this._pat._addressof_glTexCoord2bvOES;
        if (addressof_glTexCoord2bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2bvOES"));
        }
        this.dispatch_glTexCoord2bvOES1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glTexCoord2bvOES);
    }
    
    private native void dispatch_glTexCoord2bvOES1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord2bvOES(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coords_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord2bvOES = this._pat._addressof_glTexCoord2bvOES;
        if (addressof_glTexCoord2bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2bvOES"));
        }
        this.dispatch_glTexCoord2bvOES1(array, n, false, addressof_glTexCoord2bvOES);
    }
    
    @Override
    public void glTexCoord3bOES(final byte b, final byte b2, final byte b3) {
        final long addressof_glTexCoord3bOES = this._pat._addressof_glTexCoord3bOES;
        if (addressof_glTexCoord3bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3bOES"));
        }
        this.dispatch_glTexCoord3bOES1(b, b2, b3, addressof_glTexCoord3bOES);
    }
    
    private native void dispatch_glTexCoord3bOES1(final byte p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glTexCoord3bvOES(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glTexCoord3bvOES = this._pat._addressof_glTexCoord3bvOES;
        if (addressof_glTexCoord3bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3bvOES"));
        }
        this.dispatch_glTexCoord3bvOES1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glTexCoord3bvOES);
    }
    
    private native void dispatch_glTexCoord3bvOES1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord3bvOES(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coords_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord3bvOES = this._pat._addressof_glTexCoord3bvOES;
        if (addressof_glTexCoord3bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3bvOES"));
        }
        this.dispatch_glTexCoord3bvOES1(array, n, false, addressof_glTexCoord3bvOES);
    }
    
    @Override
    public void glTexCoord4bOES(final byte b, final byte b2, final byte b3, final byte b4) {
        final long addressof_glTexCoord4bOES = this._pat._addressof_glTexCoord4bOES;
        if (addressof_glTexCoord4bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4bOES"));
        }
        this.dispatch_glTexCoord4bOES1(b, b2, b3, b4, addressof_glTexCoord4bOES);
    }
    
    private native void dispatch_glTexCoord4bOES1(final byte p0, final byte p1, final byte p2, final byte p3, final long p4);
    
    @Override
    public void glTexCoord4bvOES(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glTexCoord4bvOES = this._pat._addressof_glTexCoord4bvOES;
        if (addressof_glTexCoord4bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4bvOES"));
        }
        this.dispatch_glTexCoord4bvOES1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glTexCoord4bvOES);
    }
    
    private native void dispatch_glTexCoord4bvOES1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord4bvOES(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coords_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord4bvOES = this._pat._addressof_glTexCoord4bvOES;
        if (addressof_glTexCoord4bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4bvOES"));
        }
        this.dispatch_glTexCoord4bvOES1(array, n, false, addressof_glTexCoord4bvOES);
    }
    
    @Override
    public void glVertex2bOES(final byte b, final byte b2) {
        final long addressof_glVertex2bOES = this._pat._addressof_glVertex2bOES;
        if (addressof_glVertex2bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2bOES"));
        }
        this.dispatch_glVertex2bOES1(b, b2, addressof_glVertex2bOES);
    }
    
    private native void dispatch_glVertex2bOES1(final byte p0, final byte p1, final long p2);
    
    @Override
    public void glVertex2bvOES(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertex2bvOES = this._pat._addressof_glVertex2bvOES;
        if (addressof_glVertex2bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2bvOES"));
        }
        this.dispatch_glVertex2bvOES1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertex2bvOES);
    }
    
    private native void dispatch_glVertex2bvOES1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex2bvOES(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coords_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex2bvOES = this._pat._addressof_glVertex2bvOES;
        if (addressof_glVertex2bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2bvOES"));
        }
        this.dispatch_glVertex2bvOES1(array, n, false, addressof_glVertex2bvOES);
    }
    
    @Override
    public void glVertex3bOES(final byte b, final byte b2, final byte b3) {
        final long addressof_glVertex3bOES = this._pat._addressof_glVertex3bOES;
        if (addressof_glVertex3bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3bOES"));
        }
        this.dispatch_glVertex3bOES1(b, b2, b3, addressof_glVertex3bOES);
    }
    
    private native void dispatch_glVertex3bOES1(final byte p0, final byte p1, final byte p2, final long p3);
    
    @Override
    public void glVertex3bvOES(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertex3bvOES = this._pat._addressof_glVertex3bvOES;
        if (addressof_glVertex3bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3bvOES"));
        }
        this.dispatch_glVertex3bvOES1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertex3bvOES);
    }
    
    private native void dispatch_glVertex3bvOES1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex3bvOES(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coords_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex3bvOES = this._pat._addressof_glVertex3bvOES;
        if (addressof_glVertex3bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3bvOES"));
        }
        this.dispatch_glVertex3bvOES1(array, n, false, addressof_glVertex3bvOES);
    }
    
    @Override
    public void glVertex4bOES(final byte b, final byte b2, final byte b3, final byte b4) {
        final long addressof_glVertex4bOES = this._pat._addressof_glVertex4bOES;
        if (addressof_glVertex4bOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4bOES"));
        }
        this.dispatch_glVertex4bOES1(b, b2, b3, b4, addressof_glVertex4bOES);
    }
    
    private native void dispatch_glVertex4bOES1(final byte p0, final byte p1, final byte p2, final byte p3, final long p4);
    
    @Override
    public void glVertex4bvOES(final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertex4bvOES = this._pat._addressof_glVertex4bvOES;
        if (addressof_glVertex4bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4bvOES"));
        }
        this.dispatch_glVertex4bvOES1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertex4bvOES);
    }
    
    private native void dispatch_glVertex4bvOES1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex4bvOES(final byte[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"coords_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex4bvOES = this._pat._addressof_glVertex4bvOES;
        if (addressof_glVertex4bvOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4bvOES"));
        }
        this.dispatch_glVertex4bvOES1(array, n, false, addressof_glVertex4bvOES);
    }
    
    @Override
    public int glQueryMatrixxOES(final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glQueryMatrixxOES = this._pat._addressof_glQueryMatrixxOES;
        if (addressof_glQueryMatrixxOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glQueryMatrixxOES"));
        }
        return this.dispatch_glQueryMatrixxOES1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glQueryMatrixxOES);
    }
    
    private native int dispatch_glQueryMatrixxOES1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public int glQueryMatrixxOES(final int[] array, final int n, final int[] array2, final int n2) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"mantissa_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n2) {
            throw new GLException("array offset argument \"exponent_offset\" (" + n2 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glQueryMatrixxOES = this._pat._addressof_glQueryMatrixxOES;
        if (addressof_glQueryMatrixxOES == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glQueryMatrixxOES"));
        }
        return this.dispatch_glQueryMatrixxOES1(array, 4 * n, false, array2, 4 * n2, false, addressof_glQueryMatrixxOES);
    }
    
    @Override
    public void glClipPlanef(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glClipPlanef = this._pat._addressof_glClipPlanef;
        if (addressof_glClipPlanef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClipPlanef"));
        }
        this.dispatch_glClipPlanef1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glClipPlanef);
    }
    
    private native void dispatch_glClipPlanef1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glClipPlanef(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"equation_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glClipPlanef = this._pat._addressof_glClipPlanef;
        if (addressof_glClipPlanef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClipPlanef"));
        }
        this.dispatch_glClipPlanef1(n, array, 4 * n2, false, addressof_glClipPlanef);
    }
    
    @Override
    public void glFrustumf(final float n, final float n2, final float n3, final float n4, final float n5, final float n6) {
        if (!this._context.hasFP32CompatAPI()) {
            this.glFrustum(n, n2, n3, n4, n5, n6);
            return;
        }
        final long addressof_glFrustumf = this._pat._addressof_glFrustumf;
        if (addressof_glFrustumf == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFrustumf"));
        }
        this.dispatch_glFrustumf1(n, n2, n3, n4, n5, n6, addressof_glFrustumf);
    }
    
    private native void dispatch_glFrustumf1(final float p0, final float p1, final float p2, final float p3, final float p4, final float p5, final long p6);
    
    @Override
    public void glGetClipPlanef(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetClipPlanef = this._pat._addressof_glGetClipPlanef;
        if (addressof_glGetClipPlanef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanef"));
        }
        this.dispatch_glGetClipPlanef1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetClipPlanef);
    }
    
    private native void dispatch_glGetClipPlanef1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetClipPlanef(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"equation_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetClipPlanef = this._pat._addressof_glGetClipPlanef;
        if (addressof_glGetClipPlanef == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanef"));
        }
        this.dispatch_glGetClipPlanef1(n, array, 4 * n2, false, addressof_glGetClipPlanef);
    }
    
    @Override
    public void glOrthof(final float n, final float n2, final float n3, final float n4, final float n5, final float n6) {
        if (!this._context.hasFP32CompatAPI()) {
            this.glOrtho(n, n2, n3, n4, n5, n6);
            return;
        }
        final long addressof_glOrthof = this._pat._addressof_glOrthof;
        if (addressof_glOrthof == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glOrthof"));
        }
        this.dispatch_glOrthof1(n, n2, n3, n4, n5, n6, addressof_glOrthof);
    }
    
    private native void dispatch_glOrthof1(final float p0, final float p1, final float p2, final float p3, final float p4, final float p5, final long p6);
    
    @Override
    public void glDebugMessageEnableAMD(final int n, final int n2, final int n3, final IntBuffer intBuffer, final boolean b) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDebugMessageEnableAMD = this._pat._addressof_glDebugMessageEnableAMD;
        if (addressof_glDebugMessageEnableAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageEnableAMD"));
        }
        this.dispatch_glDebugMessageEnableAMD1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, b, addressof_glDebugMessageEnableAMD);
    }
    
    private native void dispatch_glDebugMessageEnableAMD1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final boolean p6, final long p7);
    
    @Override
    public void glDebugMessageEnableAMD(final int n, final int n2, final int n3, final int[] array, final int n4, final boolean b) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"ids_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDebugMessageEnableAMD = this._pat._addressof_glDebugMessageEnableAMD;
        if (addressof_glDebugMessageEnableAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageEnableAMD"));
        }
        this.dispatch_glDebugMessageEnableAMD1(n, n2, n3, array, 4 * n4, false, b, addressof_glDebugMessageEnableAMD);
    }
    
    @Override
    public void glDebugMessageInsertAMD(final int n, final int n2, final int n3, final int n4, final String s) {
        final long addressof_glDebugMessageInsertAMD = this._pat._addressof_glDebugMessageInsertAMD;
        if (addressof_glDebugMessageInsertAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageInsertAMD"));
        }
        this.dispatch_glDebugMessageInsertAMD1(n, n2, n3, n4, s, addressof_glDebugMessageInsertAMD);
    }
    
    private native void dispatch_glDebugMessageInsertAMD1(final int p0, final int p1, final int p2, final int p3, final String p4, final long p5);
    
    @Override
    public int glGetDebugMessageLogAMD(final int n, final int n2, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final IntBuffer intBuffer4, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final boolean direct4 = Buffers.isDirect(intBuffer4);
        final boolean direct5 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetDebugMessageLogAMD = this._pat._addressof_glGetDebugMessageLogAMD;
        if (addressof_glGetDebugMessageLogAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLogAMD"));
        }
        return this.dispatch_glGetDebugMessageLogAMD1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, direct4 ? intBuffer4 : Buffers.getArray(intBuffer4), direct4 ? Buffers.getDirectBufferByteOffset(intBuffer4) : Buffers.getIndirectBufferByteOffset(intBuffer4), direct4, direct5 ? byteBuffer : Buffers.getArray(byteBuffer), direct5 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct5, addressof_glGetDebugMessageLogAMD);
    }
    
    private native int dispatch_glGetDebugMessageLogAMD1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final Object p8, final int p9, final boolean p10, final Object p11, final int p12, final boolean p13, final Object p14, final int p15, final boolean p16, final long p17);
    
    @Override
    public int glGetDebugMessageLogAMD(final int n, final int n2, final int[] array, final int n3, final int[] array2, final int n4, final int[] array3, final int n5, final int[] array4, final int n6, final byte[] array5, final int n7) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"categories_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"severities_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n5) {
            throw new GLException("array offset argument \"ids_offset\" (" + n5 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n6) {
            throw new GLException("array offset argument \"lengths_offset\" (" + n6 + ") equals or exceeds array length (" + array4.length + ")");
        }
        if (array5 != null && array5.length <= n7) {
            throw new GLException("array offset argument \"message_offset\" (" + n7 + ") equals or exceeds array length (" + array5.length + ")");
        }
        final long addressof_glGetDebugMessageLogAMD = this._pat._addressof_glGetDebugMessageLogAMD;
        if (addressof_glGetDebugMessageLogAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLogAMD"));
        }
        return this.dispatch_glGetDebugMessageLogAMD1(n, n2, array, 4 * n3, false, array2, 4 * n4, false, array3, 4 * n5, false, array4, 4 * n6, false, array5, n7, false, addressof_glGetDebugMessageLogAMD);
    }
    
    @Override
    public void glBlendFuncIndexedAMD(final int n, final int n2, final int n3) {
        final long addressof_glBlendFuncIndexedAMD = this._pat._addressof_glBlendFuncIndexedAMD;
        if (addressof_glBlendFuncIndexedAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncIndexedAMD"));
        }
        this.dispatch_glBlendFuncIndexedAMD1(n, n2, n3, addressof_glBlendFuncIndexedAMD);
    }
    
    private native void dispatch_glBlendFuncIndexedAMD1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glBlendFuncSeparateIndexedAMD(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glBlendFuncSeparateIndexedAMD = this._pat._addressof_glBlendFuncSeparateIndexedAMD;
        if (addressof_glBlendFuncSeparateIndexedAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparateIndexedAMD"));
        }
        this.dispatch_glBlendFuncSeparateIndexedAMD1(n, n2, n3, n4, n5, addressof_glBlendFuncSeparateIndexedAMD);
    }
    
    private native void dispatch_glBlendFuncSeparateIndexedAMD1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glBlendEquationIndexedAMD(final int n, final int n2) {
        final long addressof_glBlendEquationIndexedAMD = this._pat._addressof_glBlendEquationIndexedAMD;
        if (addressof_glBlendEquationIndexedAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationIndexedAMD"));
        }
        this.dispatch_glBlendEquationIndexedAMD1(n, n2, addressof_glBlendEquationIndexedAMD);
    }
    
    private native void dispatch_glBlendEquationIndexedAMD1(final int p0, final int p1, final long p2);
    
    @Override
    public void glBlendEquationSeparateIndexedAMD(final int n, final int n2, final int n3) {
        final long addressof_glBlendEquationSeparateIndexedAMD = this._pat._addressof_glBlendEquationSeparateIndexedAMD;
        if (addressof_glBlendEquationSeparateIndexedAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparateIndexedAMD"));
        }
        this.dispatch_glBlendEquationSeparateIndexedAMD1(n, n2, n3, addressof_glBlendEquationSeparateIndexedAMD);
    }
    
    private native void dispatch_glBlendEquationSeparateIndexedAMD1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glUniform1i64NV(final int n, final long n2) {
        final long addressof_glUniform1i64NV = this._pat._addressof_glUniform1i64NV;
        if (addressof_glUniform1i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64NV"));
        }
        this.dispatch_glUniform1i64NV1(n, n2, addressof_glUniform1i64NV);
    }
    
    private native void dispatch_glUniform1i64NV1(final int p0, final long p1, final long p2);
    
    @Override
    public void glUniform2i64NV(final int n, final long n2, final long n3) {
        final long addressof_glUniform2i64NV = this._pat._addressof_glUniform2i64NV;
        if (addressof_glUniform2i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64NV"));
        }
        this.dispatch_glUniform2i64NV1(n, n2, n3, addressof_glUniform2i64NV);
    }
    
    private native void dispatch_glUniform2i64NV1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glUniform3i64NV(final int n, final long n2, final long n3, final long n4) {
        final long addressof_glUniform3i64NV = this._pat._addressof_glUniform3i64NV;
        if (addressof_glUniform3i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64NV"));
        }
        this.dispatch_glUniform3i64NV1(n, n2, n3, n4, addressof_glUniform3i64NV);
    }
    
    private native void dispatch_glUniform3i64NV1(final int p0, final long p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glUniform4i64NV(final int n, final long n2, final long n3, final long n4, final long n5) {
        final long addressof_glUniform4i64NV = this._pat._addressof_glUniform4i64NV;
        if (addressof_glUniform4i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64NV"));
        }
        this.dispatch_glUniform4i64NV1(n, n2, n3, n4, n5, addressof_glUniform4i64NV);
    }
    
    private native void dispatch_glUniform4i64NV1(final int p0, final long p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glUniform1i64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform1i64vNV = this._pat._addressof_glUniform1i64vNV;
        if (addressof_glUniform1i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vNV"));
        }
        this.dispatch_glUniform1i64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform1i64vNV);
    }
    
    private native void dispatch_glUniform1i64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1i64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1i64vNV = this._pat._addressof_glUniform1i64vNV;
        if (addressof_glUniform1i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vNV"));
        }
        this.dispatch_glUniform1i64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform1i64vNV);
    }
    
    @Override
    public void glUniform2i64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform2i64vNV = this._pat._addressof_glUniform2i64vNV;
        if (addressof_glUniform2i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vNV"));
        }
        this.dispatch_glUniform2i64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform2i64vNV);
    }
    
    private native void dispatch_glUniform2i64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2i64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2i64vNV = this._pat._addressof_glUniform2i64vNV;
        if (addressof_glUniform2i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vNV"));
        }
        this.dispatch_glUniform2i64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform2i64vNV);
    }
    
    @Override
    public void glUniform3i64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform3i64vNV = this._pat._addressof_glUniform3i64vNV;
        if (addressof_glUniform3i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vNV"));
        }
        this.dispatch_glUniform3i64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform3i64vNV);
    }
    
    private native void dispatch_glUniform3i64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3i64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3i64vNV = this._pat._addressof_glUniform3i64vNV;
        if (addressof_glUniform3i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vNV"));
        }
        this.dispatch_glUniform3i64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform3i64vNV);
    }
    
    @Override
    public void glUniform4i64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform4i64vNV = this._pat._addressof_glUniform4i64vNV;
        if (addressof_glUniform4i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vNV"));
        }
        this.dispatch_glUniform4i64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform4i64vNV);
    }
    
    private native void dispatch_glUniform4i64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4i64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4i64vNV = this._pat._addressof_glUniform4i64vNV;
        if (addressof_glUniform4i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vNV"));
        }
        this.dispatch_glUniform4i64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform4i64vNV);
    }
    
    @Override
    public void glUniform1ui64NV(final int n, final long n2) {
        final long addressof_glUniform1ui64NV = this._pat._addressof_glUniform1ui64NV;
        if (addressof_glUniform1ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64NV"));
        }
        this.dispatch_glUniform1ui64NV1(n, n2, addressof_glUniform1ui64NV);
    }
    
    private native void dispatch_glUniform1ui64NV1(final int p0, final long p1, final long p2);
    
    @Override
    public void glUniform2ui64NV(final int n, final long n2, final long n3) {
        final long addressof_glUniform2ui64NV = this._pat._addressof_glUniform2ui64NV;
        if (addressof_glUniform2ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64NV"));
        }
        this.dispatch_glUniform2ui64NV1(n, n2, n3, addressof_glUniform2ui64NV);
    }
    
    private native void dispatch_glUniform2ui64NV1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glUniform3ui64NV(final int n, final long n2, final long n3, final long n4) {
        final long addressof_glUniform3ui64NV = this._pat._addressof_glUniform3ui64NV;
        if (addressof_glUniform3ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64NV"));
        }
        this.dispatch_glUniform3ui64NV1(n, n2, n3, n4, addressof_glUniform3ui64NV);
    }
    
    private native void dispatch_glUniform3ui64NV1(final int p0, final long p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glUniform4ui64NV(final int n, final long n2, final long n3, final long n4, final long n5) {
        final long addressof_glUniform4ui64NV = this._pat._addressof_glUniform4ui64NV;
        if (addressof_glUniform4ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64NV"));
        }
        this.dispatch_glUniform4ui64NV1(n, n2, n3, n4, n5, addressof_glUniform4ui64NV);
    }
    
    private native void dispatch_glUniform4ui64NV1(final int p0, final long p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glUniform1ui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform1ui64vNV = this._pat._addressof_glUniform1ui64vNV;
        if (addressof_glUniform1ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vNV"));
        }
        this.dispatch_glUniform1ui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform1ui64vNV);
    }
    
    private native void dispatch_glUniform1ui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform1ui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform1ui64vNV = this._pat._addressof_glUniform1ui64vNV;
        if (addressof_glUniform1ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vNV"));
        }
        this.dispatch_glUniform1ui64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform1ui64vNV);
    }
    
    @Override
    public void glUniform2ui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform2ui64vNV = this._pat._addressof_glUniform2ui64vNV;
        if (addressof_glUniform2ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vNV"));
        }
        this.dispatch_glUniform2ui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform2ui64vNV);
    }
    
    private native void dispatch_glUniform2ui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform2ui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform2ui64vNV = this._pat._addressof_glUniform2ui64vNV;
        if (addressof_glUniform2ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vNV"));
        }
        this.dispatch_glUniform2ui64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform2ui64vNV);
    }
    
    @Override
    public void glUniform3ui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform3ui64vNV = this._pat._addressof_glUniform3ui64vNV;
        if (addressof_glUniform3ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vNV"));
        }
        this.dispatch_glUniform3ui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform3ui64vNV);
    }
    
    private native void dispatch_glUniform3ui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform3ui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform3ui64vNV = this._pat._addressof_glUniform3ui64vNV;
        if (addressof_glUniform3ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vNV"));
        }
        this.dispatch_glUniform3ui64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform3ui64vNV);
    }
    
    @Override
    public void glUniform4ui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniform4ui64vNV = this._pat._addressof_glUniform4ui64vNV;
        if (addressof_glUniform4ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vNV"));
        }
        this.dispatch_glUniform4ui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniform4ui64vNV);
    }
    
    private native void dispatch_glUniform4ui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniform4ui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniform4ui64vNV = this._pat._addressof_glUniform4ui64vNV;
        if (addressof_glUniform4ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vNV"));
        }
        this.dispatch_glUniform4ui64vNV1(n, n2, array, 8 * n3, false, addressof_glUniform4ui64vNV);
    }
    
    @Override
    public void glGetUniformi64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetUniformi64vNV = this._pat._addressof_glGetUniformi64vNV;
        if (addressof_glGetUniformi64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vNV"));
        }
        this.dispatch_glGetUniformi64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetUniformi64vNV);
    }
    
    private native void dispatch_glGetUniformi64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformi64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformi64vNV = this._pat._addressof_glGetUniformi64vNV;
        if (addressof_glGetUniformi64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vNV"));
        }
        this.dispatch_glGetUniformi64vNV1(n, n2, array, 8 * n3, false, addressof_glGetUniformi64vNV);
    }
    
    @Override
    public void glGetUniformui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetUniformui64vNV = this._pat._addressof_glGetUniformui64vNV;
        if (addressof_glGetUniformui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vNV"));
        }
        this.dispatch_glGetUniformui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetUniformui64vNV);
    }
    
    private native void dispatch_glGetUniformui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetUniformui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetUniformui64vNV = this._pat._addressof_glGetUniformui64vNV;
        if (addressof_glGetUniformui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vNV"));
        }
        this.dispatch_glGetUniformui64vNV1(n, n2, array, 8 * n3, false, addressof_glGetUniformui64vNV);
    }
    
    @Override
    public void glProgramUniform1i64NV(final int n, final int n2, final long n3) {
        final long addressof_glProgramUniform1i64NV = this._pat._addressof_glProgramUniform1i64NV;
        if (addressof_glProgramUniform1i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64NV"));
        }
        this.dispatch_glProgramUniform1i64NV1(n, n2, n3, addressof_glProgramUniform1i64NV);
    }
    
    private native void dispatch_glProgramUniform1i64NV1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glProgramUniform2i64NV(final int n, final int n2, final long n3, final long n4) {
        final long addressof_glProgramUniform2i64NV = this._pat._addressof_glProgramUniform2i64NV;
        if (addressof_glProgramUniform2i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64NV"));
        }
        this.dispatch_glProgramUniform2i64NV1(n, n2, n3, n4, addressof_glProgramUniform2i64NV);
    }
    
    private native void dispatch_glProgramUniform2i64NV1(final int p0, final int p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glProgramUniform3i64NV(final int n, final int n2, final long n3, final long n4, final long n5) {
        final long addressof_glProgramUniform3i64NV = this._pat._addressof_glProgramUniform3i64NV;
        if (addressof_glProgramUniform3i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64NV"));
        }
        this.dispatch_glProgramUniform3i64NV1(n, n2, n3, n4, n5, addressof_glProgramUniform3i64NV);
    }
    
    private native void dispatch_glProgramUniform3i64NV1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glProgramUniform4i64NV(final int n, final int n2, final long n3, final long n4, final long n5, final long n6) {
        final long addressof_glProgramUniform4i64NV = this._pat._addressof_glProgramUniform4i64NV;
        if (addressof_glProgramUniform4i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64NV"));
        }
        this.dispatch_glProgramUniform4i64NV1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4i64NV);
    }
    
    private native void dispatch_glProgramUniform4i64NV1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5, final long p6);
    
    @Override
    public void glProgramUniform1i64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform1i64vNV = this._pat._addressof_glProgramUniform1i64vNV;
        if (addressof_glProgramUniform1i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vNV"));
        }
        this.dispatch_glProgramUniform1i64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform1i64vNV);
    }
    
    private native void dispatch_glProgramUniform1i64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1i64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1i64vNV = this._pat._addressof_glProgramUniform1i64vNV;
        if (addressof_glProgramUniform1i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vNV"));
        }
        this.dispatch_glProgramUniform1i64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform1i64vNV);
    }
    
    @Override
    public void glProgramUniform2i64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform2i64vNV = this._pat._addressof_glProgramUniform2i64vNV;
        if (addressof_glProgramUniform2i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vNV"));
        }
        this.dispatch_glProgramUniform2i64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform2i64vNV);
    }
    
    private native void dispatch_glProgramUniform2i64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2i64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2i64vNV = this._pat._addressof_glProgramUniform2i64vNV;
        if (addressof_glProgramUniform2i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vNV"));
        }
        this.dispatch_glProgramUniform2i64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform2i64vNV);
    }
    
    @Override
    public void glProgramUniform3i64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform3i64vNV = this._pat._addressof_glProgramUniform3i64vNV;
        if (addressof_glProgramUniform3i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vNV"));
        }
        this.dispatch_glProgramUniform3i64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform3i64vNV);
    }
    
    private native void dispatch_glProgramUniform3i64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3i64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3i64vNV = this._pat._addressof_glProgramUniform3i64vNV;
        if (addressof_glProgramUniform3i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vNV"));
        }
        this.dispatch_glProgramUniform3i64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform3i64vNV);
    }
    
    @Override
    public void glProgramUniform4i64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform4i64vNV = this._pat._addressof_glProgramUniform4i64vNV;
        if (addressof_glProgramUniform4i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vNV"));
        }
        this.dispatch_glProgramUniform4i64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform4i64vNV);
    }
    
    private native void dispatch_glProgramUniform4i64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4i64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4i64vNV = this._pat._addressof_glProgramUniform4i64vNV;
        if (addressof_glProgramUniform4i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vNV"));
        }
        this.dispatch_glProgramUniform4i64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform4i64vNV);
    }
    
    @Override
    public void glProgramUniform1ui64NV(final int n, final int n2, final long n3) {
        final long addressof_glProgramUniform1ui64NV = this._pat._addressof_glProgramUniform1ui64NV;
        if (addressof_glProgramUniform1ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64NV"));
        }
        this.dispatch_glProgramUniform1ui64NV1(n, n2, n3, addressof_glProgramUniform1ui64NV);
    }
    
    private native void dispatch_glProgramUniform1ui64NV1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glProgramUniform2ui64NV(final int n, final int n2, final long n3, final long n4) {
        final long addressof_glProgramUniform2ui64NV = this._pat._addressof_glProgramUniform2ui64NV;
        if (addressof_glProgramUniform2ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64NV"));
        }
        this.dispatch_glProgramUniform2ui64NV1(n, n2, n3, n4, addressof_glProgramUniform2ui64NV);
    }
    
    private native void dispatch_glProgramUniform2ui64NV1(final int p0, final int p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glProgramUniform3ui64NV(final int n, final int n2, final long n3, final long n4, final long n5) {
        final long addressof_glProgramUniform3ui64NV = this._pat._addressof_glProgramUniform3ui64NV;
        if (addressof_glProgramUniform3ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64NV"));
        }
        this.dispatch_glProgramUniform3ui64NV1(n, n2, n3, n4, n5, addressof_glProgramUniform3ui64NV);
    }
    
    private native void dispatch_glProgramUniform3ui64NV1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glProgramUniform4ui64NV(final int n, final int n2, final long n3, final long n4, final long n5, final long n6) {
        final long addressof_glProgramUniform4ui64NV = this._pat._addressof_glProgramUniform4ui64NV;
        if (addressof_glProgramUniform4ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64NV"));
        }
        this.dispatch_glProgramUniform4ui64NV1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4ui64NV);
    }
    
    private native void dispatch_glProgramUniform4ui64NV1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5, final long p6);
    
    @Override
    public void glProgramUniform1ui64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform1ui64vNV = this._pat._addressof_glProgramUniform1ui64vNV;
        if (addressof_glProgramUniform1ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vNV"));
        }
        this.dispatch_glProgramUniform1ui64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform1ui64vNV);
    }
    
    private native void dispatch_glProgramUniform1ui64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1ui64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1ui64vNV = this._pat._addressof_glProgramUniform1ui64vNV;
        if (addressof_glProgramUniform1ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vNV"));
        }
        this.dispatch_glProgramUniform1ui64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform1ui64vNV);
    }
    
    @Override
    public void glProgramUniform2ui64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform2ui64vNV = this._pat._addressof_glProgramUniform2ui64vNV;
        if (addressof_glProgramUniform2ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vNV"));
        }
        this.dispatch_glProgramUniform2ui64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform2ui64vNV);
    }
    
    private native void dispatch_glProgramUniform2ui64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2ui64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2ui64vNV = this._pat._addressof_glProgramUniform2ui64vNV;
        if (addressof_glProgramUniform2ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vNV"));
        }
        this.dispatch_glProgramUniform2ui64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform2ui64vNV);
    }
    
    @Override
    public void glProgramUniform3ui64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform3ui64vNV = this._pat._addressof_glProgramUniform3ui64vNV;
        if (addressof_glProgramUniform3ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vNV"));
        }
        this.dispatch_glProgramUniform3ui64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform3ui64vNV);
    }
    
    private native void dispatch_glProgramUniform3ui64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3ui64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3ui64vNV = this._pat._addressof_glProgramUniform3ui64vNV;
        if (addressof_glProgramUniform3ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vNV"));
        }
        this.dispatch_glProgramUniform3ui64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform3ui64vNV);
    }
    
    @Override
    public void glProgramUniform4ui64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniform4ui64vNV = this._pat._addressof_glProgramUniform4ui64vNV;
        if (addressof_glProgramUniform4ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vNV"));
        }
        this.dispatch_glProgramUniform4ui64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniform4ui64vNV);
    }
    
    private native void dispatch_glProgramUniform4ui64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4ui64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4ui64vNV = this._pat._addressof_glProgramUniform4ui64vNV;
        if (addressof_glProgramUniform4ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vNV"));
        }
        this.dispatch_glProgramUniform4ui64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform4ui64vNV);
    }
    
    @Override
    public void glVertexAttribParameteriAMD(final int n, final int n2, final int n3) {
        final long addressof_glVertexAttribParameteriAMD = this._pat._addressof_glVertexAttribParameteriAMD;
        if (addressof_glVertexAttribParameteriAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribParameteriAMD"));
        }
        this.dispatch_glVertexAttribParameteriAMD1(n, n2, n3, addressof_glVertexAttribParameteriAMD);
    }
    
    private native void dispatch_glVertexAttribParameteriAMD1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiDrawArraysIndirectAMD(final int n, final Buffer buffer, final int n2, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawArraysIndirectAMD = this._pat._addressof_glMultiDrawArraysIndirectAMD;
        if (addressof_glMultiDrawArraysIndirectAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectAMD"));
        }
        this.dispatch_glMultiDrawArraysIndirectAMD1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n2, n3, addressof_glMultiDrawArraysIndirectAMD);
    }
    
    private native void dispatch_glMultiDrawArraysIndirectAMD1(final int p0, final Object p1, final int p2, final boolean p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glMultiDrawElementsIndirectAMD(final int n, final int n2, final Buffer buffer, final int n3, final int n4) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawElementsIndirectAMD = this._pat._addressof_glMultiDrawElementsIndirectAMD;
        if (addressof_glMultiDrawElementsIndirectAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectAMD"));
        }
        this.dispatch_glMultiDrawElementsIndirectAMD1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, n4, addressof_glMultiDrawElementsIndirectAMD);
    }
    
    private native void dispatch_glMultiDrawElementsIndirectAMD1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glGenNamesAMD(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenNamesAMD = this._pat._addressof_glGenNamesAMD;
        if (addressof_glGenNamesAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenNamesAMD"));
        }
        this.dispatch_glGenNamesAMD1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenNamesAMD);
    }
    
    private native void dispatch_glGenNamesAMD1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGenNamesAMD(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"names_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenNamesAMD = this._pat._addressof_glGenNamesAMD;
        if (addressof_glGenNamesAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenNamesAMD"));
        }
        this.dispatch_glGenNamesAMD1(n, n2, array, 4 * n3, false, addressof_glGenNamesAMD);
    }
    
    @Override
    public void glDeleteNamesAMD(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteNamesAMD = this._pat._addressof_glDeleteNamesAMD;
        if (addressof_glDeleteNamesAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteNamesAMD"));
        }
        this.dispatch_glDeleteNamesAMD1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteNamesAMD);
    }
    
    private native void dispatch_glDeleteNamesAMD1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glDeleteNamesAMD(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"names_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteNamesAMD = this._pat._addressof_glDeleteNamesAMD;
        if (addressof_glDeleteNamesAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteNamesAMD"));
        }
        this.dispatch_glDeleteNamesAMD1(n, n2, array, 4 * n3, false, addressof_glDeleteNamesAMD);
    }
    
    @Override
    public boolean glIsNameAMD(final int n, final int n2) {
        final long addressof_glIsNameAMD = this._pat._addressof_glIsNameAMD;
        if (addressof_glIsNameAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsNameAMD"));
        }
        return this.dispatch_glIsNameAMD1(n, n2, addressof_glIsNameAMD);
    }
    
    private native boolean dispatch_glIsNameAMD1(final int p0, final int p1, final long p2);
    
    @Override
    public void glQueryObjectParameteruiAMD(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glQueryObjectParameteruiAMD = this._pat._addressof_glQueryObjectParameteruiAMD;
        if (addressof_glQueryObjectParameteruiAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glQueryObjectParameteruiAMD"));
        }
        this.dispatch_glQueryObjectParameteruiAMD1(n, n2, n3, n4, addressof_glQueryObjectParameteruiAMD);
    }
    
    private native void dispatch_glQueryObjectParameteruiAMD1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glGetPerfMonitorGroupsAMD(final IntBuffer intBuffer, final int n, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glGetPerfMonitorGroupsAMD = this._pat._addressof_glGetPerfMonitorGroupsAMD;
        if (addressof_glGetPerfMonitorGroupsAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupsAMD"));
        }
        this.dispatch_glGetPerfMonitorGroupsAMD1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, n, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glGetPerfMonitorGroupsAMD);
    }
    
    private native void dispatch_glGetPerfMonitorGroupsAMD1(final Object p0, final int p1, final boolean p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetPerfMonitorGroupsAMD(final int[] array, final int n, final int n2, final int[] array2, final int n3) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"numGroups_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"groups_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetPerfMonitorGroupsAMD = this._pat._addressof_glGetPerfMonitorGroupsAMD;
        if (addressof_glGetPerfMonitorGroupsAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupsAMD"));
        }
        this.dispatch_glGetPerfMonitorGroupsAMD1(array, 4 * n, false, n2, array2, 4 * n3, false, addressof_glGetPerfMonitorGroupsAMD);
    }
    
    @Override
    public void glGetPerfMonitorCountersAMD(final int n, final IntBuffer intBuffer, final IntBuffer intBuffer2, final int n2, final IntBuffer intBuffer3) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer3);
        final long addressof_glGetPerfMonitorCountersAMD = this._pat._addressof_glGetPerfMonitorCountersAMD;
        if (addressof_glGetPerfMonitorCountersAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCountersAMD"));
        }
        this.dispatch_glGetPerfMonitorCountersAMD1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, n2, direct3 ? intBuffer3 : Buffers.getArray(intBuffer3), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct3, addressof_glGetPerfMonitorCountersAMD);
    }
    
    private native void dispatch_glGetPerfMonitorCountersAMD1(final int p0, final Object p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glGetPerfMonitorCountersAMD(final int n, final int[] array, final int n2, final int[] array2, final int n3, final int n4, final int[] array3, final int n5) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"numCounters_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"maxActiveCounters_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n5) {
            throw new GLException("array offset argument \"counters_offset\" (" + n5 + ") equals or exceeds array length (" + array3.length + ")");
        }
        final long addressof_glGetPerfMonitorCountersAMD = this._pat._addressof_glGetPerfMonitorCountersAMD;
        if (addressof_glGetPerfMonitorCountersAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCountersAMD"));
        }
        this.dispatch_glGetPerfMonitorCountersAMD1(n, array, 4 * n2, false, array2, 4 * n3, false, n4, array3, 4 * n5, false, addressof_glGetPerfMonitorCountersAMD);
    }
    
    @Override
    public void glGetPerfMonitorGroupStringAMD(final int n, final int n2, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetPerfMonitorGroupStringAMD = this._pat._addressof_glGetPerfMonitorGroupStringAMD;
        if (addressof_glGetPerfMonitorGroupStringAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupStringAMD"));
        }
        this.dispatch_glGetPerfMonitorGroupStringAMD1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetPerfMonitorGroupStringAMD);
    }
    
    private native void dispatch_glGetPerfMonitorGroupStringAMD1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetPerfMonitorGroupStringAMD(final int n, final int n2, final int[] array, final int n3, final byte[] array2, final int n4) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"length_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"groupString_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetPerfMonitorGroupStringAMD = this._pat._addressof_glGetPerfMonitorGroupStringAMD;
        if (addressof_glGetPerfMonitorGroupStringAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupStringAMD"));
        }
        this.dispatch_glGetPerfMonitorGroupStringAMD1(n, n2, array, 4 * n3, false, array2, n4, false, addressof_glGetPerfMonitorGroupStringAMD);
    }
    
    @Override
    public void glGetPerfMonitorCounterStringAMD(final int n, final int n2, final int n3, final IntBuffer intBuffer, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer);
        final long addressof_glGetPerfMonitorCounterStringAMD = this._pat._addressof_glGetPerfMonitorCounterStringAMD;
        if (addressof_glGetPerfMonitorCounterStringAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterStringAMD"));
        }
        this.dispatch_glGetPerfMonitorCounterStringAMD1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? byteBuffer : Buffers.getArray(byteBuffer), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct2, addressof_glGetPerfMonitorCounterStringAMD);
    }
    
    private native void dispatch_glGetPerfMonitorCounterStringAMD1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetPerfMonitorCounterStringAMD(final int n, final int n2, final int n3, final int[] array, final int n4, final byte[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"counterString_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetPerfMonitorCounterStringAMD = this._pat._addressof_glGetPerfMonitorCounterStringAMD;
        if (addressof_glGetPerfMonitorCounterStringAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterStringAMD"));
        }
        this.dispatch_glGetPerfMonitorCounterStringAMD1(n, n2, n3, array, 4 * n4, false, array2, n5, false, addressof_glGetPerfMonitorCounterStringAMD);
    }
    
    @Override
    public void glGetPerfMonitorCounterInfoAMD(final int n, final int n2, final int n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetPerfMonitorCounterInfoAMD = this._pat._addressof_glGetPerfMonitorCounterInfoAMD;
        if (addressof_glGetPerfMonitorCounterInfoAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterInfoAMD"));
        }
        this.dispatch_glGetPerfMonitorCounterInfoAMD1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetPerfMonitorCounterInfoAMD);
    }
    
    private native void dispatch_glGetPerfMonitorCounterInfoAMD1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGenPerfMonitorsAMD(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenPerfMonitorsAMD = this._pat._addressof_glGenPerfMonitorsAMD;
        if (addressof_glGenPerfMonitorsAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenPerfMonitorsAMD"));
        }
        this.dispatch_glGenPerfMonitorsAMD1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenPerfMonitorsAMD);
    }
    
    private native void dispatch_glGenPerfMonitorsAMD1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenPerfMonitorsAMD(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"monitors_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenPerfMonitorsAMD = this._pat._addressof_glGenPerfMonitorsAMD;
        if (addressof_glGenPerfMonitorsAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenPerfMonitorsAMD"));
        }
        this.dispatch_glGenPerfMonitorsAMD1(n, array, 4 * n2, false, addressof_glGenPerfMonitorsAMD);
    }
    
    @Override
    public void glDeletePerfMonitorsAMD(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeletePerfMonitorsAMD = this._pat._addressof_glDeletePerfMonitorsAMD;
        if (addressof_glDeletePerfMonitorsAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfMonitorsAMD"));
        }
        this.dispatch_glDeletePerfMonitorsAMD1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeletePerfMonitorsAMD);
    }
    
    private native void dispatch_glDeletePerfMonitorsAMD1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeletePerfMonitorsAMD(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"monitors_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeletePerfMonitorsAMD = this._pat._addressof_glDeletePerfMonitorsAMD;
        if (addressof_glDeletePerfMonitorsAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfMonitorsAMD"));
        }
        this.dispatch_glDeletePerfMonitorsAMD1(n, array, 4 * n2, false, addressof_glDeletePerfMonitorsAMD);
    }
    
    @Override
    public void glSelectPerfMonitorCountersAMD(final int n, final boolean b, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glSelectPerfMonitorCountersAMD = this._pat._addressof_glSelectPerfMonitorCountersAMD;
        if (addressof_glSelectPerfMonitorCountersAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSelectPerfMonitorCountersAMD"));
        }
        this.dispatch_glSelectPerfMonitorCountersAMD1(n, b, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glSelectPerfMonitorCountersAMD);
    }
    
    private native void dispatch_glSelectPerfMonitorCountersAMD1(final int p0, final boolean p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glSelectPerfMonitorCountersAMD(final int n, final boolean b, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"counterList_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSelectPerfMonitorCountersAMD = this._pat._addressof_glSelectPerfMonitorCountersAMD;
        if (addressof_glSelectPerfMonitorCountersAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSelectPerfMonitorCountersAMD"));
        }
        this.dispatch_glSelectPerfMonitorCountersAMD1(n, b, n2, n3, array, 4 * n4, false, addressof_glSelectPerfMonitorCountersAMD);
    }
    
    @Override
    public void glBeginPerfMonitorAMD(final int n) {
        final long addressof_glBeginPerfMonitorAMD = this._pat._addressof_glBeginPerfMonitorAMD;
        if (addressof_glBeginPerfMonitorAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginPerfMonitorAMD"));
        }
        this.dispatch_glBeginPerfMonitorAMD1(n, addressof_glBeginPerfMonitorAMD);
    }
    
    private native void dispatch_glBeginPerfMonitorAMD1(final int p0, final long p1);
    
    @Override
    public void glEndPerfMonitorAMD(final int n) {
        final long addressof_glEndPerfMonitorAMD = this._pat._addressof_glEndPerfMonitorAMD;
        if (addressof_glEndPerfMonitorAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndPerfMonitorAMD"));
        }
        this.dispatch_glEndPerfMonitorAMD1(n, addressof_glEndPerfMonitorAMD);
    }
    
    private native void dispatch_glEndPerfMonitorAMD1(final int p0, final long p1);
    
    @Override
    public void glGetPerfMonitorCounterDataAMD(final int n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glGetPerfMonitorCounterDataAMD = this._pat._addressof_glGetPerfMonitorCounterDataAMD;
        if (addressof_glGetPerfMonitorCounterDataAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterDataAMD"));
        }
        this.dispatch_glGetPerfMonitorCounterDataAMD1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glGetPerfMonitorCounterDataAMD);
    }
    
    private native void dispatch_glGetPerfMonitorCounterDataAMD1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetPerfMonitorCounterDataAMD(final int n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"data_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"bytesWritten_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetPerfMonitorCounterDataAMD = this._pat._addressof_glGetPerfMonitorCounterDataAMD;
        if (addressof_glGetPerfMonitorCounterDataAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterDataAMD"));
        }
        this.dispatch_glGetPerfMonitorCounterDataAMD1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, addressof_glGetPerfMonitorCounterDataAMD);
    }
    
    @Override
    public void glSetMultisamplefvAMD(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glSetMultisamplefvAMD = this._pat._addressof_glSetMultisamplefvAMD;
        if (addressof_glSetMultisamplefvAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSetMultisamplefvAMD"));
        }
        this.dispatch_glSetMultisamplefvAMD1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glSetMultisamplefvAMD);
    }
    
    private native void dispatch_glSetMultisamplefvAMD1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glSetMultisamplefvAMD(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"val_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSetMultisamplefvAMD = this._pat._addressof_glSetMultisamplefvAMD;
        if (addressof_glSetMultisamplefvAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSetMultisamplefvAMD"));
        }
        this.dispatch_glSetMultisamplefvAMD1(n, n2, array, 4 * n3, false, addressof_glSetMultisamplefvAMD);
    }
    
    @Override
    public void glTexStorageSparseAMD(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7) {
        final long addressof_glTexStorageSparseAMD = this._pat._addressof_glTexStorageSparseAMD;
        if (addressof_glTexStorageSparseAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexStorageSparseAMD"));
        }
        this.dispatch_glTexStorageSparseAMD1(n, n2, n3, n4, n5, n6, n7, addressof_glTexStorageSparseAMD);
    }
    
    private native void dispatch_glTexStorageSparseAMD1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glTextureStorageSparseAMD(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glTextureStorageSparseAMD = this._pat._addressof_glTextureStorageSparseAMD;
        if (addressof_glTextureStorageSparseAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorageSparseAMD"));
        }
        this.dispatch_glTextureStorageSparseAMD1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glTextureStorageSparseAMD);
    }
    
    private native void dispatch_glTextureStorageSparseAMD1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glStencilOpValueAMD(final int n, final int n2) {
        final long addressof_glStencilOpValueAMD = this._pat._addressof_glStencilOpValueAMD;
        if (addressof_glStencilOpValueAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilOpValueAMD"));
        }
        this.dispatch_glStencilOpValueAMD1(n, n2, addressof_glStencilOpValueAMD);
    }
    
    private native void dispatch_glStencilOpValueAMD1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTessellationFactorAMD(final float n) {
        final long addressof_glTessellationFactorAMD = this._pat._addressof_glTessellationFactorAMD;
        if (addressof_glTessellationFactorAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTessellationFactorAMD"));
        }
        this.dispatch_glTessellationFactorAMD1(n, addressof_glTessellationFactorAMD);
    }
    
    private native void dispatch_glTessellationFactorAMD1(final float p0, final long p1);
    
    @Override
    public void glTessellationModeAMD(final int n) {
        final long addressof_glTessellationModeAMD = this._pat._addressof_glTessellationModeAMD;
        if (addressof_glTessellationModeAMD == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTessellationModeAMD"));
        }
        this.dispatch_glTessellationModeAMD1(n, addressof_glTessellationModeAMD);
    }
    
    private native void dispatch_glTessellationModeAMD1(final int p0, final long p1);
    
    @Override
    public void glBufferParameteri(final int n, final int n2, final int n3) {
        final long addressof_glBufferParameteri = this._pat._addressof_glBufferParameteri;
        if (addressof_glBufferParameteri == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBufferParameteri"));
        }
        this.dispatch_glBufferParameteri1(n, n2, n3, addressof_glBufferParameteri);
    }
    
    private native void dispatch_glBufferParameteri1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public int glObjectPurgeableAPPLE(final int n, final int n2, final int n3) {
        final long addressof_glObjectPurgeableAPPLE = this._pat._addressof_glObjectPurgeableAPPLE;
        if (addressof_glObjectPurgeableAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glObjectPurgeableAPPLE"));
        }
        return this.dispatch_glObjectPurgeableAPPLE1(n, n2, n3, addressof_glObjectPurgeableAPPLE);
    }
    
    private native int dispatch_glObjectPurgeableAPPLE1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public int glObjectUnpurgeableAPPLE(final int n, final int n2, final int n3) {
        final long addressof_glObjectUnpurgeableAPPLE = this._pat._addressof_glObjectUnpurgeableAPPLE;
        if (addressof_glObjectUnpurgeableAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glObjectUnpurgeableAPPLE"));
        }
        return this.dispatch_glObjectUnpurgeableAPPLE1(n, n2, n3, addressof_glObjectUnpurgeableAPPLE);
    }
    
    private native int dispatch_glObjectUnpurgeableAPPLE1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glGetObjectParameterivAPPLE(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetObjectParameterivAPPLE = this._pat._addressof_glGetObjectParameterivAPPLE;
        if (addressof_glGetObjectParameterivAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivAPPLE"));
        }
        this.dispatch_glGetObjectParameterivAPPLE1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetObjectParameterivAPPLE);
    }
    
    private native void dispatch_glGetObjectParameterivAPPLE1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetObjectParameterivAPPLE(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetObjectParameterivAPPLE = this._pat._addressof_glGetObjectParameterivAPPLE;
        if (addressof_glGetObjectParameterivAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivAPPLE"));
        }
        this.dispatch_glGetObjectParameterivAPPLE1(n, n2, n3, array, 4 * n4, false, addressof_glGetObjectParameterivAPPLE);
    }
    
    @Override
    public void glTextureRangeAPPLE(final int n, final int n2, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureRangeAPPLE = this._pat._addressof_glTextureRangeAPPLE;
        if (addressof_glTextureRangeAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureRangeAPPLE"));
        }
        this.dispatch_glTextureRangeAPPLE1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureRangeAPPLE);
    }
    
    private native void dispatch_glTextureRangeAPPLE1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glVertexArrayRangeAPPLE(final int n, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glVertexArrayRangeAPPLE = this._pat._addressof_glVertexArrayRangeAPPLE;
        if (addressof_glVertexArrayRangeAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayRangeAPPLE"));
        }
        this.dispatch_glVertexArrayRangeAPPLE1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glVertexArrayRangeAPPLE);
    }
    
    private native void dispatch_glVertexArrayRangeAPPLE1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glFlushVertexArrayRangeAPPLE(final int n, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glFlushVertexArrayRangeAPPLE = this._pat._addressof_glFlushVertexArrayRangeAPPLE;
        if (addressof_glFlushVertexArrayRangeAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFlushVertexArrayRangeAPPLE"));
        }
        this.dispatch_glFlushVertexArrayRangeAPPLE1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glFlushVertexArrayRangeAPPLE);
    }
    
    private native void dispatch_glFlushVertexArrayRangeAPPLE1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexArrayParameteriAPPLE(final int n, final int n2) {
        final long addressof_glVertexArrayParameteriAPPLE = this._pat._addressof_glVertexArrayParameteriAPPLE;
        if (addressof_glVertexArrayParameteriAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayParameteriAPPLE"));
        }
        this.dispatch_glVertexArrayParameteriAPPLE1(n, n2, addressof_glVertexArrayParameteriAPPLE);
    }
    
    private native void dispatch_glVertexArrayParameteriAPPLE1(final int p0, final int p1, final long p2);
    
    @Override
    public void glEnableVertexAttribAPPLE(final int n, final int n2) {
        final long addressof_glEnableVertexAttribAPPLE = this._pat._addressof_glEnableVertexAttribAPPLE;
        if (addressof_glEnableVertexAttribAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribAPPLE"));
        }
        this.dispatch_glEnableVertexAttribAPPLE1(n, n2, addressof_glEnableVertexAttribAPPLE);
    }
    
    private native void dispatch_glEnableVertexAttribAPPLE1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisableVertexAttribAPPLE(final int n, final int n2) {
        final long addressof_glDisableVertexAttribAPPLE = this._pat._addressof_glDisableVertexAttribAPPLE;
        if (addressof_glDisableVertexAttribAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribAPPLE"));
        }
        this.dispatch_glDisableVertexAttribAPPLE1(n, n2, addressof_glDisableVertexAttribAPPLE);
    }
    
    private native void dispatch_glDisableVertexAttribAPPLE1(final int p0, final int p1, final long p2);
    
    @Override
    public boolean glIsVertexAttribEnabledAPPLE(final int n, final int n2) {
        final long addressof_glIsVertexAttribEnabledAPPLE = this._pat._addressof_glIsVertexAttribEnabledAPPLE;
        if (addressof_glIsVertexAttribEnabledAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsVertexAttribEnabledAPPLE"));
        }
        return this.dispatch_glIsVertexAttribEnabledAPPLE1(n, n2, addressof_glIsVertexAttribEnabledAPPLE);
    }
    
    private native boolean dispatch_glIsVertexAttribEnabledAPPLE1(final int p0, final int p1, final long p2);
    
    @Override
    public void glMapVertexAttrib1dAPPLE(final int n, final int n2, final double n3, final double n4, final int n5, final int n6, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMapVertexAttrib1dAPPLE = this._pat._addressof_glMapVertexAttrib1dAPPLE;
        if (addressof_glMapVertexAttrib1dAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1dAPPLE"));
        }
        this.dispatch_glMapVertexAttrib1dAPPLE1(n, n2, n3, n4, n5, n6, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMapVertexAttrib1dAPPLE);
    }
    
    private native void dispatch_glMapVertexAttrib1dAPPLE1(final int p0, final int p1, final double p2, final double p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glMapVertexAttrib1dAPPLE(final int n, final int n2, final double n3, final double n4, final int n5, final int n6, final double[] array, final int n7) {
        if (array != null && array.length <= n7) {
            throw new GLException("array offset argument \"points_offset\" (" + n7 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMapVertexAttrib1dAPPLE = this._pat._addressof_glMapVertexAttrib1dAPPLE;
        if (addressof_glMapVertexAttrib1dAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1dAPPLE"));
        }
        this.dispatch_glMapVertexAttrib1dAPPLE1(n, n2, n3, n4, n5, n6, array, 8 * n7, false, addressof_glMapVertexAttrib1dAPPLE);
    }
    
    @Override
    public void glMapVertexAttrib1fAPPLE(final int n, final int n2, final float n3, final float n4, final int n5, final int n6, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMapVertexAttrib1fAPPLE = this._pat._addressof_glMapVertexAttrib1fAPPLE;
        if (addressof_glMapVertexAttrib1fAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1fAPPLE"));
        }
        this.dispatch_glMapVertexAttrib1fAPPLE1(n, n2, n3, n4, n5, n6, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMapVertexAttrib1fAPPLE);
    }
    
    private native void dispatch_glMapVertexAttrib1fAPPLE1(final int p0, final int p1, final float p2, final float p3, final int p4, final int p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glMapVertexAttrib1fAPPLE(final int n, final int n2, final float n3, final float n4, final int n5, final int n6, final float[] array, final int n7) {
        if (array != null && array.length <= n7) {
            throw new GLException("array offset argument \"points_offset\" (" + n7 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMapVertexAttrib1fAPPLE = this._pat._addressof_glMapVertexAttrib1fAPPLE;
        if (addressof_glMapVertexAttrib1fAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1fAPPLE"));
        }
        this.dispatch_glMapVertexAttrib1fAPPLE1(n, n2, n3, n4, n5, n6, array, 4 * n7, false, addressof_glMapVertexAttrib1fAPPLE);
    }
    
    @Override
    public void glMapVertexAttrib2dAPPLE(final int n, final int n2, final double n3, final double n4, final int n5, final int n6, final double n7, final double n8, final int n9, final int n10, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMapVertexAttrib2dAPPLE = this._pat._addressof_glMapVertexAttrib2dAPPLE;
        if (addressof_glMapVertexAttrib2dAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2dAPPLE"));
        }
        this.dispatch_glMapVertexAttrib2dAPPLE1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMapVertexAttrib2dAPPLE);
    }
    
    private native void dispatch_glMapVertexAttrib2dAPPLE1(final int p0, final int p1, final double p2, final double p3, final int p4, final int p5, final double p6, final double p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glMapVertexAttrib2dAPPLE(final int n, final int n2, final double n3, final double n4, final int n5, final int n6, final double n7, final double n8, final int n9, final int n10, final double[] array, final int n11) {
        if (array != null && array.length <= n11) {
            throw new GLException("array offset argument \"points_offset\" (" + n11 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMapVertexAttrib2dAPPLE = this._pat._addressof_glMapVertexAttrib2dAPPLE;
        if (addressof_glMapVertexAttrib2dAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2dAPPLE"));
        }
        this.dispatch_glMapVertexAttrib2dAPPLE1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, array, 8 * n11, false, addressof_glMapVertexAttrib2dAPPLE);
    }
    
    @Override
    public void glMapVertexAttrib2fAPPLE(final int n, final int n2, final float n3, final float n4, final int n5, final int n6, final float n7, final float n8, final int n9, final int n10, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMapVertexAttrib2fAPPLE = this._pat._addressof_glMapVertexAttrib2fAPPLE;
        if (addressof_glMapVertexAttrib2fAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2fAPPLE"));
        }
        this.dispatch_glMapVertexAttrib2fAPPLE1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMapVertexAttrib2fAPPLE);
    }
    
    private native void dispatch_glMapVertexAttrib2fAPPLE1(final int p0, final int p1, final float p2, final float p3, final int p4, final int p5, final float p6, final float p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glMapVertexAttrib2fAPPLE(final int n, final int n2, final float n3, final float n4, final int n5, final int n6, final float n7, final float n8, final int n9, final int n10, final float[] array, final int n11) {
        if (array != null && array.length <= n11) {
            throw new GLException("array offset argument \"points_offset\" (" + n11 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMapVertexAttrib2fAPPLE = this._pat._addressof_glMapVertexAttrib2fAPPLE;
        if (addressof_glMapVertexAttrib2fAPPLE == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2fAPPLE"));
        }
        this.dispatch_glMapVertexAttrib2fAPPLE1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, array, 4 * n11, false, addressof_glMapVertexAttrib2fAPPLE);
    }
    
    @Override
    public void glDrawBuffersATI(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDrawBuffersATI = this._pat._addressof_glDrawBuffersATI;
        if (addressof_glDrawBuffersATI == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersATI"));
        }
        this.dispatch_glDrawBuffersATI1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDrawBuffersATI);
    }
    
    private native void dispatch_glDrawBuffersATI1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDrawBuffersATI(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"bufs_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDrawBuffersATI = this._pat._addressof_glDrawBuffersATI;
        if (addressof_glDrawBuffersATI == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersATI"));
        }
        this.dispatch_glDrawBuffersATI1(n, array, 4 * n2, false, addressof_glDrawBuffersATI);
    }
    
    @Override
    public void glPNTrianglesiATI(final int n, final int n2) {
        final long addressof_glPNTrianglesiATI = this._pat._addressof_glPNTrianglesiATI;
        if (addressof_glPNTrianglesiATI == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPNTrianglesiATI"));
        }
        this.dispatch_glPNTrianglesiATI1(n, n2, addressof_glPNTrianglesiATI);
    }
    
    private native void dispatch_glPNTrianglesiATI1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPNTrianglesfATI(final int n, final float n2) {
        final long addressof_glPNTrianglesfATI = this._pat._addressof_glPNTrianglesfATI;
        if (addressof_glPNTrianglesfATI == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPNTrianglesfATI"));
        }
        this.dispatch_glPNTrianglesfATI1(n, n2, addressof_glPNTrianglesfATI);
    }
    
    private native void dispatch_glPNTrianglesfATI1(final int p0, final float p1, final long p2);
    
    @Override
    public void glUniformBufferEXT(final int n, final int n2, final int n3) {
        final long addressof_glUniformBufferEXT = this._pat._addressof_glUniformBufferEXT;
        if (addressof_glUniformBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformBufferEXT"));
        }
        this.dispatch_glUniformBufferEXT1(n, n2, n3, addressof_glUniformBufferEXT);
    }
    
    private native void dispatch_glUniformBufferEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public int glGetUniformBufferSizeEXT(final int n, final int n2) {
        final long addressof_glGetUniformBufferSizeEXT = this._pat._addressof_glGetUniformBufferSizeEXT;
        if (addressof_glGetUniformBufferSizeEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformBufferSizeEXT"));
        }
        return this.dispatch_glGetUniformBufferSizeEXT1(n, n2, addressof_glGetUniformBufferSizeEXT);
    }
    
    private native int dispatch_glGetUniformBufferSizeEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public long glGetUniformOffsetEXT(final int n, final int n2) {
        final long addressof_glGetUniformOffsetEXT = this._pat._addressof_glGetUniformOffsetEXT;
        if (addressof_glGetUniformOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetUniformOffsetEXT"));
        }
        return this.dispatch_glGetUniformOffsetEXT1(n, n2, addressof_glGetUniformOffsetEXT);
    }
    
    private native long dispatch_glGetUniformOffsetEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glLockArraysEXT(final int n, final int n2) {
        final long addressof_glLockArraysEXT = this._pat._addressof_glLockArraysEXT;
        if (addressof_glLockArraysEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glLockArraysEXT"));
        }
        this.dispatch_glLockArraysEXT1(n, n2, addressof_glLockArraysEXT);
    }
    
    private native void dispatch_glLockArraysEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glUnlockArraysEXT() {
        final long addressof_glUnlockArraysEXT = this._pat._addressof_glUnlockArraysEXT;
        if (addressof_glUnlockArraysEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUnlockArraysEXT"));
        }
        this.dispatch_glUnlockArraysEXT1(addressof_glUnlockArraysEXT);
    }
    
    private native void dispatch_glUnlockArraysEXT1(final long p0);
    
    @Override
    public void glCullParameterdvEXT(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glCullParameterdvEXT = this._pat._addressof_glCullParameterdvEXT;
        if (addressof_glCullParameterdvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCullParameterdvEXT"));
        }
        this.dispatch_glCullParameterdvEXT1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glCullParameterdvEXT);
    }
    
    private native void dispatch_glCullParameterdvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCullParameterdvEXT(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCullParameterdvEXT = this._pat._addressof_glCullParameterdvEXT;
        if (addressof_glCullParameterdvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCullParameterdvEXT"));
        }
        this.dispatch_glCullParameterdvEXT1(n, array, 8 * n2, false, addressof_glCullParameterdvEXT);
    }
    
    @Override
    public void glCullParameterfvEXT(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glCullParameterfvEXT = this._pat._addressof_glCullParameterfvEXT;
        if (addressof_glCullParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCullParameterfvEXT"));
        }
        this.dispatch_glCullParameterfvEXT1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glCullParameterfvEXT);
    }
    
    private native void dispatch_glCullParameterfvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCullParameterfvEXT(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"params_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCullParameterfvEXT = this._pat._addressof_glCullParameterfvEXT;
        if (addressof_glCullParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCullParameterfvEXT"));
        }
        this.dispatch_glCullParameterfvEXT1(n, array, 4 * n2, false, addressof_glCullParameterfvEXT);
    }
    
    @Override
    public void glDepthBoundsEXT(final double n, final double n2) {
        final long addressof_glDepthBoundsEXT = this._pat._addressof_glDepthBoundsEXT;
        if (addressof_glDepthBoundsEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDepthBoundsEXT"));
        }
        this.dispatch_glDepthBoundsEXT1(n, n2, addressof_glDepthBoundsEXT);
    }
    
    private native void dispatch_glDepthBoundsEXT1(final double p0, final double p1, final long p2);
    
    @Override
    public void glMatrixLoadfEXT(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMatrixLoadfEXT = this._pat._addressof_glMatrixLoadfEXT;
        if (addressof_glMatrixLoadfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadfEXT"));
        }
        this.dispatch_glMatrixLoadfEXT1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMatrixLoadfEXT);
    }
    
    private native void dispatch_glMatrixLoadfEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixLoadfEXT(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixLoadfEXT = this._pat._addressof_glMatrixLoadfEXT;
        if (addressof_glMatrixLoadfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadfEXT"));
        }
        this.dispatch_glMatrixLoadfEXT1(n, array, 4 * n2, false, addressof_glMatrixLoadfEXT);
    }
    
    @Override
    public void glMatrixLoaddEXT(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMatrixLoaddEXT = this._pat._addressof_glMatrixLoaddEXT;
        if (addressof_glMatrixLoaddEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoaddEXT"));
        }
        this.dispatch_glMatrixLoaddEXT1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMatrixLoaddEXT);
    }
    
    private native void dispatch_glMatrixLoaddEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixLoaddEXT(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixLoaddEXT = this._pat._addressof_glMatrixLoaddEXT;
        if (addressof_glMatrixLoaddEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoaddEXT"));
        }
        this.dispatch_glMatrixLoaddEXT1(n, array, 8 * n2, false, addressof_glMatrixLoaddEXT);
    }
    
    @Override
    public void glMatrixMultfEXT(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMatrixMultfEXT = this._pat._addressof_glMatrixMultfEXT;
        if (addressof_glMatrixMultfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultfEXT"));
        }
        this.dispatch_glMatrixMultfEXT1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMatrixMultfEXT);
    }
    
    private native void dispatch_glMatrixMultfEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixMultfEXT(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixMultfEXT = this._pat._addressof_glMatrixMultfEXT;
        if (addressof_glMatrixMultfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultfEXT"));
        }
        this.dispatch_glMatrixMultfEXT1(n, array, 4 * n2, false, addressof_glMatrixMultfEXT);
    }
    
    @Override
    public void glMatrixMultdEXT(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMatrixMultdEXT = this._pat._addressof_glMatrixMultdEXT;
        if (addressof_glMatrixMultdEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultdEXT"));
        }
        this.dispatch_glMatrixMultdEXT1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMatrixMultdEXT);
    }
    
    private native void dispatch_glMatrixMultdEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixMultdEXT(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixMultdEXT = this._pat._addressof_glMatrixMultdEXT;
        if (addressof_glMatrixMultdEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultdEXT"));
        }
        this.dispatch_glMatrixMultdEXT1(n, array, 8 * n2, false, addressof_glMatrixMultdEXT);
    }
    
    @Override
    public void glMatrixLoadIdentityEXT(final int n) {
        final long addressof_glMatrixLoadIdentityEXT = this._pat._addressof_glMatrixLoadIdentityEXT;
        if (addressof_glMatrixLoadIdentityEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadIdentityEXT"));
        }
        this.dispatch_glMatrixLoadIdentityEXT1(n, addressof_glMatrixLoadIdentityEXT);
    }
    
    private native void dispatch_glMatrixLoadIdentityEXT1(final int p0, final long p1);
    
    @Override
    public void glMatrixRotatefEXT(final int n, final float n2, final float n3, final float n4, final float n5) {
        final long addressof_glMatrixRotatefEXT = this._pat._addressof_glMatrixRotatefEXT;
        if (addressof_glMatrixRotatefEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixRotatefEXT"));
        }
        this.dispatch_glMatrixRotatefEXT1(n, n2, n3, n4, n5, addressof_glMatrixRotatefEXT);
    }
    
    private native void dispatch_glMatrixRotatefEXT1(final int p0, final float p1, final float p2, final float p3, final float p4, final long p5);
    
    @Override
    public void glMatrixRotatedEXT(final int n, final double n2, final double n3, final double n4, final double n5) {
        final long addressof_glMatrixRotatedEXT = this._pat._addressof_glMatrixRotatedEXT;
        if (addressof_glMatrixRotatedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixRotatedEXT"));
        }
        this.dispatch_glMatrixRotatedEXT1(n, n2, n3, n4, n5, addressof_glMatrixRotatedEXT);
    }
    
    private native void dispatch_glMatrixRotatedEXT1(final int p0, final double p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glMatrixScalefEXT(final int n, final float n2, final float n3, final float n4) {
        final long addressof_glMatrixScalefEXT = this._pat._addressof_glMatrixScalefEXT;
        if (addressof_glMatrixScalefEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixScalefEXT"));
        }
        this.dispatch_glMatrixScalefEXT1(n, n2, n3, n4, addressof_glMatrixScalefEXT);
    }
    
    private native void dispatch_glMatrixScalefEXT1(final int p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glMatrixScaledEXT(final int n, final double n2, final double n3, final double n4) {
        final long addressof_glMatrixScaledEXT = this._pat._addressof_glMatrixScaledEXT;
        if (addressof_glMatrixScaledEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixScaledEXT"));
        }
        this.dispatch_glMatrixScaledEXT1(n, n2, n3, n4, addressof_glMatrixScaledEXT);
    }
    
    private native void dispatch_glMatrixScaledEXT1(final int p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glMatrixTranslatefEXT(final int n, final float n2, final float n3, final float n4) {
        final long addressof_glMatrixTranslatefEXT = this._pat._addressof_glMatrixTranslatefEXT;
        if (addressof_glMatrixTranslatefEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixTranslatefEXT"));
        }
        this.dispatch_glMatrixTranslatefEXT1(n, n2, n3, n4, addressof_glMatrixTranslatefEXT);
    }
    
    private native void dispatch_glMatrixTranslatefEXT1(final int p0, final float p1, final float p2, final float p3, final long p4);
    
    @Override
    public void glMatrixTranslatedEXT(final int n, final double n2, final double n3, final double n4) {
        final long addressof_glMatrixTranslatedEXT = this._pat._addressof_glMatrixTranslatedEXT;
        if (addressof_glMatrixTranslatedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixTranslatedEXT"));
        }
        this.dispatch_glMatrixTranslatedEXT1(n, n2, n3, n4, addressof_glMatrixTranslatedEXT);
    }
    
    private native void dispatch_glMatrixTranslatedEXT1(final int p0, final double p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glMatrixFrustumEXT(final int n, final double n2, final double n3, final double n4, final double n5, final double n6, final double n7) {
        final long addressof_glMatrixFrustumEXT = this._pat._addressof_glMatrixFrustumEXT;
        if (addressof_glMatrixFrustumEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixFrustumEXT"));
        }
        this.dispatch_glMatrixFrustumEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glMatrixFrustumEXT);
    }
    
    private native void dispatch_glMatrixFrustumEXT1(final int p0, final double p1, final double p2, final double p3, final double p4, final double p5, final double p6, final long p7);
    
    @Override
    public void glMatrixOrthoEXT(final int n, final double n2, final double n3, final double n4, final double n5, final double n6, final double n7) {
        final long addressof_glMatrixOrthoEXT = this._pat._addressof_glMatrixOrthoEXT;
        if (addressof_glMatrixOrthoEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixOrthoEXT"));
        }
        this.dispatch_glMatrixOrthoEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glMatrixOrthoEXT);
    }
    
    private native void dispatch_glMatrixOrthoEXT1(final int p0, final double p1, final double p2, final double p3, final double p4, final double p5, final double p6, final long p7);
    
    @Override
    public void glMatrixPopEXT(final int n) {
        final long addressof_glMatrixPopEXT = this._pat._addressof_glMatrixPopEXT;
        if (addressof_glMatrixPopEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixPopEXT"));
        }
        this.dispatch_glMatrixPopEXT1(n, addressof_glMatrixPopEXT);
    }
    
    private native void dispatch_glMatrixPopEXT1(final int p0, final long p1);
    
    @Override
    public void glMatrixPushEXT(final int n) {
        final long addressof_glMatrixPushEXT = this._pat._addressof_glMatrixPushEXT;
        if (addressof_glMatrixPushEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixPushEXT"));
        }
        this.dispatch_glMatrixPushEXT1(n, addressof_glMatrixPushEXT);
    }
    
    private native void dispatch_glMatrixPushEXT1(final int p0, final long p1);
    
    @Override
    public void glClientAttribDefaultEXT(final int n) {
        final long addressof_glClientAttribDefaultEXT = this._pat._addressof_glClientAttribDefaultEXT;
        if (addressof_glClientAttribDefaultEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClientAttribDefaultEXT"));
        }
        this.dispatch_glClientAttribDefaultEXT1(n, addressof_glClientAttribDefaultEXT);
    }
    
    private native void dispatch_glClientAttribDefaultEXT1(final int p0, final long p1);
    
    @Override
    public void glPushClientAttribDefaultEXT(final int n) {
        final long addressof_glPushClientAttribDefaultEXT = this._pat._addressof_glPushClientAttribDefaultEXT;
        if (addressof_glPushClientAttribDefaultEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPushClientAttribDefaultEXT"));
        }
        this.dispatch_glPushClientAttribDefaultEXT1(n, addressof_glPushClientAttribDefaultEXT);
    }
    
    private native void dispatch_glPushClientAttribDefaultEXT1(final int p0, final long p1);
    
    @Override
    public void glTextureParameterfEXT(final int n, final int n2, final int n3, final float n4) {
        final long addressof_glTextureParameterfEXT = this._pat._addressof_glTextureParameterfEXT;
        if (addressof_glTextureParameterfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfEXT"));
        }
        this.dispatch_glTextureParameterfEXT1(n, n2, n3, n4, addressof_glTextureParameterfEXT);
    }
    
    private native void dispatch_glTextureParameterfEXT1(final int p0, final int p1, final int p2, final float p3, final long p4);
    
    @Override
    public void glTextureParameterfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glTextureParameterfvEXT = this._pat._addressof_glTextureParameterfvEXT;
        if (addressof_glTextureParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfvEXT"));
        }
        this.dispatch_glTextureParameterfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glTextureParameterfvEXT);
    }
    
    private native void dispatch_glTextureParameterfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTextureParameterfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameterfvEXT = this._pat._addressof_glTextureParameterfvEXT;
        if (addressof_glTextureParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfvEXT"));
        }
        this.dispatch_glTextureParameterfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glTextureParameterfvEXT);
    }
    
    @Override
    public void glTextureParameteriEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glTextureParameteriEXT = this._pat._addressof_glTextureParameteriEXT;
        if (addressof_glTextureParameteriEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteriEXT"));
        }
        this.dispatch_glTextureParameteriEXT1(n, n2, n3, n4, addressof_glTextureParameteriEXT);
    }
    
    private native void dispatch_glTextureParameteriEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glTextureParameterivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTextureParameterivEXT = this._pat._addressof_glTextureParameterivEXT;
        if (addressof_glTextureParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterivEXT"));
        }
        this.dispatch_glTextureParameterivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTextureParameterivEXT);
    }
    
    private native void dispatch_glTextureParameterivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTextureParameterivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameterivEXT = this._pat._addressof_glTextureParameterivEXT;
        if (addressof_glTextureParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterivEXT"));
        }
        this.dispatch_glTextureParameterivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glTextureParameterivEXT);
    }
    
    @Override
    public void glTextureImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n7, n8, n5, 1, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureImage1DEXT = this._pat._addressof_glTextureImage1DEXT;
        if (addressof_glTextureImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage1DEXT"));
        }
        this.dispatch_glTextureImage1DEXT1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureImage1DEXT);
    }
    
    private native void dispatch_glTextureImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glTextureImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final long n9) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureImage1DEXT = this._pat._addressof_glTextureImage1DEXT;
        if (addressof_glTextureImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage1DEXT"));
        }
        this.dispatch_glTextureImage1DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glTextureImage1DEXT);
    }
    
    private native void dispatch_glTextureImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8, final long p9);
    
    @Override
    public void glTextureImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n8, n9, n5, n6, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureImage2DEXT = this._pat._addressof_glTextureImage2DEXT;
        if (addressof_glTextureImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DEXT"));
        }
        this.dispatch_glTextureImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureImage2DEXT);
    }
    
    private native void dispatch_glTextureImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glTextureImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final long n10) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureImage2DEXT = this._pat._addressof_glTextureImage2DEXT;
        if (addressof_glTextureImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DEXT"));
        }
        this.dispatch_glTextureImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, addressof_glTextureImage2DEXT);
    }
    
    private native void dispatch_glTextureImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9, final long p10);
    
    @Override
    public void glTextureSubImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n6, n7, n5, 1, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureSubImage1DEXT = this._pat._addressof_glTextureSubImage1DEXT;
        if (addressof_glTextureSubImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1DEXT"));
        }
        this.dispatch_glTextureSubImage1DEXT1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureSubImage1DEXT);
    }
    
    private native void dispatch_glTextureSubImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glTextureSubImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final long n8) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureSubImage1DEXT = this._pat._addressof_glTextureSubImage1DEXT;
        if (addressof_glTextureSubImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1DEXT"));
        }
        this.dispatch_glTextureSubImage1DEXT1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glTextureSubImage1DEXT);
    }
    
    private native void dispatch_glTextureSubImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7, final long p8);
    
    @Override
    public void glTextureSubImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n8, n9, n6, n7, 1, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureSubImage2DEXT = this._pat._addressof_glTextureSubImage2DEXT;
        if (addressof_glTextureSubImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2DEXT"));
        }
        this.dispatch_glTextureSubImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureSubImage2DEXT);
    }
    
    private native void dispatch_glTextureSubImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glTextureSubImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final long n10) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureSubImage2DEXT = this._pat._addressof_glTextureSubImage2DEXT;
        if (addressof_glTextureSubImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2DEXT"));
        }
        this.dispatch_glTextureSubImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, addressof_glTextureSubImage2DEXT);
    }
    
    private native void dispatch_glTextureSubImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9, final long p10);
    
    @Override
    public void glCopyTextureImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glCopyTextureImage1DEXT = this._pat._addressof_glCopyTextureImage1DEXT;
        if (addressof_glCopyTextureImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureImage1DEXT"));
        }
        this.dispatch_glCopyTextureImage1DEXT1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glCopyTextureImage1DEXT);
    }
    
    private native void dispatch_glCopyTextureImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glCopyTextureImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9) {
        final long addressof_glCopyTextureImage2DEXT = this._pat._addressof_glCopyTextureImage2DEXT;
        if (addressof_glCopyTextureImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureImage2DEXT"));
        }
        this.dispatch_glCopyTextureImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCopyTextureImage2DEXT);
    }
    
    private native void dispatch_glCopyTextureImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glCopyTextureSubImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7) {
        final long addressof_glCopyTextureSubImage1DEXT = this._pat._addressof_glCopyTextureSubImage1DEXT;
        if (addressof_glCopyTextureSubImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage1DEXT"));
        }
        this.dispatch_glCopyTextureSubImage1DEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glCopyTextureSubImage1DEXT);
    }
    
    private native void dispatch_glCopyTextureSubImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glCopyTextureSubImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9) {
        final long addressof_glCopyTextureSubImage2DEXT = this._pat._addressof_glCopyTextureSubImage2DEXT;
        if (addressof_glCopyTextureSubImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage2DEXT"));
        }
        this.dispatch_glCopyTextureSubImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCopyTextureSubImage2DEXT);
    }
    
    private native void dispatch_glCopyTextureSubImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glGetTextureImageEXT(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetTextureImageEXT = this._pat._addressof_glGetTextureImageEXT;
        if (addressof_glGetTextureImageEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureImageEXT"));
        }
        this.dispatch_glGetTextureImageEXT1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetTextureImageEXT);
    }
    
    private native void dispatch_glGetTextureImageEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetTextureParameterfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTextureParameterfvEXT = this._pat._addressof_glGetTextureParameterfvEXT;
        if (addressof_glGetTextureParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfvEXT"));
        }
        this.dispatch_glGetTextureParameterfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTextureParameterfvEXT);
    }
    
    private native void dispatch_glGetTextureParameterfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTextureParameterfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameterfvEXT = this._pat._addressof_glGetTextureParameterfvEXT;
        if (addressof_glGetTextureParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfvEXT"));
        }
        this.dispatch_glGetTextureParameterfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetTextureParameterfvEXT);
    }
    
    @Override
    public void glGetTextureParameterivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureParameterivEXT = this._pat._addressof_glGetTextureParameterivEXT;
        if (addressof_glGetTextureParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterivEXT"));
        }
        this.dispatch_glGetTextureParameterivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureParameterivEXT);
    }
    
    private native void dispatch_glGetTextureParameterivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTextureParameterivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameterivEXT = this._pat._addressof_glGetTextureParameterivEXT;
        if (addressof_glGetTextureParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterivEXT"));
        }
        this.dispatch_glGetTextureParameterivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetTextureParameterivEXT);
    }
    
    @Override
    public void glGetTextureLevelParameterfvEXT(final int n, final int n2, final int n3, final int n4, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetTextureLevelParameterfvEXT = this._pat._addressof_glGetTextureLevelParameterfvEXT;
        if (addressof_glGetTextureLevelParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfvEXT"));
        }
        this.dispatch_glGetTextureLevelParameterfvEXT1(n, n2, n3, n4, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetTextureLevelParameterfvEXT);
    }
    
    private native void dispatch_glGetTextureLevelParameterfvEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetTextureLevelParameterfvEXT(final int n, final int n2, final int n3, final int n4, final float[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureLevelParameterfvEXT = this._pat._addressof_glGetTextureLevelParameterfvEXT;
        if (addressof_glGetTextureLevelParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfvEXT"));
        }
        this.dispatch_glGetTextureLevelParameterfvEXT1(n, n2, n3, n4, array, 4 * n5, false, addressof_glGetTextureLevelParameterfvEXT);
    }
    
    @Override
    public void glGetTextureLevelParameterivEXT(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureLevelParameterivEXT = this._pat._addressof_glGetTextureLevelParameterivEXT;
        if (addressof_glGetTextureLevelParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterivEXT"));
        }
        this.dispatch_glGetTextureLevelParameterivEXT1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureLevelParameterivEXT);
    }
    
    private native void dispatch_glGetTextureLevelParameterivEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetTextureLevelParameterivEXT(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureLevelParameterivEXT = this._pat._addressof_glGetTextureLevelParameterivEXT;
        if (addressof_glGetTextureLevelParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterivEXT"));
        }
        this.dispatch_glGetTextureLevelParameterivEXT1(n, n2, n3, n4, array, 4 * n5, false, addressof_glGetTextureLevelParameterivEXT);
    }
    
    @Override
    public void glTextureImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n9, n10, n5, n6, n7, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureImage3DEXT = this._pat._addressof_glTextureImage3DEXT;
        if (addressof_glTextureImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DEXT"));
        }
        this.dispatch_glTextureImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureImage3DEXT);
    }
    
    private native void dispatch_glTextureImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glTextureImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final long n11) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureImage3DEXT = this._pat._addressof_glTextureImage3DEXT;
        if (addressof_glTextureImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DEXT"));
        }
        this.dispatch_glTextureImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, addressof_glTextureImage3DEXT);
    }
    
    private native void dispatch_glTextureImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final long p10, final long p11);
    
    @Override
    public void glTextureSubImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final Buffer buffer) {
        this.checkUnpackPBOUnbound(true);
        Buffers.rangeCheckBytes(buffer, this.imageSizeInBytes(n10, n11, n7, n8, n9, false));
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glTextureSubImage3DEXT = this._pat._addressof_glTextureSubImage3DEXT;
        if (addressof_glTextureSubImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3DEXT"));
        }
        this.dispatch_glTextureSubImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glTextureSubImage3DEXT);
    }
    
    private native void dispatch_glTextureSubImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final Object p11, final int p12, final boolean p13, final long p14);
    
    @Override
    public void glTextureSubImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final long n12) {
        this.checkUnpackPBOBound(true);
        final long addressof_glTextureSubImage3DEXT = this._pat._addressof_glTextureSubImage3DEXT;
        if (addressof_glTextureSubImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3DEXT"));
        }
        this.dispatch_glTextureSubImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, addressof_glTextureSubImage3DEXT);
    }
    
    private native void dispatch_glTextureSubImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final long p11, final long p12);
    
    @Override
    public void glCopyTextureSubImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10) {
        final long addressof_glCopyTextureSubImage3DEXT = this._pat._addressof_glCopyTextureSubImage3DEXT;
        if (addressof_glCopyTextureSubImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage3DEXT"));
        }
        this.dispatch_glCopyTextureSubImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, addressof_glCopyTextureSubImage3DEXT);
    }
    
    private native void dispatch_glCopyTextureSubImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final long p10);
    
    @Override
    public void glBindMultiTextureEXT(final int n, final int n2, final int n3) {
        final long addressof_glBindMultiTextureEXT = this._pat._addressof_glBindMultiTextureEXT;
        if (addressof_glBindMultiTextureEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindMultiTextureEXT"));
        }
        this.dispatch_glBindMultiTextureEXT1(n, n2, n3, addressof_glBindMultiTextureEXT);
    }
    
    private native void dispatch_glBindMultiTextureEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiTexCoordPointerEXT(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glMultiTexCoordPointerEXT = this._pat._addressof_glMultiTexCoordPointerEXT;
        if (addressof_glMultiTexCoordPointerEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordPointerEXT"));
        }
        this.dispatch_glMultiTexCoordPointerEXT0(n, n2, n3, n4, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glMultiTexCoordPointerEXT);
    }
    
    private native void dispatch_glMultiTexCoordPointerEXT0(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final long p6);
    
    @Override
    public void glMultiTexEnvfEXT(final int n, final int n2, final int n3, final float n4) {
        final long addressof_glMultiTexEnvfEXT = this._pat._addressof_glMultiTexEnvfEXT;
        if (addressof_glMultiTexEnvfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvfEXT"));
        }
        this.dispatch_glMultiTexEnvfEXT1(n, n2, n3, n4, addressof_glMultiTexEnvfEXT);
    }
    
    private native void dispatch_glMultiTexEnvfEXT1(final int p0, final int p1, final int p2, final float p3, final long p4);
    
    @Override
    public void glMultiTexEnvfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultiTexEnvfvEXT = this._pat._addressof_glMultiTexEnvfvEXT;
        if (addressof_glMultiTexEnvfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvfvEXT"));
        }
        this.dispatch_glMultiTexEnvfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultiTexEnvfvEXT);
    }
    
    private native void dispatch_glMultiTexEnvfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexEnvfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexEnvfvEXT = this._pat._addressof_glMultiTexEnvfvEXT;
        if (addressof_glMultiTexEnvfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvfvEXT"));
        }
        this.dispatch_glMultiTexEnvfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexEnvfvEXT);
    }
    
    @Override
    public void glMultiTexEnviEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glMultiTexEnviEXT = this._pat._addressof_glMultiTexEnviEXT;
        if (addressof_glMultiTexEnviEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnviEXT"));
        }
        this.dispatch_glMultiTexEnviEXT1(n, n2, n3, n4, addressof_glMultiTexEnviEXT);
    }
    
    private native void dispatch_glMultiTexEnviEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glMultiTexEnvivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexEnvivEXT = this._pat._addressof_glMultiTexEnvivEXT;
        if (addressof_glMultiTexEnvivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvivEXT"));
        }
        this.dispatch_glMultiTexEnvivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexEnvivEXT);
    }
    
    private native void dispatch_glMultiTexEnvivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexEnvivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexEnvivEXT = this._pat._addressof_glMultiTexEnvivEXT;
        if (addressof_glMultiTexEnvivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvivEXT"));
        }
        this.dispatch_glMultiTexEnvivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexEnvivEXT);
    }
    
    @Override
    public void glMultiTexGendEXT(final int n, final int n2, final int n3, final double n4) {
        final long addressof_glMultiTexGendEXT = this._pat._addressof_glMultiTexGendEXT;
        if (addressof_glMultiTexGendEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGendEXT"));
        }
        this.dispatch_glMultiTexGendEXT1(n, n2, n3, n4, addressof_glMultiTexGendEXT);
    }
    
    private native void dispatch_glMultiTexGendEXT1(final int p0, final int p1, final int p2, final double p3, final long p4);
    
    @Override
    public void glMultiTexGendvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMultiTexGendvEXT = this._pat._addressof_glMultiTexGendvEXT;
        if (addressof_glMultiTexGendvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGendvEXT"));
        }
        this.dispatch_glMultiTexGendvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMultiTexGendvEXT);
    }
    
    private native void dispatch_glMultiTexGendvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexGendvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexGendvEXT = this._pat._addressof_glMultiTexGendvEXT;
        if (addressof_glMultiTexGendvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGendvEXT"));
        }
        this.dispatch_glMultiTexGendvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glMultiTexGendvEXT);
    }
    
    @Override
    public void glMultiTexGenfEXT(final int n, final int n2, final int n3, final float n4) {
        final long addressof_glMultiTexGenfEXT = this._pat._addressof_glMultiTexGenfEXT;
        if (addressof_glMultiTexGenfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenfEXT"));
        }
        this.dispatch_glMultiTexGenfEXT1(n, n2, n3, n4, addressof_glMultiTexGenfEXT);
    }
    
    private native void dispatch_glMultiTexGenfEXT1(final int p0, final int p1, final int p2, final float p3, final long p4);
    
    @Override
    public void glMultiTexGenfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultiTexGenfvEXT = this._pat._addressof_glMultiTexGenfvEXT;
        if (addressof_glMultiTexGenfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenfvEXT"));
        }
        this.dispatch_glMultiTexGenfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultiTexGenfvEXT);
    }
    
    private native void dispatch_glMultiTexGenfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexGenfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexGenfvEXT = this._pat._addressof_glMultiTexGenfvEXT;
        if (addressof_glMultiTexGenfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenfvEXT"));
        }
        this.dispatch_glMultiTexGenfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexGenfvEXT);
    }
    
    @Override
    public void glMultiTexGeniEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glMultiTexGeniEXT = this._pat._addressof_glMultiTexGeniEXT;
        if (addressof_glMultiTexGeniEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGeniEXT"));
        }
        this.dispatch_glMultiTexGeniEXT1(n, n2, n3, n4, addressof_glMultiTexGeniEXT);
    }
    
    private native void dispatch_glMultiTexGeniEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glMultiTexGenivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexGenivEXT = this._pat._addressof_glMultiTexGenivEXT;
        if (addressof_glMultiTexGenivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenivEXT"));
        }
        this.dispatch_glMultiTexGenivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexGenivEXT);
    }
    
    private native void dispatch_glMultiTexGenivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexGenivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexGenivEXT = this._pat._addressof_glMultiTexGenivEXT;
        if (addressof_glMultiTexGenivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenivEXT"));
        }
        this.dispatch_glMultiTexGenivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexGenivEXT);
    }
    
    @Override
    public void glGetMultiTexEnvfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMultiTexEnvfvEXT = this._pat._addressof_glGetMultiTexEnvfvEXT;
        if (addressof_glGetMultiTexEnvfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvfvEXT"));
        }
        this.dispatch_glGetMultiTexEnvfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMultiTexEnvfvEXT);
    }
    
    private native void dispatch_glGetMultiTexEnvfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexEnvfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexEnvfvEXT = this._pat._addressof_glGetMultiTexEnvfvEXT;
        if (addressof_glGetMultiTexEnvfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvfvEXT"));
        }
        this.dispatch_glGetMultiTexEnvfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexEnvfvEXT);
    }
    
    @Override
    public void glGetMultiTexEnvivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMultiTexEnvivEXT = this._pat._addressof_glGetMultiTexEnvivEXT;
        if (addressof_glGetMultiTexEnvivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvivEXT"));
        }
        this.dispatch_glGetMultiTexEnvivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMultiTexEnvivEXT);
    }
    
    private native void dispatch_glGetMultiTexEnvivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexEnvivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexEnvivEXT = this._pat._addressof_glGetMultiTexEnvivEXT;
        if (addressof_glGetMultiTexEnvivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvivEXT"));
        }
        this.dispatch_glGetMultiTexEnvivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexEnvivEXT);
    }
    
    @Override
    public void glGetMultiTexGendvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetMultiTexGendvEXT = this._pat._addressof_glGetMultiTexGendvEXT;
        if (addressof_glGetMultiTexGendvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGendvEXT"));
        }
        this.dispatch_glGetMultiTexGendvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetMultiTexGendvEXT);
    }
    
    private native void dispatch_glGetMultiTexGendvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexGendvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexGendvEXT = this._pat._addressof_glGetMultiTexGendvEXT;
        if (addressof_glGetMultiTexGendvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGendvEXT"));
        }
        this.dispatch_glGetMultiTexGendvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glGetMultiTexGendvEXT);
    }
    
    @Override
    public void glGetMultiTexGenfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMultiTexGenfvEXT = this._pat._addressof_glGetMultiTexGenfvEXT;
        if (addressof_glGetMultiTexGenfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenfvEXT"));
        }
        this.dispatch_glGetMultiTexGenfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMultiTexGenfvEXT);
    }
    
    private native void dispatch_glGetMultiTexGenfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexGenfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexGenfvEXT = this._pat._addressof_glGetMultiTexGenfvEXT;
        if (addressof_glGetMultiTexGenfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenfvEXT"));
        }
        this.dispatch_glGetMultiTexGenfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexGenfvEXT);
    }
    
    @Override
    public void glGetMultiTexGenivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMultiTexGenivEXT = this._pat._addressof_glGetMultiTexGenivEXT;
        if (addressof_glGetMultiTexGenivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenivEXT"));
        }
        this.dispatch_glGetMultiTexGenivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMultiTexGenivEXT);
    }
    
    private native void dispatch_glGetMultiTexGenivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexGenivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexGenivEXT = this._pat._addressof_glGetMultiTexGenivEXT;
        if (addressof_glGetMultiTexGenivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenivEXT"));
        }
        this.dispatch_glGetMultiTexGenivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexGenivEXT);
    }
    
    @Override
    public void glMultiTexParameteriEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glMultiTexParameteriEXT = this._pat._addressof_glMultiTexParameteriEXT;
        if (addressof_glMultiTexParameteriEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameteriEXT"));
        }
        this.dispatch_glMultiTexParameteriEXT1(n, n2, n3, n4, addressof_glMultiTexParameteriEXT);
    }
    
    private native void dispatch_glMultiTexParameteriEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glMultiTexParameterivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexParameterivEXT = this._pat._addressof_glMultiTexParameterivEXT;
        if (addressof_glMultiTexParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterivEXT"));
        }
        this.dispatch_glMultiTexParameterivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexParameterivEXT);
    }
    
    private native void dispatch_glMultiTexParameterivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexParameterivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexParameterivEXT = this._pat._addressof_glMultiTexParameterivEXT;
        if (addressof_glMultiTexParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterivEXT"));
        }
        this.dispatch_glMultiTexParameterivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexParameterivEXT);
    }
    
    @Override
    public void glMultiTexParameterfEXT(final int n, final int n2, final int n3, final float n4) {
        final long addressof_glMultiTexParameterfEXT = this._pat._addressof_glMultiTexParameterfEXT;
        if (addressof_glMultiTexParameterfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterfEXT"));
        }
        this.dispatch_glMultiTexParameterfEXT1(n, n2, n3, n4, addressof_glMultiTexParameterfEXT);
    }
    
    private native void dispatch_glMultiTexParameterfEXT1(final int p0, final int p1, final int p2, final float p3, final long p4);
    
    @Override
    public void glMultiTexParameterfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMultiTexParameterfvEXT = this._pat._addressof_glMultiTexParameterfvEXT;
        if (addressof_glMultiTexParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterfvEXT"));
        }
        this.dispatch_glMultiTexParameterfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMultiTexParameterfvEXT);
    }
    
    private native void dispatch_glMultiTexParameterfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexParameterfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexParameterfvEXT = this._pat._addressof_glMultiTexParameterfvEXT;
        if (addressof_glMultiTexParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterfvEXT"));
        }
        this.dispatch_glMultiTexParameterfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexParameterfvEXT);
    }
    
    @Override
    public void glMultiTexImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiTexImage1DEXT = this._pat._addressof_glMultiTexImage1DEXT;
        if (addressof_glMultiTexImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexImage1DEXT"));
        }
        this.dispatch_glMultiTexImage1DEXT1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glMultiTexImage1DEXT);
    }
    
    private native void dispatch_glMultiTexImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glMultiTexImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiTexImage2DEXT = this._pat._addressof_glMultiTexImage2DEXT;
        if (addressof_glMultiTexImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexImage2DEXT"));
        }
        this.dispatch_glMultiTexImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glMultiTexImage2DEXT);
    }
    
    private native void dispatch_glMultiTexImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glMultiTexSubImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiTexSubImage1DEXT = this._pat._addressof_glMultiTexSubImage1DEXT;
        if (addressof_glMultiTexSubImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexSubImage1DEXT"));
        }
        this.dispatch_glMultiTexSubImage1DEXT1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glMultiTexSubImage1DEXT);
    }
    
    private native void dispatch_glMultiTexSubImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glMultiTexSubImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiTexSubImage2DEXT = this._pat._addressof_glMultiTexSubImage2DEXT;
        if (addressof_glMultiTexSubImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexSubImage2DEXT"));
        }
        this.dispatch_glMultiTexSubImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glMultiTexSubImage2DEXT);
    }
    
    private native void dispatch_glMultiTexSubImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glCopyMultiTexImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {
        final long addressof_glCopyMultiTexImage1DEXT = this._pat._addressof_glCopyMultiTexImage1DEXT;
        if (addressof_glCopyMultiTexImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexImage1DEXT"));
        }
        this.dispatch_glCopyMultiTexImage1DEXT1(n, n2, n3, n4, n5, n6, n7, n8, addressof_glCopyMultiTexImage1DEXT);
    }
    
    private native void dispatch_glCopyMultiTexImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glCopyMultiTexImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9) {
        final long addressof_glCopyMultiTexImage2DEXT = this._pat._addressof_glCopyMultiTexImage2DEXT;
        if (addressof_glCopyMultiTexImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexImage2DEXT"));
        }
        this.dispatch_glCopyMultiTexImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCopyMultiTexImage2DEXT);
    }
    
    private native void dispatch_glCopyMultiTexImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glCopyMultiTexSubImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7) {
        final long addressof_glCopyMultiTexSubImage1DEXT = this._pat._addressof_glCopyMultiTexSubImage1DEXT;
        if (addressof_glCopyMultiTexSubImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexSubImage1DEXT"));
        }
        this.dispatch_glCopyMultiTexSubImage1DEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glCopyMultiTexSubImage1DEXT);
    }
    
    private native void dispatch_glCopyMultiTexSubImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glCopyMultiTexSubImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9) {
        final long addressof_glCopyMultiTexSubImage2DEXT = this._pat._addressof_glCopyMultiTexSubImage2DEXT;
        if (addressof_glCopyMultiTexSubImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexSubImage2DEXT"));
        }
        this.dispatch_glCopyMultiTexSubImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, addressof_glCopyMultiTexSubImage2DEXT);
    }
    
    private native void dispatch_glCopyMultiTexSubImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glGetMultiTexImageEXT(final int n, final int n2, final int n3, final int n4, final int n5, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetMultiTexImageEXT = this._pat._addressof_glGetMultiTexImageEXT;
        if (addressof_glGetMultiTexImageEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexImageEXT"));
        }
        this.dispatch_glGetMultiTexImageEXT1(n, n2, n3, n4, n5, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetMultiTexImageEXT);
    }
    
    private native void dispatch_glGetMultiTexImageEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glGetMultiTexParameterfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMultiTexParameterfvEXT = this._pat._addressof_glGetMultiTexParameterfvEXT;
        if (addressof_glGetMultiTexParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterfvEXT"));
        }
        this.dispatch_glGetMultiTexParameterfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMultiTexParameterfvEXT);
    }
    
    private native void dispatch_glGetMultiTexParameterfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexParameterfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexParameterfvEXT = this._pat._addressof_glGetMultiTexParameterfvEXT;
        if (addressof_glGetMultiTexParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterfvEXT"));
        }
        this.dispatch_glGetMultiTexParameterfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexParameterfvEXT);
    }
    
    @Override
    public void glGetMultiTexParameterivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMultiTexParameterivEXT = this._pat._addressof_glGetMultiTexParameterivEXT;
        if (addressof_glGetMultiTexParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterivEXT"));
        }
        this.dispatch_glGetMultiTexParameterivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMultiTexParameterivEXT);
    }
    
    private native void dispatch_glGetMultiTexParameterivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexParameterivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexParameterivEXT = this._pat._addressof_glGetMultiTexParameterivEXT;
        if (addressof_glGetMultiTexParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterivEXT"));
        }
        this.dispatch_glGetMultiTexParameterivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexParameterivEXT);
    }
    
    @Override
    public void glGetMultiTexLevelParameterfvEXT(final int n, final int n2, final int n3, final int n4, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMultiTexLevelParameterfvEXT = this._pat._addressof_glGetMultiTexLevelParameterfvEXT;
        if (addressof_glGetMultiTexLevelParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterfvEXT"));
        }
        this.dispatch_glGetMultiTexLevelParameterfvEXT1(n, n2, n3, n4, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMultiTexLevelParameterfvEXT);
    }
    
    private native void dispatch_glGetMultiTexLevelParameterfvEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetMultiTexLevelParameterfvEXT(final int n, final int n2, final int n3, final int n4, final float[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexLevelParameterfvEXT = this._pat._addressof_glGetMultiTexLevelParameterfvEXT;
        if (addressof_glGetMultiTexLevelParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterfvEXT"));
        }
        this.dispatch_glGetMultiTexLevelParameterfvEXT1(n, n2, n3, n4, array, 4 * n5, false, addressof_glGetMultiTexLevelParameterfvEXT);
    }
    
    @Override
    public void glGetMultiTexLevelParameterivEXT(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMultiTexLevelParameterivEXT = this._pat._addressof_glGetMultiTexLevelParameterivEXT;
        if (addressof_glGetMultiTexLevelParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterivEXT"));
        }
        this.dispatch_glGetMultiTexLevelParameterivEXT1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMultiTexLevelParameterivEXT);
    }
    
    private native void dispatch_glGetMultiTexLevelParameterivEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetMultiTexLevelParameterivEXT(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexLevelParameterivEXT = this._pat._addressof_glGetMultiTexLevelParameterivEXT;
        if (addressof_glGetMultiTexLevelParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterivEXT"));
        }
        this.dispatch_glGetMultiTexLevelParameterivEXT1(n, n2, n3, n4, array, 4 * n5, false, addressof_glGetMultiTexLevelParameterivEXT);
    }
    
    @Override
    public void glMultiTexImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiTexImage3DEXT = this._pat._addressof_glMultiTexImage3DEXT;
        if (addressof_glMultiTexImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexImage3DEXT"));
        }
        this.dispatch_glMultiTexImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glMultiTexImage3DEXT);
    }
    
    private native void dispatch_glMultiTexImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final Object p10, final int p11, final boolean p12, final long p13);
    
    @Override
    public void glMultiTexSubImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiTexSubImage3DEXT = this._pat._addressof_glMultiTexSubImage3DEXT;
        if (addressof_glMultiTexSubImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexSubImage3DEXT"));
        }
        this.dispatch_glMultiTexSubImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glMultiTexSubImage3DEXT);
    }
    
    private native void dispatch_glMultiTexSubImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final Object p11, final int p12, final boolean p13, final long p14);
    
    @Override
    public void glCopyMultiTexSubImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10) {
        final long addressof_glCopyMultiTexSubImage3DEXT = this._pat._addressof_glCopyMultiTexSubImage3DEXT;
        if (addressof_glCopyMultiTexSubImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexSubImage3DEXT"));
        }
        this.dispatch_glCopyMultiTexSubImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, addressof_glCopyMultiTexSubImage3DEXT);
    }
    
    private native void dispatch_glCopyMultiTexSubImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final long p10);
    
    @Override
    public void glEnableClientStateIndexedEXT(final int n, final int n2) {
        final long addressof_glEnableClientStateIndexedEXT = this._pat._addressof_glEnableClientStateIndexedEXT;
        if (addressof_glEnableClientStateIndexedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableClientStateIndexedEXT"));
        }
        this.dispatch_glEnableClientStateIndexedEXT1(n, n2, addressof_glEnableClientStateIndexedEXT);
    }
    
    private native void dispatch_glEnableClientStateIndexedEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisableClientStateIndexedEXT(final int n, final int n2) {
        final long addressof_glDisableClientStateIndexedEXT = this._pat._addressof_glDisableClientStateIndexedEXT;
        if (addressof_glDisableClientStateIndexedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableClientStateIndexedEXT"));
        }
        this.dispatch_glDisableClientStateIndexedEXT1(n, n2, addressof_glDisableClientStateIndexedEXT);
    }
    
    private native void dispatch_glDisableClientStateIndexedEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetFloatIndexedvEXT(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetFloatIndexedvEXT = this._pat._addressof_glGetFloatIndexedvEXT;
        if (addressof_glGetFloatIndexedvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloatIndexedvEXT"));
        }
        this.dispatch_glGetFloatIndexedvEXT1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetFloatIndexedvEXT);
    }
    
    private native void dispatch_glGetFloatIndexedvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetFloatIndexedvEXT(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFloatIndexedvEXT = this._pat._addressof_glGetFloatIndexedvEXT;
        if (addressof_glGetFloatIndexedvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloatIndexedvEXT"));
        }
        this.dispatch_glGetFloatIndexedvEXT1(n, n2, array, 4 * n3, false, addressof_glGetFloatIndexedvEXT);
    }
    
    @Override
    public void glGetDoubleIndexedvEXT(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetDoubleIndexedvEXT = this._pat._addressof_glGetDoubleIndexedvEXT;
        if (addressof_glGetDoubleIndexedvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoubleIndexedvEXT"));
        }
        this.dispatch_glGetDoubleIndexedvEXT1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetDoubleIndexedvEXT);
    }
    
    private native void dispatch_glGetDoubleIndexedvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetDoubleIndexedvEXT(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetDoubleIndexedvEXT = this._pat._addressof_glGetDoubleIndexedvEXT;
        if (addressof_glGetDoubleIndexedvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoubleIndexedvEXT"));
        }
        this.dispatch_glGetDoubleIndexedvEXT1(n, n2, array, 8 * n3, false, addressof_glGetDoubleIndexedvEXT);
    }
    
    @Override
    public void glEnableIndexed(final int n, final int n2) {
        final long addressof_glEnableIndexed = this._pat._addressof_glEnableIndexed;
        if (addressof_glEnableIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableIndexed"));
        }
        this.dispatch_glEnableIndexed1(n, n2, addressof_glEnableIndexed);
    }
    
    private native void dispatch_glEnableIndexed1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisableIndexed(final int n, final int n2) {
        final long addressof_glDisableIndexed = this._pat._addressof_glDisableIndexed;
        if (addressof_glDisableIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableIndexed"));
        }
        this.dispatch_glDisableIndexed1(n, n2, addressof_glDisableIndexed);
    }
    
    private native void dispatch_glDisableIndexed1(final int p0, final int p1, final long p2);
    
    @Override
    public boolean glIsEnabledIndexed(final int n, final int n2) {
        final long addressof_glIsEnabledIndexed = this._pat._addressof_glIsEnabledIndexed;
        if (addressof_glIsEnabledIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsEnabledIndexed"));
        }
        return this.dispatch_glIsEnabledIndexed1(n, n2, addressof_glIsEnabledIndexed);
    }
    
    private native boolean dispatch_glIsEnabledIndexed1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetIntegerIndexedv(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetIntegerIndexedv = this._pat._addressof_glGetIntegerIndexedv;
        if (addressof_glGetIntegerIndexedv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerIndexedv"));
        }
        this.dispatch_glGetIntegerIndexedv1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetIntegerIndexedv);
    }
    
    private native void dispatch_glGetIntegerIndexedv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetIntegerIndexedv(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetIntegerIndexedv = this._pat._addressof_glGetIntegerIndexedv;
        if (addressof_glGetIntegerIndexedv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerIndexedv"));
        }
        this.dispatch_glGetIntegerIndexedv1(n, n2, array, 4 * n3, false, addressof_glGetIntegerIndexedv);
    }
    
    @Override
    public void glGetBooleanIndexedv(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetBooleanIndexedv = this._pat._addressof_glGetBooleanIndexedv;
        if (addressof_glGetBooleanIndexedv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanIndexedv"));
        }
        this.dispatch_glGetBooleanIndexedv1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetBooleanIndexedv);
    }
    
    private native void dispatch_glGetBooleanIndexedv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetBooleanIndexedv(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetBooleanIndexedv = this._pat._addressof_glGetBooleanIndexedv;
        if (addressof_glGetBooleanIndexedv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanIndexedv"));
        }
        this.dispatch_glGetBooleanIndexedv1(n, n2, array, n3, false, addressof_glGetBooleanIndexedv);
    }
    
    @Override
    public void glCompressedTextureImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureImage3DEXT = this._pat._addressof_glCompressedTextureImage3DEXT;
        if (addressof_glCompressedTextureImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureImage3DEXT"));
        }
        this.dispatch_glCompressedTextureImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureImage3DEXT);
    }
    
    private native void dispatch_glCompressedTextureImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glCompressedTextureImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureImage2DEXT = this._pat._addressof_glCompressedTextureImage2DEXT;
        if (addressof_glCompressedTextureImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureImage2DEXT"));
        }
        this.dispatch_glCompressedTextureImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureImage2DEXT);
    }
    
    private native void dispatch_glCompressedTextureImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glCompressedTextureImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureImage1DEXT = this._pat._addressof_glCompressedTextureImage1DEXT;
        if (addressof_glCompressedTextureImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureImage1DEXT"));
        }
        this.dispatch_glCompressedTextureImage1DEXT1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureImage1DEXT);
    }
    
    private native void dispatch_glCompressedTextureImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glCompressedTextureSubImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureSubImage3DEXT = this._pat._addressof_glCompressedTextureSubImage3DEXT;
        if (addressof_glCompressedTextureSubImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage3DEXT"));
        }
        this.dispatch_glCompressedTextureSubImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureSubImage3DEXT);
    }
    
    private native void dispatch_glCompressedTextureSubImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final Object p11, final int p12, final boolean p13, final long p14);
    
    @Override
    public void glCompressedTextureSubImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureSubImage2DEXT = this._pat._addressof_glCompressedTextureSubImage2DEXT;
        if (addressof_glCompressedTextureSubImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage2DEXT"));
        }
        this.dispatch_glCompressedTextureSubImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureSubImage2DEXT);
    }
    
    private native void dispatch_glCompressedTextureSubImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glCompressedTextureSubImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedTextureSubImage1DEXT = this._pat._addressof_glCompressedTextureSubImage1DEXT;
        if (addressof_glCompressedTextureSubImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage1DEXT"));
        }
        this.dispatch_glCompressedTextureSubImage1DEXT1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedTextureSubImage1DEXT);
    }
    
    private native void dispatch_glCompressedTextureSubImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glGetCompressedTextureImageEXT(final int n, final int n2, final int n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetCompressedTextureImageEXT = this._pat._addressof_glGetCompressedTextureImageEXT;
        if (addressof_glGetCompressedTextureImageEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTextureImageEXT"));
        }
        this.dispatch_glGetCompressedTextureImageEXT1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetCompressedTextureImageEXT);
    }
    
    private native void dispatch_glGetCompressedTextureImageEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glCompressedMultiTexImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedMultiTexImage3DEXT = this._pat._addressof_glCompressedMultiTexImage3DEXT;
        if (addressof_glCompressedMultiTexImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexImage3DEXT"));
        }
        this.dispatch_glCompressedMultiTexImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedMultiTexImage3DEXT);
    }
    
    private native void dispatch_glCompressedMultiTexImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glCompressedMultiTexImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedMultiTexImage2DEXT = this._pat._addressof_glCompressedMultiTexImage2DEXT;
        if (addressof_glCompressedMultiTexImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexImage2DEXT"));
        }
        this.dispatch_glCompressedMultiTexImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedMultiTexImage2DEXT);
    }
    
    private native void dispatch_glCompressedMultiTexImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glCompressedMultiTexImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedMultiTexImage1DEXT = this._pat._addressof_glCompressedMultiTexImage1DEXT;
        if (addressof_glCompressedMultiTexImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexImage1DEXT"));
        }
        this.dispatch_glCompressedMultiTexImage1DEXT1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedMultiTexImage1DEXT);
    }
    
    private native void dispatch_glCompressedMultiTexImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glCompressedMultiTexSubImage3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedMultiTexSubImage3DEXT = this._pat._addressof_glCompressedMultiTexSubImage3DEXT;
        if (addressof_glCompressedMultiTexSubImage3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexSubImage3DEXT"));
        }
        this.dispatch_glCompressedMultiTexSubImage3DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedMultiTexSubImage3DEXT);
    }
    
    private native void dispatch_glCompressedMultiTexSubImage3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final Object p11, final int p12, final boolean p13, final long p14);
    
    @Override
    public void glCompressedMultiTexSubImage2DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedMultiTexSubImage2DEXT = this._pat._addressof_glCompressedMultiTexSubImage2DEXT;
        if (addressof_glCompressedMultiTexSubImage2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexSubImage2DEXT"));
        }
        this.dispatch_glCompressedMultiTexSubImage2DEXT1(n, n2, n3, n4, n5, n6, n7, n8, n9, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedMultiTexSubImage2DEXT);
    }
    
    private native void dispatch_glCompressedMultiTexSubImage2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final Object p9, final int p10, final boolean p11, final long p12);
    
    @Override
    public void glCompressedMultiTexSubImage1DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glCompressedMultiTexSubImage1DEXT = this._pat._addressof_glCompressedMultiTexSubImage1DEXT;
        if (addressof_glCompressedMultiTexSubImage1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexSubImage1DEXT"));
        }
        this.dispatch_glCompressedMultiTexSubImage1DEXT1(n, n2, n3, n4, n5, n6, n7, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glCompressedMultiTexSubImage1DEXT);
    }
    
    private native void dispatch_glCompressedMultiTexSubImage1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final Object p7, final int p8, final boolean p9, final long p10);
    
    @Override
    public void glGetCompressedMultiTexImageEXT(final int n, final int n2, final int n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetCompressedMultiTexImageEXT = this._pat._addressof_glGetCompressedMultiTexImageEXT;
        if (addressof_glGetCompressedMultiTexImageEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedMultiTexImageEXT"));
        }
        this.dispatch_glGetCompressedMultiTexImageEXT1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetCompressedMultiTexImageEXT);
    }
    
    private native void dispatch_glGetCompressedMultiTexImageEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMatrixLoadTransposefEXT(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMatrixLoadTransposefEXT = this._pat._addressof_glMatrixLoadTransposefEXT;
        if (addressof_glMatrixLoadTransposefEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposefEXT"));
        }
        this.dispatch_glMatrixLoadTransposefEXT1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMatrixLoadTransposefEXT);
    }
    
    private native void dispatch_glMatrixLoadTransposefEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixLoadTransposefEXT(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixLoadTransposefEXT = this._pat._addressof_glMatrixLoadTransposefEXT;
        if (addressof_glMatrixLoadTransposefEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposefEXT"));
        }
        this.dispatch_glMatrixLoadTransposefEXT1(n, array, 4 * n2, false, addressof_glMatrixLoadTransposefEXT);
    }
    
    @Override
    public void glMatrixLoadTransposedEXT(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMatrixLoadTransposedEXT = this._pat._addressof_glMatrixLoadTransposedEXT;
        if (addressof_glMatrixLoadTransposedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposedEXT"));
        }
        this.dispatch_glMatrixLoadTransposedEXT1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMatrixLoadTransposedEXT);
    }
    
    private native void dispatch_glMatrixLoadTransposedEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixLoadTransposedEXT(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixLoadTransposedEXT = this._pat._addressof_glMatrixLoadTransposedEXT;
        if (addressof_glMatrixLoadTransposedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposedEXT"));
        }
        this.dispatch_glMatrixLoadTransposedEXT1(n, array, 8 * n2, false, addressof_glMatrixLoadTransposedEXT);
    }
    
    @Override
    public void glMatrixMultTransposefEXT(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMatrixMultTransposefEXT = this._pat._addressof_glMatrixMultTransposefEXT;
        if (addressof_glMatrixMultTransposefEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposefEXT"));
        }
        this.dispatch_glMatrixMultTransposefEXT1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMatrixMultTransposefEXT);
    }
    
    private native void dispatch_glMatrixMultTransposefEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixMultTransposefEXT(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixMultTransposefEXT = this._pat._addressof_glMatrixMultTransposefEXT;
        if (addressof_glMatrixMultTransposefEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposefEXT"));
        }
        this.dispatch_glMatrixMultTransposefEXT1(n, array, 4 * n2, false, addressof_glMatrixMultTransposefEXT);
    }
    
    @Override
    public void glMatrixMultTransposedEXT(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glMatrixMultTransposedEXT = this._pat._addressof_glMatrixMultTransposedEXT;
        if (addressof_glMatrixMultTransposedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposedEXT"));
        }
        this.dispatch_glMatrixMultTransposedEXT1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glMatrixMultTransposedEXT);
    }
    
    private native void dispatch_glMatrixMultTransposedEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMatrixMultTransposedEXT(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"m_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMatrixMultTransposedEXT = this._pat._addressof_glMatrixMultTransposedEXT;
        if (addressof_glMatrixMultTransposedEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposedEXT"));
        }
        this.dispatch_glMatrixMultTransposedEXT1(n, array, 8 * n2, false, addressof_glMatrixMultTransposedEXT);
    }
    
    private void glNamedBufferDataEXTDelegate(final int n, final long n2, final Buffer buffer, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glNamedBufferDataEXT = this._pat._addressof_glNamedBufferDataEXT;
        if (addressof_glNamedBufferDataEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferDataEXT"));
        }
        this.dispatch_glNamedBufferDataEXTDelegate1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, addressof_glNamedBufferDataEXT);
    }
    
    private native void dispatch_glNamedBufferDataEXTDelegate1(final int p0, final long p1, final Object p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glNamedBufferSubDataEXT(final int n, final long n2, final long n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glNamedBufferSubDataEXT = this._pat._addressof_glNamedBufferSubDataEXT;
        if (addressof_glNamedBufferSubDataEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferSubDataEXT"));
        }
        this.dispatch_glNamedBufferSubDataEXT1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glNamedBufferSubDataEXT);
    }
    
    private native void dispatch_glNamedBufferSubDataEXT1(final int p0, final long p1, final long p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    private long glMapNamedBufferEXTDelegate(final int n, final int n2) {
        final long addressof_glMapNamedBufferEXT = this._pat._addressof_glMapNamedBufferEXT;
        if (addressof_glMapNamedBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBufferEXT"));
        }
        return this.dispatch_glMapNamedBufferEXTDelegate1(n, n2, addressof_glMapNamedBufferEXT);
    }
    
    private native long dispatch_glMapNamedBufferEXTDelegate1(final int p0, final int p1, final long p2);
    
    @Override
    public boolean glUnmapNamedBufferEXT(final int n) {
        final long addressof_glUnmapNamedBufferEXT = this._pat._addressof_glUnmapNamedBufferEXT;
        if (addressof_glUnmapNamedBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUnmapNamedBufferEXT"));
        }
        return this.dispatch_glUnmapNamedBufferEXT1(n, addressof_glUnmapNamedBufferEXT);
    }
    
    private native boolean dispatch_glUnmapNamedBufferEXT1(final int p0, final long p1);
    
    @Override
    public void glGetNamedBufferParameterivEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedBufferParameterivEXT = this._pat._addressof_glGetNamedBufferParameterivEXT;
        if (addressof_glGetNamedBufferParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterivEXT"));
        }
        this.dispatch_glGetNamedBufferParameterivEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedBufferParameterivEXT);
    }
    
    private native void dispatch_glGetNamedBufferParameterivEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedBufferParameterivEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedBufferParameterivEXT = this._pat._addressof_glGetNamedBufferParameterivEXT;
        if (addressof_glGetNamedBufferParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterivEXT"));
        }
        this.dispatch_glGetNamedBufferParameterivEXT1(n, n2, array, 4 * n3, false, addressof_glGetNamedBufferParameterivEXT);
    }
    
    @Override
    public void glGetNamedBufferSubDataEXT(final int n, final long n2, final long n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetNamedBufferSubDataEXT = this._pat._addressof_glGetNamedBufferSubDataEXT;
        if (addressof_glGetNamedBufferSubDataEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferSubDataEXT"));
        }
        this.dispatch_glGetNamedBufferSubDataEXT1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetNamedBufferSubDataEXT);
    }
    
    private native void dispatch_glGetNamedBufferSubDataEXT1(final int p0, final long p1, final long p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTextureBufferEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glTextureBufferEXT = this._pat._addressof_glTextureBufferEXT;
        if (addressof_glTextureBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureBufferEXT"));
        }
        this.dispatch_glTextureBufferEXT1(n, n2, n3, n4, addressof_glTextureBufferEXT);
    }
    
    private native void dispatch_glTextureBufferEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glMultiTexBufferEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glMultiTexBufferEXT = this._pat._addressof_glMultiTexBufferEXT;
        if (addressof_glMultiTexBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexBufferEXT"));
        }
        this.dispatch_glMultiTexBufferEXT1(n, n2, n3, n4, addressof_glMultiTexBufferEXT);
    }
    
    private native void dispatch_glMultiTexBufferEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glTextureParameterIivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTextureParameterIivEXT = this._pat._addressof_glTextureParameterIivEXT;
        if (addressof_glTextureParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIivEXT"));
        }
        this.dispatch_glTextureParameterIivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTextureParameterIivEXT);
    }
    
    private native void dispatch_glTextureParameterIivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTextureParameterIivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameterIivEXT = this._pat._addressof_glTextureParameterIivEXT;
        if (addressof_glTextureParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIivEXT"));
        }
        this.dispatch_glTextureParameterIivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glTextureParameterIivEXT);
    }
    
    @Override
    public void glTextureParameterIuivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glTextureParameterIuivEXT = this._pat._addressof_glTextureParameterIuivEXT;
        if (addressof_glTextureParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuivEXT"));
        }
        this.dispatch_glTextureParameterIuivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glTextureParameterIuivEXT);
    }
    
    private native void dispatch_glTextureParameterIuivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glTextureParameterIuivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTextureParameterIuivEXT = this._pat._addressof_glTextureParameterIuivEXT;
        if (addressof_glTextureParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuivEXT"));
        }
        this.dispatch_glTextureParameterIuivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glTextureParameterIuivEXT);
    }
    
    @Override
    public void glGetTextureParameterIivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureParameterIivEXT = this._pat._addressof_glGetTextureParameterIivEXT;
        if (addressof_glGetTextureParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIivEXT"));
        }
        this.dispatch_glGetTextureParameterIivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureParameterIivEXT);
    }
    
    private native void dispatch_glGetTextureParameterIivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTextureParameterIivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameterIivEXT = this._pat._addressof_glGetTextureParameterIivEXT;
        if (addressof_glGetTextureParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIivEXT"));
        }
        this.dispatch_glGetTextureParameterIivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetTextureParameterIivEXT);
    }
    
    @Override
    public void glGetTextureParameterIuivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetTextureParameterIuivEXT = this._pat._addressof_glGetTextureParameterIuivEXT;
        if (addressof_glGetTextureParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuivEXT"));
        }
        this.dispatch_glGetTextureParameterIuivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetTextureParameterIuivEXT);
    }
    
    private native void dispatch_glGetTextureParameterIuivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetTextureParameterIuivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetTextureParameterIuivEXT = this._pat._addressof_glGetTextureParameterIuivEXT;
        if (addressof_glGetTextureParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuivEXT"));
        }
        this.dispatch_glGetTextureParameterIuivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetTextureParameterIuivEXT);
    }
    
    @Override
    public void glMultiTexParameterIivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexParameterIivEXT = this._pat._addressof_glMultiTexParameterIivEXT;
        if (addressof_glMultiTexParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIivEXT"));
        }
        this.dispatch_glMultiTexParameterIivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexParameterIivEXT);
    }
    
    private native void dispatch_glMultiTexParameterIivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexParameterIivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexParameterIivEXT = this._pat._addressof_glMultiTexParameterIivEXT;
        if (addressof_glMultiTexParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIivEXT"));
        }
        this.dispatch_glMultiTexParameterIivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexParameterIivEXT);
    }
    
    @Override
    public void glMultiTexParameterIuivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMultiTexParameterIuivEXT = this._pat._addressof_glMultiTexParameterIuivEXT;
        if (addressof_glMultiTexParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIuivEXT"));
        }
        this.dispatch_glMultiTexParameterIuivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMultiTexParameterIuivEXT);
    }
    
    private native void dispatch_glMultiTexParameterIuivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glMultiTexParameterIuivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexParameterIuivEXT = this._pat._addressof_glMultiTexParameterIuivEXT;
        if (addressof_glMultiTexParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIuivEXT"));
        }
        this.dispatch_glMultiTexParameterIuivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glMultiTexParameterIuivEXT);
    }
    
    @Override
    public void glGetMultiTexParameterIivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMultiTexParameterIivEXT = this._pat._addressof_glGetMultiTexParameterIivEXT;
        if (addressof_glGetMultiTexParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIivEXT"));
        }
        this.dispatch_glGetMultiTexParameterIivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMultiTexParameterIivEXT);
    }
    
    private native void dispatch_glGetMultiTexParameterIivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexParameterIivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexParameterIivEXT = this._pat._addressof_glGetMultiTexParameterIivEXT;
        if (addressof_glGetMultiTexParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIivEXT"));
        }
        this.dispatch_glGetMultiTexParameterIivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexParameterIivEXT);
    }
    
    @Override
    public void glGetMultiTexParameterIuivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMultiTexParameterIuivEXT = this._pat._addressof_glGetMultiTexParameterIuivEXT;
        if (addressof_glGetMultiTexParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIuivEXT"));
        }
        this.dispatch_glGetMultiTexParameterIuivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMultiTexParameterIuivEXT);
    }
    
    private native void dispatch_glGetMultiTexParameterIuivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMultiTexParameterIuivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultiTexParameterIuivEXT = this._pat._addressof_glGetMultiTexParameterIuivEXT;
        if (addressof_glGetMultiTexParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIuivEXT"));
        }
        this.dispatch_glGetMultiTexParameterIuivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetMultiTexParameterIuivEXT);
    }
    
    @Override
    public void glNamedProgramLocalParameters4fvEXT(final int n, final int n2, final int n3, final int n4, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glNamedProgramLocalParameters4fvEXT = this._pat._addressof_glNamedProgramLocalParameters4fvEXT;
        if (addressof_glNamedProgramLocalParameters4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameters4fvEXT"));
        }
        this.dispatch_glNamedProgramLocalParameters4fvEXT1(n, n2, n3, n4, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glNamedProgramLocalParameters4fvEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameters4fvEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParameters4fvEXT(final int n, final int n2, final int n3, final int n4, final float[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedProgramLocalParameters4fvEXT = this._pat._addressof_glNamedProgramLocalParameters4fvEXT;
        if (addressof_glNamedProgramLocalParameters4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameters4fvEXT"));
        }
        this.dispatch_glNamedProgramLocalParameters4fvEXT1(n, n2, n3, n4, array, 4 * n5, false, addressof_glNamedProgramLocalParameters4fvEXT);
    }
    
    @Override
    public void glNamedProgramLocalParameterI4iEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7) {
        final long addressof_glNamedProgramLocalParameterI4iEXT = this._pat._addressof_glNamedProgramLocalParameterI4iEXT;
        if (addressof_glNamedProgramLocalParameterI4iEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4iEXT"));
        }
        this.dispatch_glNamedProgramLocalParameterI4iEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glNamedProgramLocalParameterI4iEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameterI4iEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParameterI4ivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glNamedProgramLocalParameterI4ivEXT = this._pat._addressof_glNamedProgramLocalParameterI4ivEXT;
        if (addressof_glNamedProgramLocalParameterI4ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4ivEXT"));
        }
        this.dispatch_glNamedProgramLocalParameterI4ivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glNamedProgramLocalParameterI4ivEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameterI4ivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glNamedProgramLocalParameterI4ivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedProgramLocalParameterI4ivEXT = this._pat._addressof_glNamedProgramLocalParameterI4ivEXT;
        if (addressof_glNamedProgramLocalParameterI4ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4ivEXT"));
        }
        this.dispatch_glNamedProgramLocalParameterI4ivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glNamedProgramLocalParameterI4ivEXT);
    }
    
    @Override
    public void glNamedProgramLocalParametersI4ivEXT(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glNamedProgramLocalParametersI4ivEXT = this._pat._addressof_glNamedProgramLocalParametersI4ivEXT;
        if (addressof_glNamedProgramLocalParametersI4ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4ivEXT"));
        }
        this.dispatch_glNamedProgramLocalParametersI4ivEXT1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glNamedProgramLocalParametersI4ivEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParametersI4ivEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParametersI4ivEXT(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedProgramLocalParametersI4ivEXT = this._pat._addressof_glNamedProgramLocalParametersI4ivEXT;
        if (addressof_glNamedProgramLocalParametersI4ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4ivEXT"));
        }
        this.dispatch_glNamedProgramLocalParametersI4ivEXT1(n, n2, n3, n4, array, 4 * n5, false, addressof_glNamedProgramLocalParametersI4ivEXT);
    }
    
    @Override
    public void glNamedProgramLocalParameterI4uiEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7) {
        final long addressof_glNamedProgramLocalParameterI4uiEXT = this._pat._addressof_glNamedProgramLocalParameterI4uiEXT;
        if (addressof_glNamedProgramLocalParameterI4uiEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4uiEXT"));
        }
        this.dispatch_glNamedProgramLocalParameterI4uiEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glNamedProgramLocalParameterI4uiEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameterI4uiEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParameterI4uivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glNamedProgramLocalParameterI4uivEXT = this._pat._addressof_glNamedProgramLocalParameterI4uivEXT;
        if (addressof_glNamedProgramLocalParameterI4uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4uivEXT"));
        }
        this.dispatch_glNamedProgramLocalParameterI4uivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glNamedProgramLocalParameterI4uivEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameterI4uivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glNamedProgramLocalParameterI4uivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedProgramLocalParameterI4uivEXT = this._pat._addressof_glNamedProgramLocalParameterI4uivEXT;
        if (addressof_glNamedProgramLocalParameterI4uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4uivEXT"));
        }
        this.dispatch_glNamedProgramLocalParameterI4uivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glNamedProgramLocalParameterI4uivEXT);
    }
    
    @Override
    public void glNamedProgramLocalParametersI4uivEXT(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glNamedProgramLocalParametersI4uivEXT = this._pat._addressof_glNamedProgramLocalParametersI4uivEXT;
        if (addressof_glNamedProgramLocalParametersI4uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4uivEXT"));
        }
        this.dispatch_glNamedProgramLocalParametersI4uivEXT1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glNamedProgramLocalParametersI4uivEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParametersI4uivEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParametersI4uivEXT(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedProgramLocalParametersI4uivEXT = this._pat._addressof_glNamedProgramLocalParametersI4uivEXT;
        if (addressof_glNamedProgramLocalParametersI4uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4uivEXT"));
        }
        this.dispatch_glNamedProgramLocalParametersI4uivEXT1(n, n2, n3, n4, array, 4 * n5, false, addressof_glNamedProgramLocalParametersI4uivEXT);
    }
    
    @Override
    public void glGetNamedProgramLocalParameterIivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedProgramLocalParameterIivEXT = this._pat._addressof_glGetNamedProgramLocalParameterIivEXT;
        if (addressof_glGetNamedProgramLocalParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIivEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterIivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedProgramLocalParameterIivEXT);
    }
    
    private native void dispatch_glGetNamedProgramLocalParameterIivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedProgramLocalParameterIivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedProgramLocalParameterIivEXT = this._pat._addressof_glGetNamedProgramLocalParameterIivEXT;
        if (addressof_glGetNamedProgramLocalParameterIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIivEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterIivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetNamedProgramLocalParameterIivEXT);
    }
    
    @Override
    public void glGetNamedProgramLocalParameterIuivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedProgramLocalParameterIuivEXT = this._pat._addressof_glGetNamedProgramLocalParameterIuivEXT;
        if (addressof_glGetNamedProgramLocalParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIuivEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterIuivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedProgramLocalParameterIuivEXT);
    }
    
    private native void dispatch_glGetNamedProgramLocalParameterIuivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedProgramLocalParameterIuivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedProgramLocalParameterIuivEXT = this._pat._addressof_glGetNamedProgramLocalParameterIuivEXT;
        if (addressof_glGetNamedProgramLocalParameterIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIuivEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterIuivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetNamedProgramLocalParameterIuivEXT);
    }
    
    @Override
    public void glEnableClientStateiEXT(final int n, final int n2) {
        final long addressof_glEnableClientStateiEXT = this._pat._addressof_glEnableClientStateiEXT;
        if (addressof_glEnableClientStateiEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableClientStateiEXT"));
        }
        this.dispatch_glEnableClientStateiEXT1(n, n2, addressof_glEnableClientStateiEXT);
    }
    
    private native void dispatch_glEnableClientStateiEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisableClientStateiEXT(final int n, final int n2) {
        final long addressof_glDisableClientStateiEXT = this._pat._addressof_glDisableClientStateiEXT;
        if (addressof_glDisableClientStateiEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableClientStateiEXT"));
        }
        this.dispatch_glDisableClientStateiEXT1(n, n2, addressof_glDisableClientStateiEXT);
    }
    
    private native void dispatch_glDisableClientStateiEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetFloati_vEXT(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetFloati_vEXT = this._pat._addressof_glGetFloati_vEXT;
        if (addressof_glGetFloati_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_vEXT"));
        }
        this.dispatch_glGetFloati_vEXT1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetFloati_vEXT);
    }
    
    private native void dispatch_glGetFloati_vEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetFloati_vEXT(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFloati_vEXT = this._pat._addressof_glGetFloati_vEXT;
        if (addressof_glGetFloati_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_vEXT"));
        }
        this.dispatch_glGetFloati_vEXT1(n, n2, array, 4 * n3, false, addressof_glGetFloati_vEXT);
    }
    
    @Override
    public void glGetDoublei_vEXT(final int n, final int n2, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetDoublei_vEXT = this._pat._addressof_glGetDoublei_vEXT;
        if (addressof_glGetDoublei_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_vEXT"));
        }
        this.dispatch_glGetDoublei_vEXT1(n, n2, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetDoublei_vEXT);
    }
    
    private native void dispatch_glGetDoublei_vEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetDoublei_vEXT(final int n, final int n2, final double[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetDoublei_vEXT = this._pat._addressof_glGetDoublei_vEXT;
        if (addressof_glGetDoublei_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_vEXT"));
        }
        this.dispatch_glGetDoublei_vEXT1(n, n2, array, 8 * n3, false, addressof_glGetDoublei_vEXT);
    }
    
    @Override
    public void glGetPointeri_vEXT(final int n, final int n2, final PointerBuffer pointerBuffer) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final long addressof_glGetPointeri_vEXT = this._pat._addressof_glGetPointeri_vEXT;
        if (addressof_glGetPointeri_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPointeri_vEXT"));
        }
        this.dispatch_glGetPointeri_vEXT1(n, n2, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, addressof_glGetPointeri_vEXT);
    }
    
    private native void dispatch_glGetPointeri_vEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glNamedProgramStringEXT(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glNamedProgramStringEXT = this._pat._addressof_glNamedProgramStringEXT;
        if (addressof_glNamedProgramStringEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramStringEXT"));
        }
        this.dispatch_glNamedProgramStringEXT1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glNamedProgramStringEXT);
    }
    
    private native void dispatch_glNamedProgramStringEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParameter4dEXT(final int n, final int n2, final int n3, final double n4, final double n5, final double n6, final double n7) {
        final long addressof_glNamedProgramLocalParameter4dEXT = this._pat._addressof_glNamedProgramLocalParameter4dEXT;
        if (addressof_glNamedProgramLocalParameter4dEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4dEXT"));
        }
        this.dispatch_glNamedProgramLocalParameter4dEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glNamedProgramLocalParameter4dEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameter4dEXT1(final int p0, final int p1, final int p2, final double p3, final double p4, final double p5, final double p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParameter4dvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glNamedProgramLocalParameter4dvEXT = this._pat._addressof_glNamedProgramLocalParameter4dvEXT;
        if (addressof_glNamedProgramLocalParameter4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4dvEXT"));
        }
        this.dispatch_glNamedProgramLocalParameter4dvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glNamedProgramLocalParameter4dvEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameter4dvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glNamedProgramLocalParameter4dvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedProgramLocalParameter4dvEXT = this._pat._addressof_glNamedProgramLocalParameter4dvEXT;
        if (addressof_glNamedProgramLocalParameter4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4dvEXT"));
        }
        this.dispatch_glNamedProgramLocalParameter4dvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glNamedProgramLocalParameter4dvEXT);
    }
    
    @Override
    public void glNamedProgramLocalParameter4fEXT(final int n, final int n2, final int n3, final float n4, final float n5, final float n6, final float n7) {
        final long addressof_glNamedProgramLocalParameter4fEXT = this._pat._addressof_glNamedProgramLocalParameter4fEXT;
        if (addressof_glNamedProgramLocalParameter4fEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4fEXT"));
        }
        this.dispatch_glNamedProgramLocalParameter4fEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glNamedProgramLocalParameter4fEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameter4fEXT1(final int p0, final int p1, final int p2, final float p3, final float p4, final float p5, final float p6, final long p7);
    
    @Override
    public void glNamedProgramLocalParameter4fvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glNamedProgramLocalParameter4fvEXT = this._pat._addressof_glNamedProgramLocalParameter4fvEXT;
        if (addressof_glNamedProgramLocalParameter4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4fvEXT"));
        }
        this.dispatch_glNamedProgramLocalParameter4fvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glNamedProgramLocalParameter4fvEXT);
    }
    
    private native void dispatch_glNamedProgramLocalParameter4fvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glNamedProgramLocalParameter4fvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedProgramLocalParameter4fvEXT = this._pat._addressof_glNamedProgramLocalParameter4fvEXT;
        if (addressof_glNamedProgramLocalParameter4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4fvEXT"));
        }
        this.dispatch_glNamedProgramLocalParameter4fvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glNamedProgramLocalParameter4fvEXT);
    }
    
    @Override
    public void glGetNamedProgramLocalParameterdvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetNamedProgramLocalParameterdvEXT = this._pat._addressof_glGetNamedProgramLocalParameterdvEXT;
        if (addressof_glGetNamedProgramLocalParameterdvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterdvEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterdvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetNamedProgramLocalParameterdvEXT);
    }
    
    private native void dispatch_glGetNamedProgramLocalParameterdvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedProgramLocalParameterdvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedProgramLocalParameterdvEXT = this._pat._addressof_glGetNamedProgramLocalParameterdvEXT;
        if (addressof_glGetNamedProgramLocalParameterdvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterdvEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterdvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glGetNamedProgramLocalParameterdvEXT);
    }
    
    @Override
    public void glGetNamedProgramLocalParameterfvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetNamedProgramLocalParameterfvEXT = this._pat._addressof_glGetNamedProgramLocalParameterfvEXT;
        if (addressof_glGetNamedProgramLocalParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterfvEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterfvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetNamedProgramLocalParameterfvEXT);
    }
    
    private native void dispatch_glGetNamedProgramLocalParameterfvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedProgramLocalParameterfvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedProgramLocalParameterfvEXT = this._pat._addressof_glGetNamedProgramLocalParameterfvEXT;
        if (addressof_glGetNamedProgramLocalParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterfvEXT"));
        }
        this.dispatch_glGetNamedProgramLocalParameterfvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetNamedProgramLocalParameterfvEXT);
    }
    
    @Override
    public void glGetNamedProgramivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedProgramivEXT = this._pat._addressof_glGetNamedProgramivEXT;
        if (addressof_glGetNamedProgramivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramivEXT"));
        }
        this.dispatch_glGetNamedProgramivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedProgramivEXT);
    }
    
    private native void dispatch_glGetNamedProgramivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedProgramivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedProgramivEXT = this._pat._addressof_glGetNamedProgramivEXT;
        if (addressof_glGetNamedProgramivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramivEXT"));
        }
        this.dispatch_glGetNamedProgramivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetNamedProgramivEXT);
    }
    
    @Override
    public void glGetNamedProgramStringEXT(final int n, final int n2, final int n3, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetNamedProgramStringEXT = this._pat._addressof_glGetNamedProgramStringEXT;
        if (addressof_glGetNamedProgramStringEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramStringEXT"));
        }
        this.dispatch_glGetNamedProgramStringEXT1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetNamedProgramStringEXT);
    }
    
    private native void dispatch_glGetNamedProgramStringEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glNamedRenderbufferStorageEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glNamedRenderbufferStorageEXT = this._pat._addressof_glNamedRenderbufferStorageEXT;
        if (addressof_glNamedRenderbufferStorageEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageEXT"));
        }
        this.dispatch_glNamedRenderbufferStorageEXT1(n, n2, n3, n4, addressof_glNamedRenderbufferStorageEXT);
    }
    
    private native void dispatch_glNamedRenderbufferStorageEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glGetNamedRenderbufferParameterivEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedRenderbufferParameterivEXT = this._pat._addressof_glGetNamedRenderbufferParameterivEXT;
        if (addressof_glGetNamedRenderbufferParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameterivEXT"));
        }
        this.dispatch_glGetNamedRenderbufferParameterivEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedRenderbufferParameterivEXT);
    }
    
    private native void dispatch_glGetNamedRenderbufferParameterivEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedRenderbufferParameterivEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedRenderbufferParameterivEXT = this._pat._addressof_glGetNamedRenderbufferParameterivEXT;
        if (addressof_glGetNamedRenderbufferParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameterivEXT"));
        }
        this.dispatch_glGetNamedRenderbufferParameterivEXT1(n, n2, array, 4 * n3, false, addressof_glGetNamedRenderbufferParameterivEXT);
    }
    
    @Override
    public void glNamedRenderbufferStorageMultisampleEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glNamedRenderbufferStorageMultisampleEXT = this._pat._addressof_glNamedRenderbufferStorageMultisampleEXT;
        if (addressof_glNamedRenderbufferStorageMultisampleEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageMultisampleEXT"));
        }
        this.dispatch_glNamedRenderbufferStorageMultisampleEXT1(n, n2, n3, n4, n5, addressof_glNamedRenderbufferStorageMultisampleEXT);
    }
    
    private native void dispatch_glNamedRenderbufferStorageMultisampleEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glNamedRenderbufferStorageMultisampleCoverageEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glNamedRenderbufferStorageMultisampleCoverageEXT = this._pat._addressof_glNamedRenderbufferStorageMultisampleCoverageEXT;
        if (addressof_glNamedRenderbufferStorageMultisampleCoverageEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageMultisampleCoverageEXT"));
        }
        this.dispatch_glNamedRenderbufferStorageMultisampleCoverageEXT1(n, n2, n3, n4, n5, n6, addressof_glNamedRenderbufferStorageMultisampleCoverageEXT);
    }
    
    private native void dispatch_glNamedRenderbufferStorageMultisampleCoverageEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public int glCheckNamedFramebufferStatusEXT(final int n, final int n2) {
        final long addressof_glCheckNamedFramebufferStatusEXT = this._pat._addressof_glCheckNamedFramebufferStatusEXT;
        if (addressof_glCheckNamedFramebufferStatusEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCheckNamedFramebufferStatusEXT"));
        }
        return this.dispatch_glCheckNamedFramebufferStatusEXT1(n, n2, addressof_glCheckNamedFramebufferStatusEXT);
    }
    
    private native int dispatch_glCheckNamedFramebufferStatusEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glNamedFramebufferTexture1DEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glNamedFramebufferTexture1DEXT = this._pat._addressof_glNamedFramebufferTexture1DEXT;
        if (addressof_glNamedFramebufferTexture1DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture1DEXT"));
        }
        this.dispatch_glNamedFramebufferTexture1DEXT1(n, n2, n3, n4, n5, addressof_glNamedFramebufferTexture1DEXT);
    }
    
    private native void dispatch_glNamedFramebufferTexture1DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glNamedFramebufferTexture2DEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glNamedFramebufferTexture2DEXT = this._pat._addressof_glNamedFramebufferTexture2DEXT;
        if (addressof_glNamedFramebufferTexture2DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture2DEXT"));
        }
        this.dispatch_glNamedFramebufferTexture2DEXT1(n, n2, n3, n4, n5, addressof_glNamedFramebufferTexture2DEXT);
    }
    
    private native void dispatch_glNamedFramebufferTexture2DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glNamedFramebufferTexture3DEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glNamedFramebufferTexture3DEXT = this._pat._addressof_glNamedFramebufferTexture3DEXT;
        if (addressof_glNamedFramebufferTexture3DEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture3DEXT"));
        }
        this.dispatch_glNamedFramebufferTexture3DEXT1(n, n2, n3, n4, n5, n6, addressof_glNamedFramebufferTexture3DEXT);
    }
    
    private native void dispatch_glNamedFramebufferTexture3DEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glNamedFramebufferRenderbufferEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glNamedFramebufferRenderbufferEXT = this._pat._addressof_glNamedFramebufferRenderbufferEXT;
        if (addressof_glNamedFramebufferRenderbufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferRenderbufferEXT"));
        }
        this.dispatch_glNamedFramebufferRenderbufferEXT1(n, n2, n3, n4, addressof_glNamedFramebufferRenderbufferEXT);
    }
    
    private native void dispatch_glNamedFramebufferRenderbufferEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glGetNamedFramebufferAttachmentParameterivEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNamedFramebufferAttachmentParameterivEXT = this._pat._addressof_glGetNamedFramebufferAttachmentParameterivEXT;
        if (addressof_glGetNamedFramebufferAttachmentParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameterivEXT"));
        }
        this.dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNamedFramebufferAttachmentParameterivEXT);
    }
    
    private native void dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetNamedFramebufferAttachmentParameterivEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedFramebufferAttachmentParameterivEXT = this._pat._addressof_glGetNamedFramebufferAttachmentParameterivEXT;
        if (addressof_glGetNamedFramebufferAttachmentParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameterivEXT"));
        }
        this.dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetNamedFramebufferAttachmentParameterivEXT);
    }
    
    @Override
    public void glGenerateTextureMipmapEXT(final int n, final int n2) {
        final long addressof_glGenerateTextureMipmapEXT = this._pat._addressof_glGenerateTextureMipmapEXT;
        if (addressof_glGenerateTextureMipmapEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenerateTextureMipmapEXT"));
        }
        this.dispatch_glGenerateTextureMipmapEXT1(n, n2, addressof_glGenerateTextureMipmapEXT);
    }
    
    private native void dispatch_glGenerateTextureMipmapEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGenerateMultiTexMipmapEXT(final int n, final int n2) {
        final long addressof_glGenerateMultiTexMipmapEXT = this._pat._addressof_glGenerateMultiTexMipmapEXT;
        if (addressof_glGenerateMultiTexMipmapEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenerateMultiTexMipmapEXT"));
        }
        this.dispatch_glGenerateMultiTexMipmapEXT1(n, n2, addressof_glGenerateMultiTexMipmapEXT);
    }
    
    private native void dispatch_glGenerateMultiTexMipmapEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glFramebufferDrawBufferEXT(final int n, final int n2) {
        final long addressof_glFramebufferDrawBufferEXT = this._pat._addressof_glFramebufferDrawBufferEXT;
        if (addressof_glFramebufferDrawBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferDrawBufferEXT"));
        }
        this.dispatch_glFramebufferDrawBufferEXT1(n, n2, addressof_glFramebufferDrawBufferEXT);
    }
    
    private native void dispatch_glFramebufferDrawBufferEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glFramebufferDrawBuffersEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glFramebufferDrawBuffersEXT = this._pat._addressof_glFramebufferDrawBuffersEXT;
        if (addressof_glFramebufferDrawBuffersEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferDrawBuffersEXT"));
        }
        this.dispatch_glFramebufferDrawBuffersEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glFramebufferDrawBuffersEXT);
    }
    
    private native void dispatch_glFramebufferDrawBuffersEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glFramebufferDrawBuffersEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"bufs_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFramebufferDrawBuffersEXT = this._pat._addressof_glFramebufferDrawBuffersEXT;
        if (addressof_glFramebufferDrawBuffersEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferDrawBuffersEXT"));
        }
        this.dispatch_glFramebufferDrawBuffersEXT1(n, n2, array, 4 * n3, false, addressof_glFramebufferDrawBuffersEXT);
    }
    
    @Override
    public void glFramebufferReadBufferEXT(final int n, final int n2) {
        final long addressof_glFramebufferReadBufferEXT = this._pat._addressof_glFramebufferReadBufferEXT;
        if (addressof_glFramebufferReadBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferReadBufferEXT"));
        }
        this.dispatch_glFramebufferReadBufferEXT1(n, n2, addressof_glFramebufferReadBufferEXT);
    }
    
    private native void dispatch_glFramebufferReadBufferEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetFramebufferParameterivEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetFramebufferParameterivEXT = this._pat._addressof_glGetFramebufferParameterivEXT;
        if (addressof_glGetFramebufferParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameterivEXT"));
        }
        this.dispatch_glGetFramebufferParameterivEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetFramebufferParameterivEXT);
    }
    
    private native void dispatch_glGetFramebufferParameterivEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetFramebufferParameterivEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFramebufferParameterivEXT = this._pat._addressof_glGetFramebufferParameterivEXT;
        if (addressof_glGetFramebufferParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameterivEXT"));
        }
        this.dispatch_glGetFramebufferParameterivEXT1(n, n2, array, 4 * n3, false, addressof_glGetFramebufferParameterivEXT);
    }
    
    @Override
    public void glNamedCopyBufferSubDataEXT(final int n, final int n2, final long n3, final long n4, final long n5) {
        final long addressof_glNamedCopyBufferSubDataEXT = this._pat._addressof_glNamedCopyBufferSubDataEXT;
        if (addressof_glNamedCopyBufferSubDataEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedCopyBufferSubDataEXT"));
        }
        this.dispatch_glNamedCopyBufferSubDataEXT1(n, n2, n3, n4, n5, addressof_glNamedCopyBufferSubDataEXT);
    }
    
    private native void dispatch_glNamedCopyBufferSubDataEXT1(final int p0, final int p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glNamedFramebufferTextureEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glNamedFramebufferTextureEXT = this._pat._addressof_glNamedFramebufferTextureEXT;
        if (addressof_glNamedFramebufferTextureEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureEXT"));
        }
        this.dispatch_glNamedFramebufferTextureEXT1(n, n2, n3, n4, addressof_glNamedFramebufferTextureEXT);
    }
    
    private native void dispatch_glNamedFramebufferTextureEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glNamedFramebufferTextureLayerEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glNamedFramebufferTextureLayerEXT = this._pat._addressof_glNamedFramebufferTextureLayerEXT;
        if (addressof_glNamedFramebufferTextureLayerEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureLayerEXT"));
        }
        this.dispatch_glNamedFramebufferTextureLayerEXT1(n, n2, n3, n4, n5, addressof_glNamedFramebufferTextureLayerEXT);
    }
    
    private native void dispatch_glNamedFramebufferTextureLayerEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glNamedFramebufferTextureFaceEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glNamedFramebufferTextureFaceEXT = this._pat._addressof_glNamedFramebufferTextureFaceEXT;
        if (addressof_glNamedFramebufferTextureFaceEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureFaceEXT"));
        }
        this.dispatch_glNamedFramebufferTextureFaceEXT1(n, n2, n3, n4, n5, addressof_glNamedFramebufferTextureFaceEXT);
    }
    
    private native void dispatch_glNamedFramebufferTextureFaceEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glTextureRenderbufferEXT(final int n, final int n2, final int n3) {
        final long addressof_glTextureRenderbufferEXT = this._pat._addressof_glTextureRenderbufferEXT;
        if (addressof_glTextureRenderbufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureRenderbufferEXT"));
        }
        this.dispatch_glTextureRenderbufferEXT1(n, n2, n3, addressof_glTextureRenderbufferEXT);
    }
    
    private native void dispatch_glTextureRenderbufferEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glMultiTexRenderbufferEXT(final int n, final int n2, final int n3) {
        final long addressof_glMultiTexRenderbufferEXT = this._pat._addressof_glMultiTexRenderbufferEXT;
        if (addressof_glMultiTexRenderbufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexRenderbufferEXT"));
        }
        this.dispatch_glMultiTexRenderbufferEXT1(n, n2, n3, addressof_glMultiTexRenderbufferEXT);
    }
    
    private native void dispatch_glMultiTexRenderbufferEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexArrayVertexOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        final long addressof_glVertexArrayVertexOffsetEXT = this._pat._addressof_glVertexArrayVertexOffsetEXT;
        if (addressof_glVertexArrayVertexOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexOffsetEXT"));
        }
        this.dispatch_glVertexArrayVertexOffsetEXT1(n, n2, n3, n4, n5, n6, addressof_glVertexArrayVertexOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayVertexOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glVertexArrayColorOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        final long addressof_glVertexArrayColorOffsetEXT = this._pat._addressof_glVertexArrayColorOffsetEXT;
        if (addressof_glVertexArrayColorOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayColorOffsetEXT"));
        }
        this.dispatch_glVertexArrayColorOffsetEXT1(n, n2, n3, n4, n5, n6, addressof_glVertexArrayColorOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayColorOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glVertexArrayEdgeFlagOffsetEXT(final int n, final int n2, final int n3, final long n4) {
        final long addressof_glVertexArrayEdgeFlagOffsetEXT = this._pat._addressof_glVertexArrayEdgeFlagOffsetEXT;
        if (addressof_glVertexArrayEdgeFlagOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayEdgeFlagOffsetEXT"));
        }
        this.dispatch_glVertexArrayEdgeFlagOffsetEXT1(n, n2, n3, n4, addressof_glVertexArrayEdgeFlagOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayEdgeFlagOffsetEXT1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glVertexArrayIndexOffsetEXT(final int n, final int n2, final int n3, final int n4, final long n5) {
        final long addressof_glVertexArrayIndexOffsetEXT = this._pat._addressof_glVertexArrayIndexOffsetEXT;
        if (addressof_glVertexArrayIndexOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayIndexOffsetEXT"));
        }
        this.dispatch_glVertexArrayIndexOffsetEXT1(n, n2, n3, n4, n5, addressof_glVertexArrayIndexOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayIndexOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glVertexArrayNormalOffsetEXT(final int n, final int n2, final int n3, final int n4, final long n5) {
        final long addressof_glVertexArrayNormalOffsetEXT = this._pat._addressof_glVertexArrayNormalOffsetEXT;
        if (addressof_glVertexArrayNormalOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayNormalOffsetEXT"));
        }
        this.dispatch_glVertexArrayNormalOffsetEXT1(n, n2, n3, n4, n5, addressof_glVertexArrayNormalOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayNormalOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glVertexArrayTexCoordOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        final long addressof_glVertexArrayTexCoordOffsetEXT = this._pat._addressof_glVertexArrayTexCoordOffsetEXT;
        if (addressof_glVertexArrayTexCoordOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayTexCoordOffsetEXT"));
        }
        this.dispatch_glVertexArrayTexCoordOffsetEXT1(n, n2, n3, n4, n5, n6, addressof_glVertexArrayTexCoordOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayTexCoordOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glVertexArrayMultiTexCoordOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        final long addressof_glVertexArrayMultiTexCoordOffsetEXT = this._pat._addressof_glVertexArrayMultiTexCoordOffsetEXT;
        if (addressof_glVertexArrayMultiTexCoordOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayMultiTexCoordOffsetEXT"));
        }
        this.dispatch_glVertexArrayMultiTexCoordOffsetEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glVertexArrayMultiTexCoordOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayMultiTexCoordOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glVertexArrayFogCoordOffsetEXT(final int n, final int n2, final int n3, final int n4, final long n5) {
        final long addressof_glVertexArrayFogCoordOffsetEXT = this._pat._addressof_glVertexArrayFogCoordOffsetEXT;
        if (addressof_glVertexArrayFogCoordOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayFogCoordOffsetEXT"));
        }
        this.dispatch_glVertexArrayFogCoordOffsetEXT1(n, n2, n3, n4, n5, addressof_glVertexArrayFogCoordOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayFogCoordOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5);
    
    @Override
    public void glVertexArraySecondaryColorOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final long n6) {
        final long addressof_glVertexArraySecondaryColorOffsetEXT = this._pat._addressof_glVertexArraySecondaryColorOffsetEXT;
        if (addressof_glVertexArraySecondaryColorOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArraySecondaryColorOffsetEXT"));
        }
        this.dispatch_glVertexArraySecondaryColorOffsetEXT1(n, n2, n3, n4, n5, n6, addressof_glVertexArraySecondaryColorOffsetEXT);
    }
    
    private native void dispatch_glVertexArraySecondaryColorOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5, final long p6);
    
    @Override
    public void glVertexArrayVertexAttribOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final boolean b, final int n6, final long n7) {
        final long addressof_glVertexArrayVertexAttribOffsetEXT = this._pat._addressof_glVertexArrayVertexAttribOffsetEXT;
        if (addressof_glVertexArrayVertexAttribOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribOffsetEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribOffsetEXT1(n, n2, n3, n4, n5, b, n6, n7, addressof_glVertexArrayVertexAttribOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final boolean p5, final int p6, final long p7, final long p8);
    
    @Override
    public void glVertexArrayVertexAttribIOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        final long addressof_glVertexArrayVertexAttribIOffsetEXT = this._pat._addressof_glVertexArrayVertexAttribIOffsetEXT;
        if (addressof_glVertexArrayVertexAttribIOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribIOffsetEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribIOffsetEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glVertexArrayVertexAttribIOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribIOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glEnableVertexArrayEXT(final int n, final int n2) {
        final long addressof_glEnableVertexArrayEXT = this._pat._addressof_glEnableVertexArrayEXT;
        if (addressof_glEnableVertexArrayEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexArrayEXT"));
        }
        this.dispatch_glEnableVertexArrayEXT1(n, n2, addressof_glEnableVertexArrayEXT);
    }
    
    private native void dispatch_glEnableVertexArrayEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisableVertexArrayEXT(final int n, final int n2) {
        final long addressof_glDisableVertexArrayEXT = this._pat._addressof_glDisableVertexArrayEXT;
        if (addressof_glDisableVertexArrayEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexArrayEXT"));
        }
        this.dispatch_glDisableVertexArrayEXT1(n, n2, addressof_glDisableVertexArrayEXT);
    }
    
    private native void dispatch_glDisableVertexArrayEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glEnableVertexArrayAttribEXT(final int n, final int n2) {
        final long addressof_glEnableVertexArrayAttribEXT = this._pat._addressof_glEnableVertexArrayAttribEXT;
        if (addressof_glEnableVertexArrayAttribEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexArrayAttribEXT"));
        }
        this.dispatch_glEnableVertexArrayAttribEXT1(n, n2, addressof_glEnableVertexArrayAttribEXT);
    }
    
    private native void dispatch_glEnableVertexArrayAttribEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDisableVertexArrayAttribEXT(final int n, final int n2) {
        final long addressof_glDisableVertexArrayAttribEXT = this._pat._addressof_glDisableVertexArrayAttribEXT;
        if (addressof_glDisableVertexArrayAttribEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexArrayAttribEXT"));
        }
        this.dispatch_glDisableVertexArrayAttribEXT1(n, n2, addressof_glDisableVertexArrayAttribEXT);
    }
    
    private native void dispatch_glDisableVertexArrayAttribEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetVertexArrayIntegervEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexArrayIntegervEXT = this._pat._addressof_glGetVertexArrayIntegervEXT;
        if (addressof_glGetVertexArrayIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegervEXT"));
        }
        this.dispatch_glGetVertexArrayIntegervEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexArrayIntegervEXT);
    }
    
    private native void dispatch_glGetVertexArrayIntegervEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexArrayIntegervEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexArrayIntegervEXT = this._pat._addressof_glGetVertexArrayIntegervEXT;
        if (addressof_glGetVertexArrayIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegervEXT"));
        }
        this.dispatch_glGetVertexArrayIntegervEXT1(n, n2, array, 4 * n3, false, addressof_glGetVertexArrayIntegervEXT);
    }
    
    @Override
    public void glGetVertexArrayPointervEXT(final int n, final int n2, final PointerBuffer pointerBuffer) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final long addressof_glGetVertexArrayPointervEXT = this._pat._addressof_glGetVertexArrayPointervEXT;
        if (addressof_glGetVertexArrayPointervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayPointervEXT"));
        }
        this.dispatch_glGetVertexArrayPointervEXT1(n, n2, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, addressof_glGetVertexArrayPointervEXT);
    }
    
    private native void dispatch_glGetVertexArrayPointervEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexArrayIntegeri_vEXT(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexArrayIntegeri_vEXT = this._pat._addressof_glGetVertexArrayIntegeri_vEXT;
        if (addressof_glGetVertexArrayIntegeri_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegeri_vEXT"));
        }
        this.dispatch_glGetVertexArrayIntegeri_vEXT1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexArrayIntegeri_vEXT);
    }
    
    private native void dispatch_glGetVertexArrayIntegeri_vEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetVertexArrayIntegeri_vEXT(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"param_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexArrayIntegeri_vEXT = this._pat._addressof_glGetVertexArrayIntegeri_vEXT;
        if (addressof_glGetVertexArrayIntegeri_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegeri_vEXT"));
        }
        this.dispatch_glGetVertexArrayIntegeri_vEXT1(n, n2, n3, array, 4 * n4, false, addressof_glGetVertexArrayIntegeri_vEXT);
    }
    
    @Override
    public void glGetVertexArrayPointeri_vEXT(final int n, final int n2, final int n3, final PointerBuffer pointerBuffer) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final long addressof_glGetVertexArrayPointeri_vEXT = this._pat._addressof_glGetVertexArrayPointeri_vEXT;
        if (addressof_glGetVertexArrayPointeri_vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayPointeri_vEXT"));
        }
        this.dispatch_glGetVertexArrayPointeri_vEXT1(n, n2, n3, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, addressof_glGetVertexArrayPointeri_vEXT);
    }
    
    private native void dispatch_glGetVertexArrayPointeri_vEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    private long glMapNamedBufferRangeEXTDelegate(final int n, final long n2, final long n3, final int n4) {
        final long addressof_glMapNamedBufferRangeEXT = this._pat._addressof_glMapNamedBufferRangeEXT;
        if (addressof_glMapNamedBufferRangeEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBufferRangeEXT"));
        }
        return this.dispatch_glMapNamedBufferRangeEXTDelegate1(n, n2, n3, n4, addressof_glMapNamedBufferRangeEXT);
    }
    
    private native long dispatch_glMapNamedBufferRangeEXTDelegate1(final int p0, final long p1, final long p2, final int p3, final long p4);
    
    @Override
    public void glFlushMappedNamedBufferRangeEXT(final int n, final long n2, final long n3) {
        final long addressof_glFlushMappedNamedBufferRangeEXT = this._pat._addressof_glFlushMappedNamedBufferRangeEXT;
        if (addressof_glFlushMappedNamedBufferRangeEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedNamedBufferRangeEXT"));
        }
        this.dispatch_glFlushMappedNamedBufferRangeEXT1(n, n2, n3, addressof_glFlushMappedNamedBufferRangeEXT);
    }
    
    private native void dispatch_glFlushMappedNamedBufferRangeEXT1(final int p0, final long p1, final long p2, final long p3);
    
    private void glNamedBufferStorageEXTDelegate(final int n, final long n2, final Buffer buffer, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glNamedBufferStorageEXT = this._pat._addressof_glNamedBufferStorageEXT;
        if (addressof_glNamedBufferStorageEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferStorageEXT"));
        }
        this.dispatch_glNamedBufferStorageEXTDelegate1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, addressof_glNamedBufferStorageEXT);
    }
    
    private native void dispatch_glNamedBufferStorageEXTDelegate1(final int p0, final long p1, final Object p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glProgramUniform1dEXT(final int n, final int n2, final double n3) {
        final long addressof_glProgramUniform1dEXT = this._pat._addressof_glProgramUniform1dEXT;
        if (addressof_glProgramUniform1dEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dEXT"));
        }
        this.dispatch_glProgramUniform1dEXT1(n, n2, n3, addressof_glProgramUniform1dEXT);
    }
    
    private native void dispatch_glProgramUniform1dEXT1(final int p0, final int p1, final double p2, final long p3);
    
    @Override
    public void glProgramUniform2dEXT(final int n, final int n2, final double n3, final double n4) {
        final long addressof_glProgramUniform2dEXT = this._pat._addressof_glProgramUniform2dEXT;
        if (addressof_glProgramUniform2dEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dEXT"));
        }
        this.dispatch_glProgramUniform2dEXT1(n, n2, n3, n4, addressof_glProgramUniform2dEXT);
    }
    
    private native void dispatch_glProgramUniform2dEXT1(final int p0, final int p1, final double p2, final double p3, final long p4);
    
    @Override
    public void glProgramUniform3dEXT(final int n, final int n2, final double n3, final double n4, final double n5) {
        final long addressof_glProgramUniform3dEXT = this._pat._addressof_glProgramUniform3dEXT;
        if (addressof_glProgramUniform3dEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dEXT"));
        }
        this.dispatch_glProgramUniform3dEXT1(n, n2, n3, n4, n5, addressof_glProgramUniform3dEXT);
    }
    
    private native void dispatch_glProgramUniform3dEXT1(final int p0, final int p1, final double p2, final double p3, final double p4, final long p5);
    
    @Override
    public void glProgramUniform4dEXT(final int n, final int n2, final double n3, final double n4, final double n5, final double n6) {
        final long addressof_glProgramUniform4dEXT = this._pat._addressof_glProgramUniform4dEXT;
        if (addressof_glProgramUniform4dEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dEXT"));
        }
        this.dispatch_glProgramUniform4dEXT1(n, n2, n3, n4, n5, n6, addressof_glProgramUniform4dEXT);
    }
    
    private native void dispatch_glProgramUniform4dEXT1(final int p0, final int p1, final double p2, final double p3, final double p4, final double p5, final long p6);
    
    @Override
    public void glProgramUniform1dvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform1dvEXT = this._pat._addressof_glProgramUniform1dvEXT;
        if (addressof_glProgramUniform1dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dvEXT"));
        }
        this.dispatch_glProgramUniform1dvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform1dvEXT);
    }
    
    private native void dispatch_glProgramUniform1dvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform1dvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform1dvEXT = this._pat._addressof_glProgramUniform1dvEXT;
        if (addressof_glProgramUniform1dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dvEXT"));
        }
        this.dispatch_glProgramUniform1dvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform1dvEXT);
    }
    
    @Override
    public void glProgramUniform2dvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform2dvEXT = this._pat._addressof_glProgramUniform2dvEXT;
        if (addressof_glProgramUniform2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dvEXT"));
        }
        this.dispatch_glProgramUniform2dvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform2dvEXT);
    }
    
    private native void dispatch_glProgramUniform2dvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform2dvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform2dvEXT = this._pat._addressof_glProgramUniform2dvEXT;
        if (addressof_glProgramUniform2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dvEXT"));
        }
        this.dispatch_glProgramUniform2dvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform2dvEXT);
    }
    
    @Override
    public void glProgramUniform3dvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform3dvEXT = this._pat._addressof_glProgramUniform3dvEXT;
        if (addressof_glProgramUniform3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dvEXT"));
        }
        this.dispatch_glProgramUniform3dvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform3dvEXT);
    }
    
    private native void dispatch_glProgramUniform3dvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform3dvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform3dvEXT = this._pat._addressof_glProgramUniform3dvEXT;
        if (addressof_glProgramUniform3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dvEXT"));
        }
        this.dispatch_glProgramUniform3dvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform3dvEXT);
    }
    
    @Override
    public void glProgramUniform4dvEXT(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniform4dvEXT = this._pat._addressof_glProgramUniform4dvEXT;
        if (addressof_glProgramUniform4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dvEXT"));
        }
        this.dispatch_glProgramUniform4dvEXT1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniform4dvEXT);
    }
    
    private native void dispatch_glProgramUniform4dvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniform4dvEXT(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniform4dvEXT = this._pat._addressof_glProgramUniform4dvEXT;
        if (addressof_glProgramUniform4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dvEXT"));
        }
        this.dispatch_glProgramUniform4dvEXT1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniform4dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix2dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix2dvEXT = this._pat._addressof_glProgramUniformMatrix2dvEXT;
        if (addressof_glProgramUniformMatrix2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix2dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix2dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix2dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2dvEXT = this._pat._addressof_glProgramUniformMatrix2dvEXT;
        if (addressof_glProgramUniformMatrix2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix2dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix2dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix3dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix3dvEXT = this._pat._addressof_glProgramUniformMatrix3dvEXT;
        if (addressof_glProgramUniformMatrix3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix3dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix3dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix3dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3dvEXT = this._pat._addressof_glProgramUniformMatrix3dvEXT;
        if (addressof_glProgramUniformMatrix3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix3dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix3dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix4dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix4dvEXT = this._pat._addressof_glProgramUniformMatrix4dvEXT;
        if (addressof_glProgramUniformMatrix4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix4dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix4dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix4dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4dvEXT = this._pat._addressof_glProgramUniformMatrix4dvEXT;
        if (addressof_glProgramUniformMatrix4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix4dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix4dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix2x3dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix2x3dvEXT = this._pat._addressof_glProgramUniformMatrix2x3dvEXT;
        if (addressof_glProgramUniformMatrix2x3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix2x3dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix2x3dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix2x3dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2x3dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2x3dvEXT = this._pat._addressof_glProgramUniformMatrix2x3dvEXT;
        if (addressof_glProgramUniformMatrix2x3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix2x3dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix2x3dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix2x4dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix2x4dvEXT = this._pat._addressof_glProgramUniformMatrix2x4dvEXT;
        if (addressof_glProgramUniformMatrix2x4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix2x4dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix2x4dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix2x4dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix2x4dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix2x4dvEXT = this._pat._addressof_glProgramUniformMatrix2x4dvEXT;
        if (addressof_glProgramUniformMatrix2x4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix2x4dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix2x4dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix3x2dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix3x2dvEXT = this._pat._addressof_glProgramUniformMatrix3x2dvEXT;
        if (addressof_glProgramUniformMatrix3x2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix3x2dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix3x2dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix3x2dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3x2dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3x2dvEXT = this._pat._addressof_glProgramUniformMatrix3x2dvEXT;
        if (addressof_glProgramUniformMatrix3x2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix3x2dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix3x2dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix3x4dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix3x4dvEXT = this._pat._addressof_glProgramUniformMatrix3x4dvEXT;
        if (addressof_glProgramUniformMatrix3x4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix3x4dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix3x4dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix3x4dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix3x4dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix3x4dvEXT = this._pat._addressof_glProgramUniformMatrix3x4dvEXT;
        if (addressof_glProgramUniformMatrix3x4dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix3x4dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix3x4dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix4x2dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix4x2dvEXT = this._pat._addressof_glProgramUniformMatrix4x2dvEXT;
        if (addressof_glProgramUniformMatrix4x2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix4x2dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix4x2dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix4x2dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4x2dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4x2dvEXT = this._pat._addressof_glProgramUniformMatrix4x2dvEXT;
        if (addressof_glProgramUniformMatrix4x2dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix4x2dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix4x2dvEXT);
    }
    
    @Override
    public void glProgramUniformMatrix4x3dvEXT(final int n, final int n2, final int n3, final boolean b, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glProgramUniformMatrix4x3dvEXT = this._pat._addressof_glProgramUniformMatrix4x3dvEXT;
        if (addressof_glProgramUniformMatrix4x3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix4x3dvEXT1(n, n2, n3, b, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glProgramUniformMatrix4x3dvEXT);
    }
    
    private native void dispatch_glProgramUniformMatrix4x3dvEXT1(final int p0, final int p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramUniformMatrix4x3dvEXT(final int n, final int n2, final int n3, final boolean b, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformMatrix4x3dvEXT = this._pat._addressof_glProgramUniformMatrix4x3dvEXT;
        if (addressof_glProgramUniformMatrix4x3dvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dvEXT"));
        }
        this.dispatch_glProgramUniformMatrix4x3dvEXT1(n, n2, n3, b, array, 8 * n4, false, addressof_glProgramUniformMatrix4x3dvEXT);
    }
    
    @Override
    public void glTextureBufferRangeEXT(final int n, final int n2, final int n3, final int n4, final long n5, final long n6) {
        final long addressof_glTextureBufferRangeEXT = this._pat._addressof_glTextureBufferRangeEXT;
        if (addressof_glTextureBufferRangeEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureBufferRangeEXT"));
        }
        this.dispatch_glTextureBufferRangeEXT1(n, n2, n3, n4, n5, n6, addressof_glTextureBufferRangeEXT);
    }
    
    private native void dispatch_glTextureBufferRangeEXT1(final int p0, final int p1, final int p2, final int p3, final long p4, final long p5, final long p6);
    
    @Override
    public void glTextureStorage2DMultisampleEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final boolean b) {
        final long addressof_glTextureStorage2DMultisampleEXT = this._pat._addressof_glTextureStorage2DMultisampleEXT;
        if (addressof_glTextureStorage2DMultisampleEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DMultisampleEXT"));
        }
        this.dispatch_glTextureStorage2DMultisampleEXT1(n, n2, n3, n4, n5, n6, b, addressof_glTextureStorage2DMultisampleEXT);
    }
    
    private native void dispatch_glTextureStorage2DMultisampleEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glTextureStorage3DMultisampleEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final boolean b) {
        final long addressof_glTextureStorage3DMultisampleEXT = this._pat._addressof_glTextureStorage3DMultisampleEXT;
        if (addressof_glTextureStorage3DMultisampleEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DMultisampleEXT"));
        }
        this.dispatch_glTextureStorage3DMultisampleEXT1(n, n2, n3, n4, n5, n6, n7, b, addressof_glTextureStorage3DMultisampleEXT);
    }
    
    private native void dispatch_glTextureStorage3DMultisampleEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glVertexArrayBindVertexBufferEXT(final int n, final int n2, final int n3, final long n4, final int n5) {
        final long addressof_glVertexArrayBindVertexBufferEXT = this._pat._addressof_glVertexArrayBindVertexBufferEXT;
        if (addressof_glVertexArrayBindVertexBufferEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayBindVertexBufferEXT"));
        }
        this.dispatch_glVertexArrayBindVertexBufferEXT1(n, n2, n3, n4, n5, addressof_glVertexArrayBindVertexBufferEXT);
    }
    
    private native void dispatch_glVertexArrayBindVertexBufferEXT1(final int p0, final int p1, final int p2, final long p3, final int p4, final long p5);
    
    @Override
    public void glVertexArrayVertexAttribFormatEXT(final int n, final int n2, final int n3, final int n4, final boolean b, final int n5) {
        final long addressof_glVertexArrayVertexAttribFormatEXT = this._pat._addressof_glVertexArrayVertexAttribFormatEXT;
        if (addressof_glVertexArrayVertexAttribFormatEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribFormatEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribFormatEXT1(n, n2, n3, n4, b, n5, addressof_glVertexArrayVertexAttribFormatEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribFormatEXT1(final int p0, final int p1, final int p2, final int p3, final boolean p4, final int p5, final long p6);
    
    @Override
    public void glVertexArrayVertexAttribIFormatEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexArrayVertexAttribIFormatEXT = this._pat._addressof_glVertexArrayVertexAttribIFormatEXT;
        if (addressof_glVertexArrayVertexAttribIFormatEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribIFormatEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribIFormatEXT1(n, n2, n3, n4, n5, addressof_glVertexArrayVertexAttribIFormatEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribIFormatEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexArrayVertexAttribLFormatEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexArrayVertexAttribLFormatEXT = this._pat._addressof_glVertexArrayVertexAttribLFormatEXT;
        if (addressof_glVertexArrayVertexAttribLFormatEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribLFormatEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribLFormatEXT1(n, n2, n3, n4, n5, addressof_glVertexArrayVertexAttribLFormatEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribLFormatEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexArrayVertexAttribBindingEXT(final int n, final int n2, final int n3) {
        final long addressof_glVertexArrayVertexAttribBindingEXT = this._pat._addressof_glVertexArrayVertexAttribBindingEXT;
        if (addressof_glVertexArrayVertexAttribBindingEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribBindingEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribBindingEXT1(n, n2, n3, addressof_glVertexArrayVertexAttribBindingEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribBindingEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexArrayVertexBindingDivisorEXT(final int n, final int n2, final int n3) {
        final long addressof_glVertexArrayVertexBindingDivisorEXT = this._pat._addressof_glVertexArrayVertexBindingDivisorEXT;
        if (addressof_glVertexArrayVertexBindingDivisorEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBindingDivisorEXT"));
        }
        this.dispatch_glVertexArrayVertexBindingDivisorEXT1(n, n2, n3, addressof_glVertexArrayVertexBindingDivisorEXT);
    }
    
    private native void dispatch_glVertexArrayVertexBindingDivisorEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexArrayVertexAttribLOffsetEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final long n7) {
        final long addressof_glVertexArrayVertexAttribLOffsetEXT = this._pat._addressof_glVertexArrayVertexAttribLOffsetEXT;
        if (addressof_glVertexArrayVertexAttribLOffsetEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribLOffsetEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribLOffsetEXT1(n, n2, n3, n4, n5, n6, n7, addressof_glVertexArrayVertexAttribLOffsetEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribLOffsetEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6, final long p7);
    
    @Override
    public void glTexturePageCommitmentEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final boolean b) {
        final long addressof_glTexturePageCommitmentEXT = this._pat._addressof_glTexturePageCommitmentEXT;
        if (addressof_glTexturePageCommitmentEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexturePageCommitmentEXT"));
        }
        this.dispatch_glTexturePageCommitmentEXT1(n, n2, n3, n4, n5, n6, n7, n8, b, addressof_glTexturePageCommitmentEXT);
    }
    
    private native void dispatch_glTexturePageCommitmentEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glVertexArrayVertexAttribDivisorEXT(final int n, final int n2, final int n3) {
        final long addressof_glVertexArrayVertexAttribDivisorEXT = this._pat._addressof_glVertexArrayVertexAttribDivisorEXT;
        if (addressof_glVertexArrayVertexAttribDivisorEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribDivisorEXT"));
        }
        this.dispatch_glVertexArrayVertexAttribDivisorEXT1(n, n2, n3, addressof_glVertexArrayVertexAttribDivisorEXT);
    }
    
    private native void dispatch_glVertexArrayVertexAttribDivisorEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glColorMaskIndexed(final int n, final boolean b, final boolean b2, final boolean b3, final boolean b4) {
        final long addressof_glColorMaskIndexed = this._pat._addressof_glColorMaskIndexed;
        if (addressof_glColorMaskIndexed == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorMaskIndexed"));
        }
        this.dispatch_glColorMaskIndexed1(n, b, b2, b3, b4, addressof_glColorMaskIndexed);
    }
    
    private native void dispatch_glColorMaskIndexed1(final int p0, final boolean p1, final boolean p2, final boolean p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramEnvParameters4fvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramEnvParameters4fvEXT = this._pat._addressof_glProgramEnvParameters4fvEXT;
        if (addressof_glProgramEnvParameters4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameters4fvEXT"));
        }
        this.dispatch_glProgramEnvParameters4fvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramEnvParameters4fvEXT);
    }
    
    private native void dispatch_glProgramEnvParameters4fvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramEnvParameters4fvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramEnvParameters4fvEXT = this._pat._addressof_glProgramEnvParameters4fvEXT;
        if (addressof_glProgramEnvParameters4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameters4fvEXT"));
        }
        this.dispatch_glProgramEnvParameters4fvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glProgramEnvParameters4fvEXT);
    }
    
    @Override
    public void glProgramLocalParameters4fvEXT(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramLocalParameters4fvEXT = this._pat._addressof_glProgramLocalParameters4fvEXT;
        if (addressof_glProgramLocalParameters4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameters4fvEXT"));
        }
        this.dispatch_glProgramLocalParameters4fvEXT1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramLocalParameters4fvEXT);
    }
    
    private native void dispatch_glProgramLocalParameters4fvEXT1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramLocalParameters4fvEXT(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramLocalParameters4fvEXT = this._pat._addressof_glProgramLocalParameters4fvEXT;
        if (addressof_glProgramLocalParameters4fvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameters4fvEXT"));
        }
        this.dispatch_glProgramLocalParameters4fvEXT1(n, n2, n3, array, 4 * n4, false, addressof_glProgramLocalParameters4fvEXT);
    }
    
    @Override
    public void glIndexFuncEXT(final int n, final float n2) {
        final long addressof_glIndexFuncEXT = this._pat._addressof_glIndexFuncEXT;
        if (addressof_glIndexFuncEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexFuncEXT"));
        }
        this.dispatch_glIndexFuncEXT1(n, n2, addressof_glIndexFuncEXT);
    }
    
    private native void dispatch_glIndexFuncEXT1(final int p0, final float p1, final long p2);
    
    @Override
    public void glIndexMaterialEXT(final int n, final int n2) {
        final long addressof_glIndexMaterialEXT = this._pat._addressof_glIndexMaterialEXT;
        if (addressof_glIndexMaterialEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexMaterialEXT"));
        }
        this.dispatch_glIndexMaterialEXT1(n, n2, addressof_glIndexMaterialEXT);
    }
    
    private native void dispatch_glIndexMaterialEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glApplyTextureEXT(final int n) {
        final long addressof_glApplyTextureEXT = this._pat._addressof_glApplyTextureEXT;
        if (addressof_glApplyTextureEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glApplyTextureEXT"));
        }
        this.dispatch_glApplyTextureEXT1(n, addressof_glApplyTextureEXT);
    }
    
    private native void dispatch_glApplyTextureEXT1(final int p0, final long p1);
    
    @Override
    public void glTextureLightEXT(final int n) {
        final long addressof_glTextureLightEXT = this._pat._addressof_glTextureLightEXT;
        if (addressof_glTextureLightEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureLightEXT"));
        }
        this.dispatch_glTextureLightEXT1(n, addressof_glTextureLightEXT);
    }
    
    private native void dispatch_glTextureLightEXT1(final int p0, final long p1);
    
    @Override
    public void glTextureMaterialEXT(final int n, final int n2) {
        final long addressof_glTextureMaterialEXT = this._pat._addressof_glTextureMaterialEXT;
        if (addressof_glTextureMaterialEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureMaterialEXT"));
        }
        this.dispatch_glTextureMaterialEXT1(n, n2, addressof_glTextureMaterialEXT);
    }
    
    private native void dispatch_glTextureMaterialEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glPixelTransformParameteriEXT(final int n, final int n2, final int n3) {
        final long addressof_glPixelTransformParameteriEXT = this._pat._addressof_glPixelTransformParameteriEXT;
        if (addressof_glPixelTransformParameteriEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameteriEXT"));
        }
        this.dispatch_glPixelTransformParameteriEXT1(n, n2, n3, addressof_glPixelTransformParameteriEXT);
    }
    
    private native void dispatch_glPixelTransformParameteriEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glPixelTransformParameterfEXT(final int n, final int n2, final float n3) {
        final long addressof_glPixelTransformParameterfEXT = this._pat._addressof_glPixelTransformParameterfEXT;
        if (addressof_glPixelTransformParameterfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterfEXT"));
        }
        this.dispatch_glPixelTransformParameterfEXT1(n, n2, n3, addressof_glPixelTransformParameterfEXT);
    }
    
    private native void dispatch_glPixelTransformParameterfEXT1(final int p0, final int p1, final float p2, final long p3);
    
    @Override
    public void glPixelTransformParameterivEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glPixelTransformParameterivEXT = this._pat._addressof_glPixelTransformParameterivEXT;
        if (addressof_glPixelTransformParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterivEXT"));
        }
        this.dispatch_glPixelTransformParameterivEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glPixelTransformParameterivEXT);
    }
    
    private native void dispatch_glPixelTransformParameterivEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glPixelTransformParameterivEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPixelTransformParameterivEXT = this._pat._addressof_glPixelTransformParameterivEXT;
        if (addressof_glPixelTransformParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterivEXT"));
        }
        this.dispatch_glPixelTransformParameterivEXT1(n, n2, array, 4 * n3, false, addressof_glPixelTransformParameterivEXT);
    }
    
    @Override
    public void glPixelTransformParameterfvEXT(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glPixelTransformParameterfvEXT = this._pat._addressof_glPixelTransformParameterfvEXT;
        if (addressof_glPixelTransformParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterfvEXT"));
        }
        this.dispatch_glPixelTransformParameterfvEXT1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glPixelTransformParameterfvEXT);
    }
    
    private native void dispatch_glPixelTransformParameterfvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glPixelTransformParameterfvEXT(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glPixelTransformParameterfvEXT = this._pat._addressof_glPixelTransformParameterfvEXT;
        if (addressof_glPixelTransformParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterfvEXT"));
        }
        this.dispatch_glPixelTransformParameterfvEXT1(n, n2, array, 4 * n3, false, addressof_glPixelTransformParameterfvEXT);
    }
    
    @Override
    public void glGetPixelTransformParameterivEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetPixelTransformParameterivEXT = this._pat._addressof_glGetPixelTransformParameterivEXT;
        if (addressof_glGetPixelTransformParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterivEXT"));
        }
        this.dispatch_glGetPixelTransformParameterivEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetPixelTransformParameterivEXT);
    }
    
    private native void dispatch_glGetPixelTransformParameterivEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetPixelTransformParameterivEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetPixelTransformParameterivEXT = this._pat._addressof_glGetPixelTransformParameterivEXT;
        if (addressof_glGetPixelTransformParameterivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterivEXT"));
        }
        this.dispatch_glGetPixelTransformParameterivEXT1(n, n2, array, 4 * n3, false, addressof_glGetPixelTransformParameterivEXT);
    }
    
    @Override
    public void glGetPixelTransformParameterfvEXT(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetPixelTransformParameterfvEXT = this._pat._addressof_glGetPixelTransformParameterfvEXT;
        if (addressof_glGetPixelTransformParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterfvEXT"));
        }
        this.dispatch_glGetPixelTransformParameterfvEXT1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetPixelTransformParameterfvEXT);
    }
    
    private native void dispatch_glGetPixelTransformParameterfvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetPixelTransformParameterfvEXT(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetPixelTransformParameterfvEXT = this._pat._addressof_glGetPixelTransformParameterfvEXT;
        if (addressof_glGetPixelTransformParameterfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterfvEXT"));
        }
        this.dispatch_glGetPixelTransformParameterfvEXT1(n, n2, array, 4 * n3, false, addressof_glGetPixelTransformParameterfvEXT);
    }
    
    @Override
    public void glPolygonOffsetClampEXT(final float n, final float n2, final float n3) {
        final long addressof_glPolygonOffsetClampEXT = this._pat._addressof_glPolygonOffsetClampEXT;
        if (addressof_glPolygonOffsetClampEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffsetClampEXT"));
        }
        this.dispatch_glPolygonOffsetClampEXT1(n, n2, n3, addressof_glPolygonOffsetClampEXT);
    }
    
    private native void dispatch_glPolygonOffsetClampEXT1(final float p0, final float p1, final float p2, final long p3);
    
    @Override
    public void glProvokingVertexEXT(final int n) {
        final long addressof_glProvokingVertexEXT = this._pat._addressof_glProvokingVertexEXT;
        if (addressof_glProvokingVertexEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProvokingVertexEXT"));
        }
        this.dispatch_glProvokingVertexEXT1(n, addressof_glProvokingVertexEXT);
    }
    
    private native void dispatch_glProvokingVertexEXT1(final int p0, final long p1);
    
    @Override
    public void glRasterSamplesEXT(final int n, final boolean b) {
        final long addressof_glRasterSamplesEXT = this._pat._addressof_glRasterSamplesEXT;
        if (addressof_glRasterSamplesEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRasterSamplesEXT"));
        }
        this.dispatch_glRasterSamplesEXT1(n, b, addressof_glRasterSamplesEXT);
    }
    
    private native void dispatch_glRasterSamplesEXT1(final int p0, final boolean p1, final long p2);
    
    @Override
    public void glStencilClearTagEXT(final int n, final int n2) {
        final long addressof_glStencilClearTagEXT = this._pat._addressof_glStencilClearTagEXT;
        if (addressof_glStencilClearTagEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStencilClearTagEXT"));
        }
        this.dispatch_glStencilClearTagEXT1(n, n2, addressof_glStencilClearTagEXT);
    }
    
    private native void dispatch_glStencilClearTagEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glActiveStencilFaceEXT(final int n) {
        final long addressof_glActiveStencilFaceEXT = this._pat._addressof_glActiveStencilFaceEXT;
        if (addressof_glActiveStencilFaceEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glActiveStencilFaceEXT"));
        }
        this.dispatch_glActiveStencilFaceEXT1(n, addressof_glActiveStencilFaceEXT);
    }
    
    private native void dispatch_glActiveStencilFaceEXT1(final int p0, final long p1);
    
    @Override
    public void glClearColorIi(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glClearColorIi = this._pat._addressof_glClearColorIi;
        if (addressof_glClearColorIi == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearColorIi"));
        }
        this.dispatch_glClearColorIi1(n, n2, n3, n4, addressof_glClearColorIi);
    }
    
    private native void dispatch_glClearColorIi1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glClearColorIui(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glClearColorIui = this._pat._addressof_glClearColorIui;
        if (addressof_glClearColorIui == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glClearColorIui"));
        }
        this.dispatch_glClearColorIui1(n, n2, n3, n4, addressof_glClearColorIui);
    }
    
    private native void dispatch_glClearColorIui1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glTextureNormalEXT(final int n) {
        final long addressof_glTextureNormalEXT = this._pat._addressof_glTextureNormalEXT;
        if (addressof_glTextureNormalEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureNormalEXT"));
        }
        this.dispatch_glTextureNormalEXT1(n, addressof_glTextureNormalEXT);
    }
    
    private native void dispatch_glTextureNormalEXT1(final int p0, final long p1);
    
    @Override
    public void glGetQueryObjecti64vEXT(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetQueryObjecti64vEXT = this._pat._addressof_glGetQueryObjecti64vEXT;
        if (addressof_glGetQueryObjecti64vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64vEXT"));
        }
        this.dispatch_glGetQueryObjecti64vEXT1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetQueryObjecti64vEXT);
    }
    
    private native void dispatch_glGetQueryObjecti64vEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetQueryObjecti64vEXT(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryObjecti64vEXT = this._pat._addressof_glGetQueryObjecti64vEXT;
        if (addressof_glGetQueryObjecti64vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64vEXT"));
        }
        this.dispatch_glGetQueryObjecti64vEXT1(n, n2, array, 8 * n3, false, addressof_glGetQueryObjecti64vEXT);
    }
    
    @Override
    public void glGetQueryObjectui64vEXT(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetQueryObjectui64vEXT = this._pat._addressof_glGetQueryObjectui64vEXT;
        if (addressof_glGetQueryObjectui64vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64vEXT"));
        }
        this.dispatch_glGetQueryObjectui64vEXT1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetQueryObjectui64vEXT);
    }
    
    private native void dispatch_glGetQueryObjectui64vEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetQueryObjectui64vEXT(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetQueryObjectui64vEXT = this._pat._addressof_glGetQueryObjectui64vEXT;
        if (addressof_glGetQueryObjectui64vEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64vEXT"));
        }
        this.dispatch_glGetQueryObjectui64vEXT1(n, n2, array, 8 * n3, false, addressof_glGetQueryObjectui64vEXT);
    }
    
    @Override
    public void glBeginVertexShaderEXT() {
        final long addressof_glBeginVertexShaderEXT = this._pat._addressof_glBeginVertexShaderEXT;
        if (addressof_glBeginVertexShaderEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginVertexShaderEXT"));
        }
        this.dispatch_glBeginVertexShaderEXT1(addressof_glBeginVertexShaderEXT);
    }
    
    private native void dispatch_glBeginVertexShaderEXT1(final long p0);
    
    @Override
    public void glEndVertexShaderEXT() {
        final long addressof_glEndVertexShaderEXT = this._pat._addressof_glEndVertexShaderEXT;
        if (addressof_glEndVertexShaderEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndVertexShaderEXT"));
        }
        this.dispatch_glEndVertexShaderEXT1(addressof_glEndVertexShaderEXT);
    }
    
    private native void dispatch_glEndVertexShaderEXT1(final long p0);
    
    @Override
    public void glBindVertexShaderEXT(final int n) {
        final long addressof_glBindVertexShaderEXT = this._pat._addressof_glBindVertexShaderEXT;
        if (addressof_glBindVertexShaderEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindVertexShaderEXT"));
        }
        this.dispatch_glBindVertexShaderEXT1(n, addressof_glBindVertexShaderEXT);
    }
    
    private native void dispatch_glBindVertexShaderEXT1(final int p0, final long p1);
    
    @Override
    public int glGenVertexShadersEXT(final int n) {
        final long addressof_glGenVertexShadersEXT = this._pat._addressof_glGenVertexShadersEXT;
        if (addressof_glGenVertexShadersEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenVertexShadersEXT"));
        }
        return this.dispatch_glGenVertexShadersEXT1(n, addressof_glGenVertexShadersEXT);
    }
    
    private native int dispatch_glGenVertexShadersEXT1(final int p0, final long p1);
    
    @Override
    public void glDeleteVertexShaderEXT(final int n) {
        final long addressof_glDeleteVertexShaderEXT = this._pat._addressof_glDeleteVertexShaderEXT;
        if (addressof_glDeleteVertexShaderEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexShaderEXT"));
        }
        this.dispatch_glDeleteVertexShaderEXT1(n, addressof_glDeleteVertexShaderEXT);
    }
    
    private native void dispatch_glDeleteVertexShaderEXT1(final int p0, final long p1);
    
    @Override
    public void glShaderOp1EXT(final int n, final int n2, final int n3) {
        final long addressof_glShaderOp1EXT = this._pat._addressof_glShaderOp1EXT;
        if (addressof_glShaderOp1EXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderOp1EXT"));
        }
        this.dispatch_glShaderOp1EXT1(n, n2, n3, addressof_glShaderOp1EXT);
    }
    
    private native void dispatch_glShaderOp1EXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glShaderOp2EXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glShaderOp2EXT = this._pat._addressof_glShaderOp2EXT;
        if (addressof_glShaderOp2EXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderOp2EXT"));
        }
        this.dispatch_glShaderOp2EXT1(n, n2, n3, n4, addressof_glShaderOp2EXT);
    }
    
    private native void dispatch_glShaderOp2EXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glShaderOp3EXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glShaderOp3EXT = this._pat._addressof_glShaderOp3EXT;
        if (addressof_glShaderOp3EXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glShaderOp3EXT"));
        }
        this.dispatch_glShaderOp3EXT1(n, n2, n3, n4, n5, addressof_glShaderOp3EXT);
    }
    
    private native void dispatch_glShaderOp3EXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glSwizzleEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glSwizzleEXT = this._pat._addressof_glSwizzleEXT;
        if (addressof_glSwizzleEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSwizzleEXT"));
        }
        this.dispatch_glSwizzleEXT1(n, n2, n3, n4, n5, n6, addressof_glSwizzleEXT);
    }
    
    private native void dispatch_glSwizzleEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glWriteMaskEXT(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glWriteMaskEXT = this._pat._addressof_glWriteMaskEXT;
        if (addressof_glWriteMaskEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glWriteMaskEXT"));
        }
        this.dispatch_glWriteMaskEXT1(n, n2, n3, n4, n5, n6, addressof_glWriteMaskEXT);
    }
    
    private native void dispatch_glWriteMaskEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glInsertComponentEXT(final int n, final int n2, final int n3) {
        final long addressof_glInsertComponentEXT = this._pat._addressof_glInsertComponentEXT;
        if (addressof_glInsertComponentEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glInsertComponentEXT"));
        }
        this.dispatch_glInsertComponentEXT1(n, n2, n3, addressof_glInsertComponentEXT);
    }
    
    private native void dispatch_glInsertComponentEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glExtractComponentEXT(final int n, final int n2, final int n3) {
        final long addressof_glExtractComponentEXT = this._pat._addressof_glExtractComponentEXT;
        if (addressof_glExtractComponentEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glExtractComponentEXT"));
        }
        this.dispatch_glExtractComponentEXT1(n, n2, n3, addressof_glExtractComponentEXT);
    }
    
    private native void dispatch_glExtractComponentEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public int glGenSymbolsEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glGenSymbolsEXT = this._pat._addressof_glGenSymbolsEXT;
        if (addressof_glGenSymbolsEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenSymbolsEXT"));
        }
        return this.dispatch_glGenSymbolsEXT1(n, n2, n3, n4, addressof_glGenSymbolsEXT);
    }
    
    private native int dispatch_glGenSymbolsEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glSetInvariantEXT(final int n, final int n2, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glSetInvariantEXT = this._pat._addressof_glSetInvariantEXT;
        if (addressof_glSetInvariantEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSetInvariantEXT"));
        }
        this.dispatch_glSetInvariantEXT1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glSetInvariantEXT);
    }
    
    private native void dispatch_glSetInvariantEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glSetLocalConstantEXT(final int n, final int n2, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glSetLocalConstantEXT = this._pat._addressof_glSetLocalConstantEXT;
        if (addressof_glSetLocalConstantEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSetLocalConstantEXT"));
        }
        this.dispatch_glSetLocalConstantEXT1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glSetLocalConstantEXT);
    }
    
    private native void dispatch_glSetLocalConstantEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glVariantbvEXT(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVariantbvEXT = this._pat._addressof_glVariantbvEXT;
        if (addressof_glVariantbvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantbvEXT"));
        }
        this.dispatch_glVariantbvEXT1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVariantbvEXT);
    }
    
    private native void dispatch_glVariantbvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantbvEXT(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantbvEXT = this._pat._addressof_glVariantbvEXT;
        if (addressof_glVariantbvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantbvEXT"));
        }
        this.dispatch_glVariantbvEXT1(n, array, n2, false, addressof_glVariantbvEXT);
    }
    
    @Override
    public void glVariantsvEXT(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVariantsvEXT = this._pat._addressof_glVariantsvEXT;
        if (addressof_glVariantsvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantsvEXT"));
        }
        this.dispatch_glVariantsvEXT1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVariantsvEXT);
    }
    
    private native void dispatch_glVariantsvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantsvEXT(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantsvEXT = this._pat._addressof_glVariantsvEXT;
        if (addressof_glVariantsvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantsvEXT"));
        }
        this.dispatch_glVariantsvEXT1(n, array, 2 * n2, false, addressof_glVariantsvEXT);
    }
    
    @Override
    public void glVariantivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVariantivEXT = this._pat._addressof_glVariantivEXT;
        if (addressof_glVariantivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantivEXT"));
        }
        this.dispatch_glVariantivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVariantivEXT);
    }
    
    private native void dispatch_glVariantivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantivEXT = this._pat._addressof_glVariantivEXT;
        if (addressof_glVariantivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantivEXT"));
        }
        this.dispatch_glVariantivEXT1(n, array, 4 * n2, false, addressof_glVariantivEXT);
    }
    
    @Override
    public void glVariantfvEXT(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVariantfvEXT = this._pat._addressof_glVariantfvEXT;
        if (addressof_glVariantfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantfvEXT"));
        }
        this.dispatch_glVariantfvEXT1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVariantfvEXT);
    }
    
    private native void dispatch_glVariantfvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantfvEXT(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantfvEXT = this._pat._addressof_glVariantfvEXT;
        if (addressof_glVariantfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantfvEXT"));
        }
        this.dispatch_glVariantfvEXT1(n, array, 4 * n2, false, addressof_glVariantfvEXT);
    }
    
    @Override
    public void glVariantdvEXT(final int n, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVariantdvEXT = this._pat._addressof_glVariantdvEXT;
        if (addressof_glVariantdvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantdvEXT"));
        }
        this.dispatch_glVariantdvEXT1(n, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVariantdvEXT);
    }
    
    private native void dispatch_glVariantdvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantdvEXT(final int n, final double[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantdvEXT = this._pat._addressof_glVariantdvEXT;
        if (addressof_glVariantdvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantdvEXT"));
        }
        this.dispatch_glVariantdvEXT1(n, array, 8 * n2, false, addressof_glVariantdvEXT);
    }
    
    @Override
    public void glVariantubvEXT(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVariantubvEXT = this._pat._addressof_glVariantubvEXT;
        if (addressof_glVariantubvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantubvEXT"));
        }
        this.dispatch_glVariantubvEXT1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVariantubvEXT);
    }
    
    private native void dispatch_glVariantubvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantubvEXT(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantubvEXT = this._pat._addressof_glVariantubvEXT;
        if (addressof_glVariantubvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantubvEXT"));
        }
        this.dispatch_glVariantubvEXT1(n, array, n2, false, addressof_glVariantubvEXT);
    }
    
    @Override
    public void glVariantusvEXT(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVariantusvEXT = this._pat._addressof_glVariantusvEXT;
        if (addressof_glVariantusvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantusvEXT"));
        }
        this.dispatch_glVariantusvEXT1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVariantusvEXT);
    }
    
    private native void dispatch_glVariantusvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantusvEXT(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantusvEXT = this._pat._addressof_glVariantusvEXT;
        if (addressof_glVariantusvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantusvEXT"));
        }
        this.dispatch_glVariantusvEXT1(n, array, 2 * n2, false, addressof_glVariantusvEXT);
    }
    
    @Override
    public void glVariantuivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVariantuivEXT = this._pat._addressof_glVariantuivEXT;
        if (addressof_glVariantuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantuivEXT"));
        }
        this.dispatch_glVariantuivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVariantuivEXT);
    }
    
    private native void dispatch_glVariantuivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVariantuivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"addr_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVariantuivEXT = this._pat._addressof_glVariantuivEXT;
        if (addressof_glVariantuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantuivEXT"));
        }
        this.dispatch_glVariantuivEXT1(n, array, 4 * n2, false, addressof_glVariantuivEXT);
    }
    
    @Override
    public void glVariantPointerEXT(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        Buffers.rangeCheck(buffer, 1);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"addr\" is not a direct buffer");
        }
        final long addressof_glVariantPointerEXT = this._pat._addressof_glVariantPointerEXT;
        if (addressof_glVariantPointerEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantPointerEXT"));
        }
        this.dispatch_glVariantPointerEXT0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glVariantPointerEXT);
    }
    
    private native void dispatch_glVariantPointerEXT0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glVariantPointerEXT(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glVariantPointerEXT = this._pat._addressof_glVariantPointerEXT;
        if (addressof_glVariantPointerEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVariantPointerEXT"));
        }
        this.dispatch_glVariantPointerEXT0(n, n2, n3, n4, addressof_glVariantPointerEXT);
    }
    
    private native void dispatch_glVariantPointerEXT0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glEnableVariantClientStateEXT(final int n) {
        final long addressof_glEnableVariantClientStateEXT = this._pat._addressof_glEnableVariantClientStateEXT;
        if (addressof_glEnableVariantClientStateEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEnableVariantClientStateEXT"));
        }
        this.dispatch_glEnableVariantClientStateEXT1(n, addressof_glEnableVariantClientStateEXT);
    }
    
    private native void dispatch_glEnableVariantClientStateEXT1(final int p0, final long p1);
    
    @Override
    public void glDisableVariantClientStateEXT(final int n) {
        final long addressof_glDisableVariantClientStateEXT = this._pat._addressof_glDisableVariantClientStateEXT;
        if (addressof_glDisableVariantClientStateEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDisableVariantClientStateEXT"));
        }
        this.dispatch_glDisableVariantClientStateEXT1(n, addressof_glDisableVariantClientStateEXT);
    }
    
    private native void dispatch_glDisableVariantClientStateEXT1(final int p0, final long p1);
    
    @Override
    public int glBindLightParameterEXT(final int n, final int n2) {
        final long addressof_glBindLightParameterEXT = this._pat._addressof_glBindLightParameterEXT;
        if (addressof_glBindLightParameterEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindLightParameterEXT"));
        }
        return this.dispatch_glBindLightParameterEXT1(n, n2, addressof_glBindLightParameterEXT);
    }
    
    private native int dispatch_glBindLightParameterEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public int glBindMaterialParameterEXT(final int n, final int n2) {
        final long addressof_glBindMaterialParameterEXT = this._pat._addressof_glBindMaterialParameterEXT;
        if (addressof_glBindMaterialParameterEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindMaterialParameterEXT"));
        }
        return this.dispatch_glBindMaterialParameterEXT1(n, n2, addressof_glBindMaterialParameterEXT);
    }
    
    private native int dispatch_glBindMaterialParameterEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public int glBindTexGenParameterEXT(final int n, final int n2, final int n3) {
        final long addressof_glBindTexGenParameterEXT = this._pat._addressof_glBindTexGenParameterEXT;
        if (addressof_glBindTexGenParameterEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTexGenParameterEXT"));
        }
        return this.dispatch_glBindTexGenParameterEXT1(n, n2, n3, addressof_glBindTexGenParameterEXT);
    }
    
    private native int dispatch_glBindTexGenParameterEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public int glBindTextureUnitParameterEXT(final int n, final int n2) {
        final long addressof_glBindTextureUnitParameterEXT = this._pat._addressof_glBindTextureUnitParameterEXT;
        if (addressof_glBindTextureUnitParameterEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTextureUnitParameterEXT"));
        }
        return this.dispatch_glBindTextureUnitParameterEXT1(n, n2, addressof_glBindTextureUnitParameterEXT);
    }
    
    private native int dispatch_glBindTextureUnitParameterEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public int glBindParameterEXT(final int n) {
        final long addressof_glBindParameterEXT = this._pat._addressof_glBindParameterEXT;
        if (addressof_glBindParameterEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindParameterEXT"));
        }
        return this.dispatch_glBindParameterEXT1(n, addressof_glBindParameterEXT);
    }
    
    private native int dispatch_glBindParameterEXT1(final int p0, final long p1);
    
    @Override
    public boolean glIsVariantEnabledEXT(final int n, final int n2) {
        final long addressof_glIsVariantEnabledEXT = this._pat._addressof_glIsVariantEnabledEXT;
        if (addressof_glIsVariantEnabledEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsVariantEnabledEXT"));
        }
        return this.dispatch_glIsVariantEnabledEXT1(n, n2, addressof_glIsVariantEnabledEXT);
    }
    
    private native boolean dispatch_glIsVariantEnabledEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetVariantBooleanvEXT(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetVariantBooleanvEXT = this._pat._addressof_glGetVariantBooleanvEXT;
        if (addressof_glGetVariantBooleanvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVariantBooleanvEXT"));
        }
        this.dispatch_glGetVariantBooleanvEXT1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetVariantBooleanvEXT);
    }
    
    private native void dispatch_glGetVariantBooleanvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVariantBooleanvEXT(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVariantBooleanvEXT = this._pat._addressof_glGetVariantBooleanvEXT;
        if (addressof_glGetVariantBooleanvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVariantBooleanvEXT"));
        }
        this.dispatch_glGetVariantBooleanvEXT1(n, n2, array, n3, false, addressof_glGetVariantBooleanvEXT);
    }
    
    @Override
    public void glGetVariantIntegervEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVariantIntegervEXT = this._pat._addressof_glGetVariantIntegervEXT;
        if (addressof_glGetVariantIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVariantIntegervEXT"));
        }
        this.dispatch_glGetVariantIntegervEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVariantIntegervEXT);
    }
    
    private native void dispatch_glGetVariantIntegervEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVariantIntegervEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVariantIntegervEXT = this._pat._addressof_glGetVariantIntegervEXT;
        if (addressof_glGetVariantIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVariantIntegervEXT"));
        }
        this.dispatch_glGetVariantIntegervEXT1(n, n2, array, 4 * n3, false, addressof_glGetVariantIntegervEXT);
    }
    
    @Override
    public void glGetVariantFloatvEXT(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetVariantFloatvEXT = this._pat._addressof_glGetVariantFloatvEXT;
        if (addressof_glGetVariantFloatvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVariantFloatvEXT"));
        }
        this.dispatch_glGetVariantFloatvEXT1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetVariantFloatvEXT);
    }
    
    private native void dispatch_glGetVariantFloatvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVariantFloatvEXT(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVariantFloatvEXT = this._pat._addressof_glGetVariantFloatvEXT;
        if (addressof_glGetVariantFloatvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVariantFloatvEXT"));
        }
        this.dispatch_glGetVariantFloatvEXT1(n, n2, array, 4 * n3, false, addressof_glGetVariantFloatvEXT);
    }
    
    @Override
    public void glGetInvariantBooleanvEXT(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetInvariantBooleanvEXT = this._pat._addressof_glGetInvariantBooleanvEXT;
        if (addressof_glGetInvariantBooleanvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantBooleanvEXT"));
        }
        this.dispatch_glGetInvariantBooleanvEXT1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetInvariantBooleanvEXT);
    }
    
    private native void dispatch_glGetInvariantBooleanvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetInvariantBooleanvEXT(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetInvariantBooleanvEXT = this._pat._addressof_glGetInvariantBooleanvEXT;
        if (addressof_glGetInvariantBooleanvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantBooleanvEXT"));
        }
        this.dispatch_glGetInvariantBooleanvEXT1(n, n2, array, n3, false, addressof_glGetInvariantBooleanvEXT);
    }
    
    @Override
    public void glGetInvariantIntegervEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetInvariantIntegervEXT = this._pat._addressof_glGetInvariantIntegervEXT;
        if (addressof_glGetInvariantIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantIntegervEXT"));
        }
        this.dispatch_glGetInvariantIntegervEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetInvariantIntegervEXT);
    }
    
    private native void dispatch_glGetInvariantIntegervEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetInvariantIntegervEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetInvariantIntegervEXT = this._pat._addressof_glGetInvariantIntegervEXT;
        if (addressof_glGetInvariantIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantIntegervEXT"));
        }
        this.dispatch_glGetInvariantIntegervEXT1(n, n2, array, 4 * n3, false, addressof_glGetInvariantIntegervEXT);
    }
    
    @Override
    public void glGetInvariantFloatvEXT(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetInvariantFloatvEXT = this._pat._addressof_glGetInvariantFloatvEXT;
        if (addressof_glGetInvariantFloatvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantFloatvEXT"));
        }
        this.dispatch_glGetInvariantFloatvEXT1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetInvariantFloatvEXT);
    }
    
    private native void dispatch_glGetInvariantFloatvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetInvariantFloatvEXT(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetInvariantFloatvEXT = this._pat._addressof_glGetInvariantFloatvEXT;
        if (addressof_glGetInvariantFloatvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantFloatvEXT"));
        }
        this.dispatch_glGetInvariantFloatvEXT1(n, n2, array, 4 * n3, false, addressof_glGetInvariantFloatvEXT);
    }
    
    @Override
    public void glGetLocalConstantBooleanvEXT(final int n, final int n2, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glGetLocalConstantBooleanvEXT = this._pat._addressof_glGetLocalConstantBooleanvEXT;
        if (addressof_glGetLocalConstantBooleanvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantBooleanvEXT"));
        }
        this.dispatch_glGetLocalConstantBooleanvEXT1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glGetLocalConstantBooleanvEXT);
    }
    
    private native void dispatch_glGetLocalConstantBooleanvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetLocalConstantBooleanvEXT(final int n, final int n2, final byte[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetLocalConstantBooleanvEXT = this._pat._addressof_glGetLocalConstantBooleanvEXT;
        if (addressof_glGetLocalConstantBooleanvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantBooleanvEXT"));
        }
        this.dispatch_glGetLocalConstantBooleanvEXT1(n, n2, array, n3, false, addressof_glGetLocalConstantBooleanvEXT);
    }
    
    @Override
    public void glGetLocalConstantIntegervEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetLocalConstantIntegervEXT = this._pat._addressof_glGetLocalConstantIntegervEXT;
        if (addressof_glGetLocalConstantIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantIntegervEXT"));
        }
        this.dispatch_glGetLocalConstantIntegervEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetLocalConstantIntegervEXT);
    }
    
    private native void dispatch_glGetLocalConstantIntegervEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetLocalConstantIntegervEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetLocalConstantIntegervEXT = this._pat._addressof_glGetLocalConstantIntegervEXT;
        if (addressof_glGetLocalConstantIntegervEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantIntegervEXT"));
        }
        this.dispatch_glGetLocalConstantIntegervEXT1(n, n2, array, 4 * n3, false, addressof_glGetLocalConstantIntegervEXT);
    }
    
    @Override
    public void glGetLocalConstantFloatvEXT(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetLocalConstantFloatvEXT = this._pat._addressof_glGetLocalConstantFloatvEXT;
        if (addressof_glGetLocalConstantFloatvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantFloatvEXT"));
        }
        this.dispatch_glGetLocalConstantFloatvEXT1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetLocalConstantFloatvEXT);
    }
    
    private native void dispatch_glGetLocalConstantFloatvEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetLocalConstantFloatvEXT(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"data_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetLocalConstantFloatvEXT = this._pat._addressof_glGetLocalConstantFloatvEXT;
        if (addressof_glGetLocalConstantFloatvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantFloatvEXT"));
        }
        this.dispatch_glGetLocalConstantFloatvEXT1(n, n2, array, 4 * n3, false, addressof_glGetLocalConstantFloatvEXT);
    }
    
    @Override
    public void glVertexWeightfEXT(final float n) {
        final long addressof_glVertexWeightfEXT = this._pat._addressof_glVertexWeightfEXT;
        if (addressof_glVertexWeightfEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightfEXT"));
        }
        this.dispatch_glVertexWeightfEXT1(n, addressof_glVertexWeightfEXT);
    }
    
    private native void dispatch_glVertexWeightfEXT1(final float p0, final long p1);
    
    @Override
    public void glVertexWeightfvEXT(final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVertexWeightfvEXT = this._pat._addressof_glVertexWeightfvEXT;
        if (addressof_glVertexWeightfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightfvEXT"));
        }
        this.dispatch_glVertexWeightfvEXT1(direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVertexWeightfvEXT);
    }
    
    private native void dispatch_glVertexWeightfvEXT1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertexWeightfvEXT(final float[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"weight_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexWeightfvEXT = this._pat._addressof_glVertexWeightfvEXT;
        if (addressof_glVertexWeightfvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightfvEXT"));
        }
        this.dispatch_glVertexWeightfvEXT1(array, 4 * n, false, addressof_glVertexWeightfvEXT);
    }
    
    @Override
    public void glVertexWeightPointerEXT(final int n, final int n2, final int n3, final Buffer buffer) {
        this.checkArrayVBOUnbound(true);
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glVertexWeightPointerEXT = this._pat._addressof_glVertexWeightPointerEXT;
        if (addressof_glVertexWeightPointerEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightPointerEXT"));
        }
        this.dispatch_glVertexWeightPointerEXT0(n, n2, n3, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glVertexWeightPointerEXT);
    }
    
    private native void dispatch_glVertexWeightPointerEXT0(final int p0, final int p1, final int p2, final Object p3, final int p4, final long p5);
    
    @Override
    public void glVertexWeightPointerEXT(final int n, final int n2, final int n3, final long n4) {
        this.checkArrayVBOBound(true);
        final long addressof_glVertexWeightPointerEXT = this._pat._addressof_glVertexWeightPointerEXT;
        if (addressof_glVertexWeightPointerEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightPointerEXT"));
        }
        this.dispatch_glVertexWeightPointerEXT0(n, n2, n3, n4, addressof_glVertexWeightPointerEXT);
    }
    
    private native void dispatch_glVertexWeightPointerEXT0(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public long glImportSyncEXT(final int n, final long n2, final int n3) {
        final long addressof_glImportSyncEXT = this._pat._addressof_glImportSyncEXT;
        if (addressof_glImportSyncEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glImportSyncEXT"));
        }
        return this.dispatch_glImportSyncEXT1(n, n2, n3, addressof_glImportSyncEXT);
    }
    
    private native long dispatch_glImportSyncEXT1(final int p0, final long p1, final int p2, final long p3);
    
    @Override
    public void glFrameTerminatorGREMEDY() {
        final long addressof_glFrameTerminatorGREMEDY = this._pat._addressof_glFrameTerminatorGREMEDY;
        if (addressof_glFrameTerminatorGREMEDY == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFrameTerminatorGREMEDY"));
        }
        this.dispatch_glFrameTerminatorGREMEDY1(addressof_glFrameTerminatorGREMEDY);
    }
    
    private native void dispatch_glFrameTerminatorGREMEDY1(final long p0);
    
    @Override
    public void glStringMarkerGREMEDY(final int n, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glStringMarkerGREMEDY = this._pat._addressof_glStringMarkerGREMEDY;
        if (addressof_glStringMarkerGREMEDY == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStringMarkerGREMEDY"));
        }
        this.dispatch_glStringMarkerGREMEDY1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glStringMarkerGREMEDY);
    }
    
    private native void dispatch_glStringMarkerGREMEDY1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glBlendFuncSeparateINGR(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glBlendFuncSeparateINGR = this._pat._addressof_glBlendFuncSeparateINGR;
        if (addressof_glBlendFuncSeparateINGR == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparateINGR"));
        }
        this.dispatch_glBlendFuncSeparateINGR1(n, n2, n3, n4, addressof_glBlendFuncSeparateINGR);
    }
    
    private native void dispatch_glBlendFuncSeparateINGR1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glApplyFramebufferAttachmentCMAAINTEL() {
        final long addressof_glApplyFramebufferAttachmentCMAAINTEL = this._pat._addressof_glApplyFramebufferAttachmentCMAAINTEL;
        if (addressof_glApplyFramebufferAttachmentCMAAINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glApplyFramebufferAttachmentCMAAINTEL"));
        }
        this.dispatch_glApplyFramebufferAttachmentCMAAINTEL1(addressof_glApplyFramebufferAttachmentCMAAINTEL);
    }
    
    private native void dispatch_glApplyFramebufferAttachmentCMAAINTEL1(final long p0);
    
    @Override
    public void glSyncTextureINTEL(final int n) {
        final long addressof_glSyncTextureINTEL = this._pat._addressof_glSyncTextureINTEL;
        if (addressof_glSyncTextureINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSyncTextureINTEL"));
        }
        this.dispatch_glSyncTextureINTEL1(n, addressof_glSyncTextureINTEL);
    }
    
    private native void dispatch_glSyncTextureINTEL1(final int p0, final long p1);
    
    @Override
    public void glUnmapTexture2DINTEL(final int n, final int n2) {
        final long addressof_glUnmapTexture2DINTEL = this._pat._addressof_glUnmapTexture2DINTEL;
        if (addressof_glUnmapTexture2DINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUnmapTexture2DINTEL"));
        }
        this.dispatch_glUnmapTexture2DINTEL1(n, n2, addressof_glUnmapTexture2DINTEL);
    }
    
    private native void dispatch_glUnmapTexture2DINTEL1(final int p0, final int p1, final long p2);
    
    @Override
    public ByteBuffer glMapTexture2DINTEL(final int n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glMapTexture2DINTEL = this._pat._addressof_glMapTexture2DINTEL;
        if (addressof_glMapTexture2DINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapTexture2DINTEL"));
        }
        final ByteBuffer dispatch_glMapTexture2DINTEL1 = this.dispatch_glMapTexture2DINTEL1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glMapTexture2DINTEL);
        if (dispatch_glMapTexture2DINTEL1 == null) {
            return null;
        }
        Buffers.nativeOrder(dispatch_glMapTexture2DINTEL1);
        return dispatch_glMapTexture2DINTEL1;
    }
    
    private native ByteBuffer dispatch_glMapTexture2DINTEL1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public ByteBuffer glMapTexture2DINTEL(final int n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"stride_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"layout_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glMapTexture2DINTEL = this._pat._addressof_glMapTexture2DINTEL;
        if (addressof_glMapTexture2DINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapTexture2DINTEL"));
        }
        final ByteBuffer dispatch_glMapTexture2DINTEL1 = this.dispatch_glMapTexture2DINTEL1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, addressof_glMapTexture2DINTEL);
        if (dispatch_glMapTexture2DINTEL1 == null) {
            return null;
        }
        Buffers.nativeOrder(dispatch_glMapTexture2DINTEL1);
        return dispatch_glMapTexture2DINTEL1;
    }
    
    @Override
    public void glBeginPerfQueryINTEL(final int n) {
        final long addressof_glBeginPerfQueryINTEL = this._pat._addressof_glBeginPerfQueryINTEL;
        if (addressof_glBeginPerfQueryINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginPerfQueryINTEL"));
        }
        this.dispatch_glBeginPerfQueryINTEL1(n, addressof_glBeginPerfQueryINTEL);
    }
    
    private native void dispatch_glBeginPerfQueryINTEL1(final int p0, final long p1);
    
    @Override
    public void glCreatePerfQueryINTEL(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreatePerfQueryINTEL = this._pat._addressof_glCreatePerfQueryINTEL;
        if (addressof_glCreatePerfQueryINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreatePerfQueryINTEL"));
        }
        this.dispatch_glCreatePerfQueryINTEL1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreatePerfQueryINTEL);
    }
    
    private native void dispatch_glCreatePerfQueryINTEL1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreatePerfQueryINTEL(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"queryHandle_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreatePerfQueryINTEL = this._pat._addressof_glCreatePerfQueryINTEL;
        if (addressof_glCreatePerfQueryINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreatePerfQueryINTEL"));
        }
        this.dispatch_glCreatePerfQueryINTEL1(n, array, 4 * n2, false, addressof_glCreatePerfQueryINTEL);
    }
    
    @Override
    public void glDeletePerfQueryINTEL(final int n) {
        final long addressof_glDeletePerfQueryINTEL = this._pat._addressof_glDeletePerfQueryINTEL;
        if (addressof_glDeletePerfQueryINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfQueryINTEL"));
        }
        this.dispatch_glDeletePerfQueryINTEL1(n, addressof_glDeletePerfQueryINTEL);
    }
    
    private native void dispatch_glDeletePerfQueryINTEL1(final int p0, final long p1);
    
    @Override
    public void glEndPerfQueryINTEL(final int n) {
        final long addressof_glEndPerfQueryINTEL = this._pat._addressof_glEndPerfQueryINTEL;
        if (addressof_glEndPerfQueryINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndPerfQueryINTEL"));
        }
        this.dispatch_glEndPerfQueryINTEL1(n, addressof_glEndPerfQueryINTEL);
    }
    
    private native void dispatch_glEndPerfQueryINTEL1(final int p0, final long p1);
    
    @Override
    public void glGetFirstPerfQueryIdINTEL(final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetFirstPerfQueryIdINTEL = this._pat._addressof_glGetFirstPerfQueryIdINTEL;
        if (addressof_glGetFirstPerfQueryIdINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFirstPerfQueryIdINTEL"));
        }
        this.dispatch_glGetFirstPerfQueryIdINTEL1(direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetFirstPerfQueryIdINTEL);
    }
    
    private native void dispatch_glGetFirstPerfQueryIdINTEL1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glGetFirstPerfQueryIdINTEL(final int[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"queryId_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetFirstPerfQueryIdINTEL = this._pat._addressof_glGetFirstPerfQueryIdINTEL;
        if (addressof_glGetFirstPerfQueryIdINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetFirstPerfQueryIdINTEL"));
        }
        this.dispatch_glGetFirstPerfQueryIdINTEL1(array, 4 * n, false, addressof_glGetFirstPerfQueryIdINTEL);
    }
    
    @Override
    public void glGetNextPerfQueryIdINTEL(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetNextPerfQueryIdINTEL = this._pat._addressof_glGetNextPerfQueryIdINTEL;
        if (addressof_glGetNextPerfQueryIdINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNextPerfQueryIdINTEL"));
        }
        this.dispatch_glGetNextPerfQueryIdINTEL1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetNextPerfQueryIdINTEL);
    }
    
    private native void dispatch_glGetNextPerfQueryIdINTEL1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetNextPerfQueryIdINTEL(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"nextQueryId_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNextPerfQueryIdINTEL = this._pat._addressof_glGetNextPerfQueryIdINTEL;
        if (addressof_glGetNextPerfQueryIdINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNextPerfQueryIdINTEL"));
        }
        this.dispatch_glGetNextPerfQueryIdINTEL1(n, array, 4 * n2, false, addressof_glGetNextPerfQueryIdINTEL);
    }
    
    @Override
    public void glGetPerfCounterInfoINTEL(final int n, final int n2, final int n3, final ByteBuffer byteBuffer, final int n4, final ByteBuffer byteBuffer2, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final IntBuffer intBuffer4, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final boolean direct2 = Buffers.isDirect(byteBuffer2);
        final boolean direct3 = Buffers.isDirect(intBuffer);
        final boolean direct4 = Buffers.isDirect(intBuffer2);
        final boolean direct5 = Buffers.isDirect(intBuffer3);
        final boolean direct6 = Buffers.isDirect(intBuffer4);
        final boolean direct7 = Buffers.isDirect(longBuffer);
        final long addressof_glGetPerfCounterInfoINTEL = this._pat._addressof_glGetPerfCounterInfoINTEL;
        if (addressof_glGetPerfCounterInfoINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfCounterInfoINTEL"));
        }
        this.dispatch_glGetPerfCounterInfoINTEL1(n, n2, n3, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, n4, direct2 ? byteBuffer2 : Buffers.getArray(byteBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(byteBuffer2) : Buffers.getIndirectBufferByteOffset(byteBuffer2), direct2, direct3 ? intBuffer : Buffers.getArray(intBuffer), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct3, direct4 ? intBuffer2 : Buffers.getArray(intBuffer2), direct4 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct4, direct5 ? intBuffer3 : Buffers.getArray(intBuffer3), direct5 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct5, direct6 ? intBuffer4 : Buffers.getArray(intBuffer4), direct6 ? Buffers.getDirectBufferByteOffset(intBuffer4) : Buffers.getIndirectBufferByteOffset(intBuffer4), direct6, direct7 ? longBuffer : Buffers.getArray(longBuffer), direct7 ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct7, addressof_glGetPerfCounterInfoINTEL);
    }
    
    private native void dispatch_glGetPerfCounterInfoINTEL1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final int p6, final Object p7, final int p8, final boolean p9, final Object p10, final int p11, final boolean p12, final Object p13, final int p14, final boolean p15, final Object p16, final int p17, final boolean p18, final Object p19, final int p20, final boolean p21, final Object p22, final int p23, final boolean p24, final long p25);
    
    @Override
    public void glGetPerfCounterInfoINTEL(final int n, final int n2, final int n3, final byte[] array, final int n4, final int n5, final byte[] array2, final int n6, final int[] array3, final int n7, final int[] array4, final int n8, final int[] array5, final int n9, final int[] array6, final int n10, final long[] array7, final int n11) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"counterName_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n6) {
            throw new GLException("array offset argument \"counterDesc_offset\" (" + n6 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n7) {
            throw new GLException("array offset argument \"counterOffset_offset\" (" + n7 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n8) {
            throw new GLException("array offset argument \"counterDataSize_offset\" (" + n8 + ") equals or exceeds array length (" + array4.length + ")");
        }
        if (array5 != null && array5.length <= n9) {
            throw new GLException("array offset argument \"counterTypeEnum_offset\" (" + n9 + ") equals or exceeds array length (" + array5.length + ")");
        }
        if (array6 != null && array6.length <= n10) {
            throw new GLException("array offset argument \"counterDataTypeEnum_offset\" (" + n10 + ") equals or exceeds array length (" + array6.length + ")");
        }
        if (array7 != null && array7.length <= n11) {
            throw new GLException("array offset argument \"rawCounterMaxValue_offset\" (" + n11 + ") equals or exceeds array length (" + array7.length + ")");
        }
        final long addressof_glGetPerfCounterInfoINTEL = this._pat._addressof_glGetPerfCounterInfoINTEL;
        if (addressof_glGetPerfCounterInfoINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfCounterInfoINTEL"));
        }
        this.dispatch_glGetPerfCounterInfoINTEL1(n, n2, n3, array, n4, false, n5, array2, n6, false, array3, 4 * n7, false, array4, 4 * n8, false, array5, 4 * n9, false, array6, 4 * n10, false, array7, 8 * n11, false, addressof_glGetPerfCounterInfoINTEL);
    }
    
    @Override
    public void glGetPerfQueryDataINTEL(final int n, final int n2, final int n3, final Buffer buffer, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final long addressof_glGetPerfQueryDataINTEL = this._pat._addressof_glGetPerfQueryDataINTEL;
        if (addressof_glGetPerfQueryDataINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryDataINTEL"));
        }
        this.dispatch_glGetPerfQueryDataINTEL1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, addressof_glGetPerfQueryDataINTEL);
    }
    
    private native void dispatch_glGetPerfQueryDataINTEL1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetPerfQueryDataINTEL(final int n, final int n2, final int n3, final Buffer buffer, final int[] array, final int n4) {
        final boolean direct = Buffers.isDirect(buffer);
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"bytesWritten_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetPerfQueryDataINTEL = this._pat._addressof_glGetPerfQueryDataINTEL;
        if (addressof_glGetPerfQueryDataINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryDataINTEL"));
        }
        this.dispatch_glGetPerfQueryDataINTEL1(n, n2, n3, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, array, 4 * n4, false, addressof_glGetPerfQueryDataINTEL);
    }
    
    @Override
    public void glGetPerfQueryIdByNameINTEL(final ByteBuffer byteBuffer, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final long addressof_glGetPerfQueryIdByNameINTEL = this._pat._addressof_glGetPerfQueryIdByNameINTEL;
        if (addressof_glGetPerfQueryIdByNameINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryIdByNameINTEL"));
        }
        this.dispatch_glGetPerfQueryIdByNameINTEL1(direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, addressof_glGetPerfQueryIdByNameINTEL);
    }
    
    private native void dispatch_glGetPerfQueryIdByNameINTEL1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetPerfQueryIdByNameINTEL(final byte[] array, final int n, final int[] array2, final int n2) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"queryName_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n2) {
            throw new GLException("array offset argument \"queryId_offset\" (" + n2 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glGetPerfQueryIdByNameINTEL = this._pat._addressof_glGetPerfQueryIdByNameINTEL;
        if (addressof_glGetPerfQueryIdByNameINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryIdByNameINTEL"));
        }
        this.dispatch_glGetPerfQueryIdByNameINTEL1(array, n, false, array2, 4 * n2, false, addressof_glGetPerfQueryIdByNameINTEL);
    }
    
    @Override
    public void glGetPerfQueryInfoINTEL(final int n, final int n2, final ByteBuffer byteBuffer, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final IntBuffer intBuffer4) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final boolean direct3 = Buffers.isDirect(intBuffer2);
        final boolean direct4 = Buffers.isDirect(intBuffer3);
        final boolean direct5 = Buffers.isDirect(intBuffer4);
        final long addressof_glGetPerfQueryInfoINTEL = this._pat._addressof_glGetPerfQueryInfoINTEL;
        if (addressof_glGetPerfQueryInfoINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryInfoINTEL"));
        }
        this.dispatch_glGetPerfQueryInfoINTEL1(n, n2, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, direct3 ? intBuffer2 : Buffers.getArray(intBuffer2), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct3, direct4 ? intBuffer3 : Buffers.getArray(intBuffer3), direct4 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct4, direct5 ? intBuffer4 : Buffers.getArray(intBuffer4), direct5 ? Buffers.getDirectBufferByteOffset(intBuffer4) : Buffers.getIndirectBufferByteOffset(intBuffer4), direct5, addressof_glGetPerfQueryInfoINTEL);
    }
    
    private native void dispatch_glGetPerfQueryInfoINTEL1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final Object p8, final int p9, final boolean p10, final Object p11, final int p12, final boolean p13, final Object p14, final int p15, final boolean p16, final long p17);
    
    @Override
    public void glGetPerfQueryInfoINTEL(final int n, final int n2, final byte[] array, final int n3, final int[] array2, final int n4, final int[] array3, final int n5, final int[] array4, final int n6, final int[] array5, final int n7) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"queryName_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"dataSize_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n5) {
            throw new GLException("array offset argument \"noCounters_offset\" (" + n5 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n6) {
            throw new GLException("array offset argument \"noInstances_offset\" (" + n6 + ") equals or exceeds array length (" + array4.length + ")");
        }
        if (array5 != null && array5.length <= n7) {
            throw new GLException("array offset argument \"capsMask_offset\" (" + n7 + ") equals or exceeds array length (" + array5.length + ")");
        }
        final long addressof_glGetPerfQueryInfoINTEL = this._pat._addressof_glGetPerfQueryInfoINTEL;
        if (addressof_glGetPerfQueryInfoINTEL == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryInfoINTEL"));
        }
        this.dispatch_glGetPerfQueryInfoINTEL1(n, n2, array, n3, false, array2, 4 * n4, false, array3, 4 * n5, false, array4, 4 * n6, false, array5, 4 * n7, false, addressof_glGetPerfQueryInfoINTEL);
    }
    
    @Override
    public void glBeginConditionalRenderNVX(final int n) {
        final long addressof_glBeginConditionalRenderNVX = this._pat._addressof_glBeginConditionalRenderNVX;
        if (addressof_glBeginConditionalRenderNVX == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginConditionalRenderNVX"));
        }
        this.dispatch_glBeginConditionalRenderNVX1(n, addressof_glBeginConditionalRenderNVX);
    }
    
    private native void dispatch_glBeginConditionalRenderNVX1(final int p0, final long p1);
    
    @Override
    public void glEndConditionalRenderNVX() {
        final long addressof_glEndConditionalRenderNVX = this._pat._addressof_glEndConditionalRenderNVX;
        if (addressof_glEndConditionalRenderNVX == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndConditionalRenderNVX"));
        }
        this.dispatch_glEndConditionalRenderNVX1(addressof_glEndConditionalRenderNVX);
    }
    
    private native void dispatch_glEndConditionalRenderNVX1(final long p0);
    
    @Override
    public void glMultiDrawArraysIndirectBindlessNV(final int n, final Buffer buffer, final int n2, final int n3, final int n4) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawArraysIndirectBindlessNV = this._pat._addressof_glMultiDrawArraysIndirectBindlessNV;
        if (addressof_glMultiDrawArraysIndirectBindlessNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectBindlessNV"));
        }
        this.dispatch_glMultiDrawArraysIndirectBindlessNV1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n2, n3, n4, addressof_glMultiDrawArraysIndirectBindlessNV);
    }
    
    private native void dispatch_glMultiDrawArraysIndirectBindlessNV1(final int p0, final Object p1, final int p2, final boolean p3, final int p4, final int p5, final int p6, final long p7);
    
    @Override
    public void glMultiDrawElementsIndirectBindlessNV(final int n, final int n2, final Buffer buffer, final int n3, final int n4, final int n5) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawElementsIndirectBindlessNV = this._pat._addressof_glMultiDrawElementsIndirectBindlessNV;
        if (addressof_glMultiDrawElementsIndirectBindlessNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectBindlessNV"));
        }
        this.dispatch_glMultiDrawElementsIndirectBindlessNV1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, n4, n5, addressof_glMultiDrawElementsIndirectBindlessNV);
    }
    
    private native void dispatch_glMultiDrawElementsIndirectBindlessNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glMultiDrawArraysIndirectBindlessCountNV(final int n, final Buffer buffer, final int n2, final int n3, final int n4, final int n5) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawArraysIndirectBindlessCountNV = this._pat._addressof_glMultiDrawArraysIndirectBindlessCountNV;
        if (addressof_glMultiDrawArraysIndirectBindlessCountNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectBindlessCountNV"));
        }
        this.dispatch_glMultiDrawArraysIndirectBindlessCountNV1(n, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n2, n3, n4, n5, addressof_glMultiDrawArraysIndirectBindlessCountNV);
    }
    
    private native void dispatch_glMultiDrawArraysIndirectBindlessCountNV1(final int p0, final Object p1, final int p2, final boolean p3, final int p4, final int p5, final int p6, final int p7, final long p8);
    
    @Override
    public void glMultiDrawElementsIndirectBindlessCountNV(final int n, final int n2, final Buffer buffer, final int n3, final int n4, final int n5, final int n6) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMultiDrawElementsIndirectBindlessCountNV = this._pat._addressof_glMultiDrawElementsIndirectBindlessCountNV;
        if (addressof_glMultiDrawElementsIndirectBindlessCountNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectBindlessCountNV"));
        }
        this.dispatch_glMultiDrawElementsIndirectBindlessCountNV1(n, n2, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n3, n4, n5, n6, addressof_glMultiDrawElementsIndirectBindlessCountNV);
    }
    
    private native void dispatch_glMultiDrawElementsIndirectBindlessCountNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final int p5, final int p6, final int p7, final int p8, final long p9);
    
    @Override
    public void glCreateStatesNV(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateStatesNV = this._pat._addressof_glCreateStatesNV;
        if (addressof_glCreateStatesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateStatesNV"));
        }
        this.dispatch_glCreateStatesNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateStatesNV);
    }
    
    private native void dispatch_glCreateStatesNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateStatesNV(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"states_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateStatesNV = this._pat._addressof_glCreateStatesNV;
        if (addressof_glCreateStatesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateStatesNV"));
        }
        this.dispatch_glCreateStatesNV1(n, array, 4 * n2, false, addressof_glCreateStatesNV);
    }
    
    @Override
    public void glDeleteStatesNV(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteStatesNV = this._pat._addressof_glDeleteStatesNV;
        if (addressof_glDeleteStatesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteStatesNV"));
        }
        this.dispatch_glDeleteStatesNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteStatesNV);
    }
    
    private native void dispatch_glDeleteStatesNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteStatesNV(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"states_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteStatesNV = this._pat._addressof_glDeleteStatesNV;
        if (addressof_glDeleteStatesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteStatesNV"));
        }
        this.dispatch_glDeleteStatesNV1(n, array, 4 * n2, false, addressof_glDeleteStatesNV);
    }
    
    @Override
    public boolean glIsStateNV(final int n) {
        final long addressof_glIsStateNV = this._pat._addressof_glIsStateNV;
        if (addressof_glIsStateNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsStateNV"));
        }
        return this.dispatch_glIsStateNV1(n, addressof_glIsStateNV);
    }
    
    private native boolean dispatch_glIsStateNV1(final int p0, final long p1);
    
    @Override
    public void glStateCaptureNV(final int n, final int n2) {
        final long addressof_glStateCaptureNV = this._pat._addressof_glStateCaptureNV;
        if (addressof_glStateCaptureNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glStateCaptureNV"));
        }
        this.dispatch_glStateCaptureNV1(n, n2, addressof_glStateCaptureNV);
    }
    
    private native void dispatch_glStateCaptureNV1(final int p0, final int p1, final long p2);
    
    @Override
    public int glGetCommandHeaderNV(final int n, final int n2) {
        final long addressof_glGetCommandHeaderNV = this._pat._addressof_glGetCommandHeaderNV;
        if (addressof_glGetCommandHeaderNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCommandHeaderNV"));
        }
        return this.dispatch_glGetCommandHeaderNV1(n, n2, addressof_glGetCommandHeaderNV);
    }
    
    private native int dispatch_glGetCommandHeaderNV1(final int p0, final int p1, final long p2);
    
    @Override
    public short glGetStageIndexNV(final int n) {
        final long addressof_glGetStageIndexNV = this._pat._addressof_glGetStageIndexNV;
        if (addressof_glGetStageIndexNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetStageIndexNV"));
        }
        return this.dispatch_glGetStageIndexNV1(n, addressof_glGetStageIndexNV);
    }
    
    private native short dispatch_glGetStageIndexNV1(final int p0, final long p1);
    
    @Override
    public void glDrawCommandsNV(final int n, final int n2, final PointerBuffer pointerBuffer, final IntBuffer intBuffer, final int n3) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final long addressof_glDrawCommandsNV = this._pat._addressof_glDrawCommandsNV;
        if (addressof_glDrawCommandsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsNV"));
        }
        this.dispatch_glDrawCommandsNV1(n, n2, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, n3, addressof_glDrawCommandsNV);
    }
    
    private native void dispatch_glDrawCommandsNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final int p8, final long p9);
    
    @Override
    public void glDrawCommandsNV(final int n, final int n2, final PointerBuffer pointerBuffer, final int[] array, final int n3, final int n4) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"sizes_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDrawCommandsNV = this._pat._addressof_glDrawCommandsNV;
        if (addressof_glDrawCommandsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsNV"));
        }
        this.dispatch_glDrawCommandsNV1(n, n2, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, array, 4 * n3, false, n4, addressof_glDrawCommandsNV);
    }
    
    @Override
    public void glDrawCommandsAddressNV(final int n, final LongBuffer longBuffer, final IntBuffer intBuffer, final int n2) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final long addressof_glDrawCommandsAddressNV = this._pat._addressof_glDrawCommandsAddressNV;
        if (addressof_glDrawCommandsAddressNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsAddressNV"));
        }
        this.dispatch_glDrawCommandsAddressNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, n2, addressof_glDrawCommandsAddressNV);
    }
    
    private native void dispatch_glDrawCommandsAddressNV1(final int p0, final Object p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final int p7, final long p8);
    
    @Override
    public void glDrawCommandsAddressNV(final int n, final long[] array, final int n2, final int[] array2, final int n3, final int n4) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"indirects_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"sizes_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glDrawCommandsAddressNV = this._pat._addressof_glDrawCommandsAddressNV;
        if (addressof_glDrawCommandsAddressNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsAddressNV"));
        }
        this.dispatch_glDrawCommandsAddressNV1(n, array, 8 * n2, false, array2, 4 * n3, false, n4, addressof_glDrawCommandsAddressNV);
    }
    
    @Override
    public void glDrawCommandsStatesNV(final int n, final PointerBuffer pointerBuffer, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final int n2) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final boolean direct3 = Buffers.isDirect(intBuffer2);
        final boolean direct4 = Buffers.isDirect(intBuffer3);
        final long addressof_glDrawCommandsStatesNV = this._pat._addressof_glDrawCommandsStatesNV;
        if (addressof_glDrawCommandsStatesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesNV"));
        }
        this.dispatch_glDrawCommandsStatesNV1(n, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, direct3 ? intBuffer2 : Buffers.getArray(intBuffer2), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct3, direct4 ? intBuffer3 : Buffers.getArray(intBuffer3), direct4 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct4, n2, addressof_glDrawCommandsStatesNV);
    }
    
    private native void dispatch_glDrawCommandsStatesNV1(final int p0, final Object p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final Object p7, final int p8, final boolean p9, final Object p10, final int p11, final boolean p12, final int p13, final long p14);
    
    @Override
    public void glDrawCommandsStatesNV(final int n, final PointerBuffer pointerBuffer, final int[] array, final int n2, final int[] array2, final int n3, final int[] array3, final int n4, final int n5) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"sizes_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"states_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n4) {
            throw new GLException("array offset argument \"fbos_offset\" (" + n4 + ") equals or exceeds array length (" + array3.length + ")");
        }
        final long addressof_glDrawCommandsStatesNV = this._pat._addressof_glDrawCommandsStatesNV;
        if (addressof_glDrawCommandsStatesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesNV"));
        }
        this.dispatch_glDrawCommandsStatesNV1(n, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, array, 4 * n2, false, array2, 4 * n3, false, array3, 4 * n4, false, n5, addressof_glDrawCommandsStatesNV);
    }
    
    @Override
    public void glDrawCommandsStatesAddressNV(final LongBuffer longBuffer, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final int n) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final boolean direct3 = Buffers.isDirect(intBuffer2);
        final boolean direct4 = Buffers.isDirect(intBuffer3);
        final long addressof_glDrawCommandsStatesAddressNV = this._pat._addressof_glDrawCommandsStatesAddressNV;
        if (addressof_glDrawCommandsStatesAddressNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesAddressNV"));
        }
        this.dispatch_glDrawCommandsStatesAddressNV1(direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, direct3 ? intBuffer2 : Buffers.getArray(intBuffer2), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct3, direct4 ? intBuffer3 : Buffers.getArray(intBuffer3), direct4 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct4, n, addressof_glDrawCommandsStatesAddressNV);
    }
    
    private native void dispatch_glDrawCommandsStatesAddressNV1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final Object p9, final int p10, final boolean p11, final int p12, final long p13);
    
    @Override
    public void glDrawCommandsStatesAddressNV(final long[] array, final int n, final int[] array2, final int n2, final int[] array3, final int n3, final int[] array4, final int n4, final int n5) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"indirects_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n2) {
            throw new GLException("array offset argument \"sizes_offset\" (" + n2 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n3) {
            throw new GLException("array offset argument \"states_offset\" (" + n3 + ") equals or exceeds array length (" + array3.length + ")");
        }
        if (array4 != null && array4.length <= n4) {
            throw new GLException("array offset argument \"fbos_offset\" (" + n4 + ") equals or exceeds array length (" + array4.length + ")");
        }
        final long addressof_glDrawCommandsStatesAddressNV = this._pat._addressof_glDrawCommandsStatesAddressNV;
        if (addressof_glDrawCommandsStatesAddressNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesAddressNV"));
        }
        this.dispatch_glDrawCommandsStatesAddressNV1(array, 8 * n, false, array2, 4 * n2, false, array3, 4 * n3, false, array4, 4 * n4, false, n5, addressof_glDrawCommandsStatesAddressNV);
    }
    
    @Override
    public void glCreateCommandListsNV(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glCreateCommandListsNV = this._pat._addressof_glCreateCommandListsNV;
        if (addressof_glCreateCommandListsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateCommandListsNV"));
        }
        this.dispatch_glCreateCommandListsNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glCreateCommandListsNV);
    }
    
    private native void dispatch_glCreateCommandListsNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCreateCommandListsNV(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"lists_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCreateCommandListsNV = this._pat._addressof_glCreateCommandListsNV;
        if (addressof_glCreateCommandListsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCreateCommandListsNV"));
        }
        this.dispatch_glCreateCommandListsNV1(n, array, 4 * n2, false, addressof_glCreateCommandListsNV);
    }
    
    @Override
    public void glDeleteCommandListsNV(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteCommandListsNV = this._pat._addressof_glDeleteCommandListsNV;
        if (addressof_glDeleteCommandListsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteCommandListsNV"));
        }
        this.dispatch_glDeleteCommandListsNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteCommandListsNV);
    }
    
    private native void dispatch_glDeleteCommandListsNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteCommandListsNV(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"lists_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteCommandListsNV = this._pat._addressof_glDeleteCommandListsNV;
        if (addressof_glDeleteCommandListsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteCommandListsNV"));
        }
        this.dispatch_glDeleteCommandListsNV1(n, array, 4 * n2, false, addressof_glDeleteCommandListsNV);
    }
    
    @Override
    public boolean glIsCommandListNV(final int n) {
        final long addressof_glIsCommandListNV = this._pat._addressof_glIsCommandListNV;
        if (addressof_glIsCommandListNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsCommandListNV"));
        }
        return this.dispatch_glIsCommandListNV1(n, addressof_glIsCommandListNV);
    }
    
    private native boolean dispatch_glIsCommandListNV1(final int p0, final long p1);
    
    @Override
    public void glListDrawCommandsStatesClientNV(final int n, final int n2, final PointerBuffer pointerBuffer, final IntBuffer intBuffer, final IntBuffer intBuffer2, final IntBuffer intBuffer3, final int n3) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final boolean direct3 = Buffers.isDirect(intBuffer2);
        final boolean direct4 = Buffers.isDirect(intBuffer3);
        final long addressof_glListDrawCommandsStatesClientNV = this._pat._addressof_glListDrawCommandsStatesClientNV;
        if (addressof_glListDrawCommandsStatesClientNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glListDrawCommandsStatesClientNV"));
        }
        this.dispatch_glListDrawCommandsStatesClientNV1(n, n2, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, direct3 ? intBuffer2 : Buffers.getArray(intBuffer2), direct3 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct3, direct4 ? intBuffer3 : Buffers.getArray(intBuffer3), direct4 ? Buffers.getDirectBufferByteOffset(intBuffer3) : Buffers.getIndirectBufferByteOffset(intBuffer3), direct4, n3, addressof_glListDrawCommandsStatesClientNV);
    }
    
    private native void dispatch_glListDrawCommandsStatesClientNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final Object p5, final int p6, final boolean p7, final Object p8, final int p9, final boolean p10, final Object p11, final int p12, final boolean p13, final int p14, final long p15);
    
    @Override
    public void glListDrawCommandsStatesClientNV(final int n, final int n2, final PointerBuffer pointerBuffer, final int[] array, final int n3, final int[] array2, final int n4, final int[] array3, final int n5, final int n6) {
        final boolean direct = Buffers.isDirect(pointerBuffer);
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"sizes_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n4) {
            throw new GLException("array offset argument \"states_offset\" (" + n4 + ") equals or exceeds array length (" + array2.length + ")");
        }
        if (array3 != null && array3.length <= n5) {
            throw new GLException("array offset argument \"fbos_offset\" (" + n5 + ") equals or exceeds array length (" + array3.length + ")");
        }
        final long addressof_glListDrawCommandsStatesClientNV = this._pat._addressof_glListDrawCommandsStatesClientNV;
        if (addressof_glListDrawCommandsStatesClientNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glListDrawCommandsStatesClientNV"));
        }
        this.dispatch_glListDrawCommandsStatesClientNV1(n, n2, direct ? ((pointerBuffer != null) ? pointerBuffer.getBuffer() : null) : Buffers.getArray(pointerBuffer), direct ? Buffers.getDirectBufferByteOffset(pointerBuffer) : Buffers.getIndirectBufferByteOffset(pointerBuffer), direct, array, 4 * n3, false, array2, 4 * n4, false, array3, 4 * n5, false, n6, addressof_glListDrawCommandsStatesClientNV);
    }
    
    @Override
    public void glCommandListSegmentsNV(final int n, final int n2) {
        final long addressof_glCommandListSegmentsNV = this._pat._addressof_glCommandListSegmentsNV;
        if (addressof_glCommandListSegmentsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCommandListSegmentsNV"));
        }
        this.dispatch_glCommandListSegmentsNV1(n, n2, addressof_glCommandListSegmentsNV);
    }
    
    private native void dispatch_glCommandListSegmentsNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glCompileCommandListNV(final int n) {
        final long addressof_glCompileCommandListNV = this._pat._addressof_glCompileCommandListNV;
        if (addressof_glCompileCommandListNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCompileCommandListNV"));
        }
        this.dispatch_glCompileCommandListNV1(n, addressof_glCompileCommandListNV);
    }
    
    private native void dispatch_glCompileCommandListNV1(final int p0, final long p1);
    
    @Override
    public void glCallCommandListNV(final int n) {
        final long addressof_glCallCommandListNV = this._pat._addressof_glCallCommandListNV;
        if (addressof_glCallCommandListNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCallCommandListNV"));
        }
        this.dispatch_glCallCommandListNV1(n, addressof_glCallCommandListNV);
    }
    
    private native void dispatch_glCallCommandListNV1(final int p0, final long p1);
    
    @Override
    public void glSubpixelPrecisionBiasNV(final int n, final int n2) {
        final long addressof_glSubpixelPrecisionBiasNV = this._pat._addressof_glSubpixelPrecisionBiasNV;
        if (addressof_glSubpixelPrecisionBiasNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSubpixelPrecisionBiasNV"));
        }
        this.dispatch_glSubpixelPrecisionBiasNV1(n, n2, addressof_glSubpixelPrecisionBiasNV);
    }
    
    private native void dispatch_glSubpixelPrecisionBiasNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glConservativeRasterParameterfNV(final int n, final float n2) {
        final long addressof_glConservativeRasterParameterfNV = this._pat._addressof_glConservativeRasterParameterfNV;
        if (addressof_glConservativeRasterParameterfNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glConservativeRasterParameterfNV"));
        }
        this.dispatch_glConservativeRasterParameterfNV1(n, n2, addressof_glConservativeRasterParameterfNV);
    }
    
    private native void dispatch_glConservativeRasterParameterfNV1(final int p0, final float p1, final long p2);
    
    @Override
    public void glCopyImageSubDataNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final int n9, final int n10, final int n11, final int n12, final int n13, final int n14, final int n15) {
        final long addressof_glCopyImageSubDataNV = this._pat._addressof_glCopyImageSubDataNV;
        if (addressof_glCopyImageSubDataNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCopyImageSubDataNV"));
        }
        this.dispatch_glCopyImageSubDataNV1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, addressof_glCopyImageSubDataNV);
    }
    
    private native void dispatch_glCopyImageSubDataNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final int p8, final int p9, final int p10, final int p11, final int p12, final int p13, final int p14, final long p15);
    
    @Override
    public void glDrawTextureNV(final int n, final int n2, final float n3, final float n4, final float n5, final float n6, final float n7, final float n8, final float n9, final float n10, final float n11) {
        final long addressof_glDrawTextureNV = this._pat._addressof_glDrawTextureNV;
        if (addressof_glDrawTextureNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawTextureNV"));
        }
        this.dispatch_glDrawTextureNV1(n, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, addressof_glDrawTextureNV);
    }
    
    private native void dispatch_glDrawTextureNV1(final int p0, final int p1, final float p2, final float p3, final float p4, final float p5, final float p6, final float p7, final float p8, final float p9, final float p10, final long p11);
    
    @Override
    public void glMapControlPointsNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final boolean b, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glMapControlPointsNV = this._pat._addressof_glMapControlPointsNV;
        if (addressof_glMapControlPointsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapControlPointsNV"));
        }
        this.dispatch_glMapControlPointsNV1(n, n2, n3, n4, n5, n6, n7, b, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glMapControlPointsNV);
    }
    
    private native void dispatch_glMapControlPointsNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final boolean p7, final Object p8, final int p9, final boolean p10, final long p11);
    
    @Override
    public void glMapParameterivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glMapParameterivNV = this._pat._addressof_glMapParameterivNV;
        if (addressof_glMapParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapParameterivNV"));
        }
        this.dispatch_glMapParameterivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glMapParameterivNV);
    }
    
    private native void dispatch_glMapParameterivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMapParameterivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMapParameterivNV = this._pat._addressof_glMapParameterivNV;
        if (addressof_glMapParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapParameterivNV"));
        }
        this.dispatch_glMapParameterivNV1(n, n2, array, 4 * n3, false, addressof_glMapParameterivNV);
    }
    
    @Override
    public void glMapParameterfvNV(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glMapParameterfvNV = this._pat._addressof_glMapParameterfvNV;
        if (addressof_glMapParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapParameterfvNV"));
        }
        this.dispatch_glMapParameterfvNV1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glMapParameterfvNV);
    }
    
    private native void dispatch_glMapParameterfvNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glMapParameterfvNV(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMapParameterfvNV = this._pat._addressof_glMapParameterfvNV;
        if (addressof_glMapParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMapParameterfvNV"));
        }
        this.dispatch_glMapParameterfvNV1(n, n2, array, 4 * n3, false, addressof_glMapParameterfvNV);
    }
    
    @Override
    public void glGetMapControlPointsNV(final int n, final int n2, final int n3, final int n4, final int n5, final boolean b, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glGetMapControlPointsNV = this._pat._addressof_glGetMapControlPointsNV;
        if (addressof_glGetMapControlPointsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapControlPointsNV"));
        }
        this.dispatch_glGetMapControlPointsNV1(n, n2, n3, n4, n5, b, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glGetMapControlPointsNV);
    }
    
    private native void dispatch_glGetMapControlPointsNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glGetMapParameterivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMapParameterivNV = this._pat._addressof_glGetMapParameterivNV;
        if (addressof_glGetMapParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterivNV"));
        }
        this.dispatch_glGetMapParameterivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMapParameterivNV);
    }
    
    private native void dispatch_glGetMapParameterivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMapParameterivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMapParameterivNV = this._pat._addressof_glGetMapParameterivNV;
        if (addressof_glGetMapParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterivNV"));
        }
        this.dispatch_glGetMapParameterivNV1(n, n2, array, 4 * n3, false, addressof_glGetMapParameterivNV);
    }
    
    @Override
    public void glGetMapParameterfvNV(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMapParameterfvNV = this._pat._addressof_glGetMapParameterfvNV;
        if (addressof_glGetMapParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterfvNV"));
        }
        this.dispatch_glGetMapParameterfvNV1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMapParameterfvNV);
    }
    
    private native void dispatch_glGetMapParameterfvNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMapParameterfvNV(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMapParameterfvNV = this._pat._addressof_glGetMapParameterfvNV;
        if (addressof_glGetMapParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterfvNV"));
        }
        this.dispatch_glGetMapParameterfvNV1(n, n2, array, 4 * n3, false, addressof_glGetMapParameterfvNV);
    }
    
    @Override
    public void glGetMapAttribParameterivNV(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetMapAttribParameterivNV = this._pat._addressof_glGetMapAttribParameterivNV;
        if (addressof_glGetMapAttribParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterivNV"));
        }
        this.dispatch_glGetMapAttribParameterivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetMapAttribParameterivNV);
    }
    
    private native void dispatch_glGetMapAttribParameterivNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMapAttribParameterivNV(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMapAttribParameterivNV = this._pat._addressof_glGetMapAttribParameterivNV;
        if (addressof_glGetMapAttribParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterivNV"));
        }
        this.dispatch_glGetMapAttribParameterivNV1(n, n2, n3, array, 4 * n4, false, addressof_glGetMapAttribParameterivNV);
    }
    
    @Override
    public void glGetMapAttribParameterfvNV(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMapAttribParameterfvNV = this._pat._addressof_glGetMapAttribParameterfvNV;
        if (addressof_glGetMapAttribParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterfvNV"));
        }
        this.dispatch_glGetMapAttribParameterfvNV1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMapAttribParameterfvNV);
    }
    
    private native void dispatch_glGetMapAttribParameterfvNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetMapAttribParameterfvNV(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMapAttribParameterfvNV = this._pat._addressof_glGetMapAttribParameterfvNV;
        if (addressof_glGetMapAttribParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterfvNV"));
        }
        this.dispatch_glGetMapAttribParameterfvNV1(n, n2, n3, array, 4 * n4, false, addressof_glGetMapAttribParameterfvNV);
    }
    
    @Override
    public void glEvalMapsNV(final int n, final int n2) {
        final long addressof_glEvalMapsNV = this._pat._addressof_glEvalMapsNV;
        if (addressof_glEvalMapsNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEvalMapsNV"));
        }
        this.dispatch_glEvalMapsNV1(n, n2, addressof_glEvalMapsNV);
    }
    
    private native void dispatch_glEvalMapsNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glGetMultisamplefvNV(final int n, final int n2, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetMultisamplefvNV = this._pat._addressof_glGetMultisamplefvNV;
        if (addressof_glGetMultisamplefvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefvNV"));
        }
        this.dispatch_glGetMultisamplefvNV1(n, n2, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetMultisamplefvNV);
    }
    
    private native void dispatch_glGetMultisamplefvNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetMultisamplefvNV(final int n, final int n2, final float[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"val_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetMultisamplefvNV = this._pat._addressof_glGetMultisamplefvNV;
        if (addressof_glGetMultisamplefvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefvNV"));
        }
        this.dispatch_glGetMultisamplefvNV1(n, n2, array, 4 * n3, false, addressof_glGetMultisamplefvNV);
    }
    
    @Override
    public void glSampleMaskIndexedNV(final int n, final int n2) {
        final long addressof_glSampleMaskIndexedNV = this._pat._addressof_glSampleMaskIndexedNV;
        if (addressof_glSampleMaskIndexedNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSampleMaskIndexedNV"));
        }
        this.dispatch_glSampleMaskIndexedNV1(n, n2, addressof_glSampleMaskIndexedNV);
    }
    
    private native void dispatch_glSampleMaskIndexedNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTexRenderbufferNV(final int n, final int n2) {
        final long addressof_glTexRenderbufferNV = this._pat._addressof_glTexRenderbufferNV;
        if (addressof_glTexRenderbufferNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexRenderbufferNV"));
        }
        this.dispatch_glTexRenderbufferNV1(n, n2, addressof_glTexRenderbufferNV);
    }
    
    private native void dispatch_glTexRenderbufferNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glFragmentCoverageColorNV(final int n) {
        final long addressof_glFragmentCoverageColorNV = this._pat._addressof_glFragmentCoverageColorNV;
        if (addressof_glFragmentCoverageColorNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFragmentCoverageColorNV"));
        }
        this.dispatch_glFragmentCoverageColorNV1(n, addressof_glFragmentCoverageColorNV);
    }
    
    private native void dispatch_glFragmentCoverageColorNV1(final int p0, final long p1);
    
    @Override
    public void glCoverageModulationTableNV(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glCoverageModulationTableNV = this._pat._addressof_glCoverageModulationTableNV;
        if (addressof_glCoverageModulationTableNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationTableNV"));
        }
        this.dispatch_glCoverageModulationTableNV1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glCoverageModulationTableNV);
    }
    
    private native void dispatch_glCoverageModulationTableNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glCoverageModulationTableNV(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glCoverageModulationTableNV = this._pat._addressof_glCoverageModulationTableNV;
        if (addressof_glCoverageModulationTableNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationTableNV"));
        }
        this.dispatch_glCoverageModulationTableNV1(n, array, 4 * n2, false, addressof_glCoverageModulationTableNV);
    }
    
    @Override
    public void glGetCoverageModulationTableNV(final int n, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetCoverageModulationTableNV = this._pat._addressof_glGetCoverageModulationTableNV;
        if (addressof_glGetCoverageModulationTableNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCoverageModulationTableNV"));
        }
        this.dispatch_glGetCoverageModulationTableNV1(n, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetCoverageModulationTableNV);
    }
    
    private native void dispatch_glGetCoverageModulationTableNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetCoverageModulationTableNV(final int n, final float[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetCoverageModulationTableNV = this._pat._addressof_glGetCoverageModulationTableNV;
        if (addressof_glGetCoverageModulationTableNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetCoverageModulationTableNV"));
        }
        this.dispatch_glGetCoverageModulationTableNV1(n, array, 4 * n2, false, addressof_glGetCoverageModulationTableNV);
    }
    
    @Override
    public void glCoverageModulationNV(final int n) {
        final long addressof_glCoverageModulationNV = this._pat._addressof_glCoverageModulationNV;
        if (addressof_glCoverageModulationNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationNV"));
        }
        this.dispatch_glCoverageModulationNV1(n, addressof_glCoverageModulationNV);
    }
    
    private native void dispatch_glCoverageModulationNV1(final int p0, final long p1);
    
    @Override
    public void glRenderbufferStorageMultisampleCoverageNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glRenderbufferStorageMultisampleCoverageNV = this._pat._addressof_glRenderbufferStorageMultisampleCoverageNV;
        if (addressof_glRenderbufferStorageMultisampleCoverageNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleCoverageNV"));
        }
        this.dispatch_glRenderbufferStorageMultisampleCoverageNV1(n, n2, n3, n4, n5, n6, addressof_glRenderbufferStorageMultisampleCoverageNV);
    }
    
    private native void dispatch_glRenderbufferStorageMultisampleCoverageNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramVertexLimitNV(final int n, final int n2) {
        final long addressof_glProgramVertexLimitNV = this._pat._addressof_glProgramVertexLimitNV;
        if (addressof_glProgramVertexLimitNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramVertexLimitNV"));
        }
        this.dispatch_glProgramVertexLimitNV1(n, n2, addressof_glProgramVertexLimitNV);
    }
    
    private native void dispatch_glProgramVertexLimitNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glFramebufferTextureEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glFramebufferTextureEXT = this._pat._addressof_glFramebufferTextureEXT;
        if (addressof_glFramebufferTextureEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureEXT"));
        }
        this.dispatch_glFramebufferTextureEXT1(n, n2, n3, n4, addressof_glFramebufferTextureEXT);
    }
    
    private native void dispatch_glFramebufferTextureEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glFramebufferTextureFaceEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glFramebufferTextureFaceEXT = this._pat._addressof_glFramebufferTextureFaceEXT;
        if (addressof_glFramebufferTextureFaceEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureFaceEXT"));
        }
        this.dispatch_glFramebufferTextureFaceEXT1(n, n2, n3, n4, n5, addressof_glFramebufferTextureFaceEXT);
    }
    
    private native void dispatch_glFramebufferTextureFaceEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glProgramLocalParameterI4iNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glProgramLocalParameterI4iNV = this._pat._addressof_glProgramLocalParameterI4iNV;
        if (addressof_glProgramLocalParameterI4iNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4iNV"));
        }
        this.dispatch_glProgramLocalParameterI4iNV1(n, n2, n3, n4, n5, n6, addressof_glProgramLocalParameterI4iNV);
    }
    
    private native void dispatch_glProgramLocalParameterI4iNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramLocalParameterI4ivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramLocalParameterI4ivNV = this._pat._addressof_glProgramLocalParameterI4ivNV;
        if (addressof_glProgramLocalParameterI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4ivNV"));
        }
        this.dispatch_glProgramLocalParameterI4ivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramLocalParameterI4ivNV);
    }
    
    private native void dispatch_glProgramLocalParameterI4ivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramLocalParameterI4ivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramLocalParameterI4ivNV = this._pat._addressof_glProgramLocalParameterI4ivNV;
        if (addressof_glProgramLocalParameterI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4ivNV"));
        }
        this.dispatch_glProgramLocalParameterI4ivNV1(n, n2, array, 4 * n3, false, addressof_glProgramLocalParameterI4ivNV);
    }
    
    @Override
    public void glProgramLocalParametersI4ivNV(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramLocalParametersI4ivNV = this._pat._addressof_glProgramLocalParametersI4ivNV;
        if (addressof_glProgramLocalParametersI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4ivNV"));
        }
        this.dispatch_glProgramLocalParametersI4ivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramLocalParametersI4ivNV);
    }
    
    private native void dispatch_glProgramLocalParametersI4ivNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramLocalParametersI4ivNV(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramLocalParametersI4ivNV = this._pat._addressof_glProgramLocalParametersI4ivNV;
        if (addressof_glProgramLocalParametersI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4ivNV"));
        }
        this.dispatch_glProgramLocalParametersI4ivNV1(n, n2, n3, array, 4 * n4, false, addressof_glProgramLocalParametersI4ivNV);
    }
    
    @Override
    public void glProgramLocalParameterI4uiNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glProgramLocalParameterI4uiNV = this._pat._addressof_glProgramLocalParameterI4uiNV;
        if (addressof_glProgramLocalParameterI4uiNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4uiNV"));
        }
        this.dispatch_glProgramLocalParameterI4uiNV1(n, n2, n3, n4, n5, n6, addressof_glProgramLocalParameterI4uiNV);
    }
    
    private native void dispatch_glProgramLocalParameterI4uiNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramLocalParameterI4uivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramLocalParameterI4uivNV = this._pat._addressof_glProgramLocalParameterI4uivNV;
        if (addressof_glProgramLocalParameterI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4uivNV"));
        }
        this.dispatch_glProgramLocalParameterI4uivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramLocalParameterI4uivNV);
    }
    
    private native void dispatch_glProgramLocalParameterI4uivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramLocalParameterI4uivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramLocalParameterI4uivNV = this._pat._addressof_glProgramLocalParameterI4uivNV;
        if (addressof_glProgramLocalParameterI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4uivNV"));
        }
        this.dispatch_glProgramLocalParameterI4uivNV1(n, n2, array, 4 * n3, false, addressof_glProgramLocalParameterI4uivNV);
    }
    
    @Override
    public void glProgramLocalParametersI4uivNV(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramLocalParametersI4uivNV = this._pat._addressof_glProgramLocalParametersI4uivNV;
        if (addressof_glProgramLocalParametersI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4uivNV"));
        }
        this.dispatch_glProgramLocalParametersI4uivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramLocalParametersI4uivNV);
    }
    
    private native void dispatch_glProgramLocalParametersI4uivNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramLocalParametersI4uivNV(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramLocalParametersI4uivNV = this._pat._addressof_glProgramLocalParametersI4uivNV;
        if (addressof_glProgramLocalParametersI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4uivNV"));
        }
        this.dispatch_glProgramLocalParametersI4uivNV1(n, n2, n3, array, 4 * n4, false, addressof_glProgramLocalParametersI4uivNV);
    }
    
    @Override
    public void glProgramEnvParameterI4iNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glProgramEnvParameterI4iNV = this._pat._addressof_glProgramEnvParameterI4iNV;
        if (addressof_glProgramEnvParameterI4iNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4iNV"));
        }
        this.dispatch_glProgramEnvParameterI4iNV1(n, n2, n3, n4, n5, n6, addressof_glProgramEnvParameterI4iNV);
    }
    
    private native void dispatch_glProgramEnvParameterI4iNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramEnvParameterI4ivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramEnvParameterI4ivNV = this._pat._addressof_glProgramEnvParameterI4ivNV;
        if (addressof_glProgramEnvParameterI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4ivNV"));
        }
        this.dispatch_glProgramEnvParameterI4ivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramEnvParameterI4ivNV);
    }
    
    private native void dispatch_glProgramEnvParameterI4ivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramEnvParameterI4ivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramEnvParameterI4ivNV = this._pat._addressof_glProgramEnvParameterI4ivNV;
        if (addressof_glProgramEnvParameterI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4ivNV"));
        }
        this.dispatch_glProgramEnvParameterI4ivNV1(n, n2, array, 4 * n3, false, addressof_glProgramEnvParameterI4ivNV);
    }
    
    @Override
    public void glProgramEnvParametersI4ivNV(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramEnvParametersI4ivNV = this._pat._addressof_glProgramEnvParametersI4ivNV;
        if (addressof_glProgramEnvParametersI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4ivNV"));
        }
        this.dispatch_glProgramEnvParametersI4ivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramEnvParametersI4ivNV);
    }
    
    private native void dispatch_glProgramEnvParametersI4ivNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramEnvParametersI4ivNV(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramEnvParametersI4ivNV = this._pat._addressof_glProgramEnvParametersI4ivNV;
        if (addressof_glProgramEnvParametersI4ivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4ivNV"));
        }
        this.dispatch_glProgramEnvParametersI4ivNV1(n, n2, n3, array, 4 * n4, false, addressof_glProgramEnvParametersI4ivNV);
    }
    
    @Override
    public void glProgramEnvParameterI4uiNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glProgramEnvParameterI4uiNV = this._pat._addressof_glProgramEnvParameterI4uiNV;
        if (addressof_glProgramEnvParameterI4uiNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4uiNV"));
        }
        this.dispatch_glProgramEnvParameterI4uiNV1(n, n2, n3, n4, n5, n6, addressof_glProgramEnvParameterI4uiNV);
    }
    
    private native void dispatch_glProgramEnvParameterI4uiNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glProgramEnvParameterI4uivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramEnvParameterI4uivNV = this._pat._addressof_glProgramEnvParameterI4uivNV;
        if (addressof_glProgramEnvParameterI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4uivNV"));
        }
        this.dispatch_glProgramEnvParameterI4uivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramEnvParameterI4uivNV);
    }
    
    private native void dispatch_glProgramEnvParameterI4uivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramEnvParameterI4uivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramEnvParameterI4uivNV = this._pat._addressof_glProgramEnvParameterI4uivNV;
        if (addressof_glProgramEnvParameterI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4uivNV"));
        }
        this.dispatch_glProgramEnvParameterI4uivNV1(n, n2, array, 4 * n3, false, addressof_glProgramEnvParameterI4uivNV);
    }
    
    @Override
    public void glProgramEnvParametersI4uivNV(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramEnvParametersI4uivNV = this._pat._addressof_glProgramEnvParametersI4uivNV;
        if (addressof_glProgramEnvParametersI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4uivNV"));
        }
        this.dispatch_glProgramEnvParametersI4uivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramEnvParametersI4uivNV);
    }
    
    private native void dispatch_glProgramEnvParametersI4uivNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramEnvParametersI4uivNV(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramEnvParametersI4uivNV = this._pat._addressof_glProgramEnvParametersI4uivNV;
        if (addressof_glProgramEnvParametersI4uivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4uivNV"));
        }
        this.dispatch_glProgramEnvParametersI4uivNV1(n, n2, n3, array, 4 * n4, false, addressof_glProgramEnvParametersI4uivNV);
    }
    
    @Override
    public void glGetProgramLocalParameterIivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramLocalParameterIivNV = this._pat._addressof_glGetProgramLocalParameterIivNV;
        if (addressof_glGetProgramLocalParameterIivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIivNV"));
        }
        this.dispatch_glGetProgramLocalParameterIivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramLocalParameterIivNV);
    }
    
    private native void dispatch_glGetProgramLocalParameterIivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramLocalParameterIivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramLocalParameterIivNV = this._pat._addressof_glGetProgramLocalParameterIivNV;
        if (addressof_glGetProgramLocalParameterIivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIivNV"));
        }
        this.dispatch_glGetProgramLocalParameterIivNV1(n, n2, array, 4 * n3, false, addressof_glGetProgramLocalParameterIivNV);
    }
    
    @Override
    public void glGetProgramLocalParameterIuivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramLocalParameterIuivNV = this._pat._addressof_glGetProgramLocalParameterIuivNV;
        if (addressof_glGetProgramLocalParameterIuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIuivNV"));
        }
        this.dispatch_glGetProgramLocalParameterIuivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramLocalParameterIuivNV);
    }
    
    private native void dispatch_glGetProgramLocalParameterIuivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramLocalParameterIuivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramLocalParameterIuivNV = this._pat._addressof_glGetProgramLocalParameterIuivNV;
        if (addressof_glGetProgramLocalParameterIuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIuivNV"));
        }
        this.dispatch_glGetProgramLocalParameterIuivNV1(n, n2, array, 4 * n3, false, addressof_glGetProgramLocalParameterIuivNV);
    }
    
    @Override
    public void glGetProgramEnvParameterIivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramEnvParameterIivNV = this._pat._addressof_glGetProgramEnvParameterIivNV;
        if (addressof_glGetProgramEnvParameterIivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIivNV"));
        }
        this.dispatch_glGetProgramEnvParameterIivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramEnvParameterIivNV);
    }
    
    private native void dispatch_glGetProgramEnvParameterIivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramEnvParameterIivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramEnvParameterIivNV = this._pat._addressof_glGetProgramEnvParameterIivNV;
        if (addressof_glGetProgramEnvParameterIivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIivNV"));
        }
        this.dispatch_glGetProgramEnvParameterIivNV1(n, n2, array, 4 * n3, false, addressof_glGetProgramEnvParameterIivNV);
    }
    
    @Override
    public void glGetProgramEnvParameterIuivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramEnvParameterIuivNV = this._pat._addressof_glGetProgramEnvParameterIuivNV;
        if (addressof_glGetProgramEnvParameterIuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIuivNV"));
        }
        this.dispatch_glGetProgramEnvParameterIuivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramEnvParameterIuivNV);
    }
    
    private native void dispatch_glGetProgramEnvParameterIuivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramEnvParameterIuivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramEnvParameterIuivNV = this._pat._addressof_glGetProgramEnvParameterIuivNV;
        if (addressof_glGetProgramEnvParameterIuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIuivNV"));
        }
        this.dispatch_glGetProgramEnvParameterIuivNV1(n, n2, array, 4 * n3, false, addressof_glGetProgramEnvParameterIuivNV);
    }
    
    @Override
    public void glProgramSubroutineParametersuivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramSubroutineParametersuivNV = this._pat._addressof_glProgramSubroutineParametersuivNV;
        if (addressof_glProgramSubroutineParametersuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramSubroutineParametersuivNV"));
        }
        this.dispatch_glProgramSubroutineParametersuivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramSubroutineParametersuivNV);
    }
    
    private native void dispatch_glProgramSubroutineParametersuivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glProgramSubroutineParametersuivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramSubroutineParametersuivNV = this._pat._addressof_glProgramSubroutineParametersuivNV;
        if (addressof_glProgramSubroutineParametersuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramSubroutineParametersuivNV"));
        }
        this.dispatch_glProgramSubroutineParametersuivNV1(n, n2, array, 4 * n3, false, addressof_glProgramSubroutineParametersuivNV);
    }
    
    @Override
    public void glGetProgramSubroutineParameteruivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetProgramSubroutineParameteruivNV = this._pat._addressof_glGetProgramSubroutineParameteruivNV;
        if (addressof_glGetProgramSubroutineParameteruivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramSubroutineParameteruivNV"));
        }
        this.dispatch_glGetProgramSubroutineParameteruivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetProgramSubroutineParameteruivNV);
    }
    
    private native void dispatch_glGetProgramSubroutineParameteruivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetProgramSubroutineParameteruivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"param_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetProgramSubroutineParameteruivNV = this._pat._addressof_glGetProgramSubroutineParameteruivNV;
        if (addressof_glGetProgramSubroutineParameteruivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetProgramSubroutineParameteruivNV"));
        }
        this.dispatch_glGetProgramSubroutineParameteruivNV1(n, n2, array, 4 * n3, false, addressof_glGetProgramSubroutineParameteruivNV);
    }
    
    @Override
    public void glVertex2h(final short n, final short n2) {
        final long addressof_glVertex2h = this._pat._addressof_glVertex2h;
        if (addressof_glVertex2h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2h"));
        }
        this.dispatch_glVertex2h1(n, n2, addressof_glVertex2h);
    }
    
    private native void dispatch_glVertex2h1(final short p0, final short p1, final long p2);
    
    @Override
    public void glVertex2hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertex2hv = this._pat._addressof_glVertex2hv;
        if (addressof_glVertex2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2hv"));
        }
        this.dispatch_glVertex2hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertex2hv);
    }
    
    private native void dispatch_glVertex2hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex2hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex2hv = this._pat._addressof_glVertex2hv;
        if (addressof_glVertex2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex2hv"));
        }
        this.dispatch_glVertex2hv1(array, 2 * n, false, addressof_glVertex2hv);
    }
    
    @Override
    public void glVertex3h(final short n, final short n2, final short n3) {
        final long addressof_glVertex3h = this._pat._addressof_glVertex3h;
        if (addressof_glVertex3h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3h"));
        }
        this.dispatch_glVertex3h1(n, n2, n3, addressof_glVertex3h);
    }
    
    private native void dispatch_glVertex3h1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glVertex3hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertex3hv = this._pat._addressof_glVertex3hv;
        if (addressof_glVertex3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3hv"));
        }
        this.dispatch_glVertex3hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertex3hv);
    }
    
    private native void dispatch_glVertex3hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex3hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex3hv = this._pat._addressof_glVertex3hv;
        if (addressof_glVertex3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex3hv"));
        }
        this.dispatch_glVertex3hv1(array, 2 * n, false, addressof_glVertex3hv);
    }
    
    @Override
    public void glVertex4h(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glVertex4h = this._pat._addressof_glVertex4h;
        if (addressof_glVertex4h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4h"));
        }
        this.dispatch_glVertex4h1(n, n2, n3, n4, addressof_glVertex4h);
    }
    
    private native void dispatch_glVertex4h1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glVertex4hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertex4hv = this._pat._addressof_glVertex4hv;
        if (addressof_glVertex4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4hv"));
        }
        this.dispatch_glVertex4hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertex4hv);
    }
    
    private native void dispatch_glVertex4hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertex4hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertex4hv = this._pat._addressof_glVertex4hv;
        if (addressof_glVertex4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertex4hv"));
        }
        this.dispatch_glVertex4hv1(array, 2 * n, false, addressof_glVertex4hv);
    }
    
    @Override
    public void glNormal3h(final short n, final short n2, final short n3) {
        final long addressof_glNormal3h = this._pat._addressof_glNormal3h;
        if (addressof_glNormal3h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3h"));
        }
        this.dispatch_glNormal3h1(n, n2, n3, addressof_glNormal3h);
    }
    
    private native void dispatch_glNormal3h1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glNormal3hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glNormal3hv = this._pat._addressof_glNormal3hv;
        if (addressof_glNormal3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3hv"));
        }
        this.dispatch_glNormal3hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glNormal3hv);
    }
    
    private native void dispatch_glNormal3hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glNormal3hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNormal3hv = this._pat._addressof_glNormal3hv;
        if (addressof_glNormal3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormal3hv"));
        }
        this.dispatch_glNormal3hv1(array, 2 * n, false, addressof_glNormal3hv);
    }
    
    @Override
    public void glColor3h(final short n, final short n2, final short n3) {
        final long addressof_glColor3h = this._pat._addressof_glColor3h;
        if (addressof_glColor3h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3h"));
        }
        this.dispatch_glColor3h1(n, n2, n3, addressof_glColor3h);
    }
    
    private native void dispatch_glColor3h1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glColor3hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glColor3hv = this._pat._addressof_glColor3hv;
        if (addressof_glColor3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3hv"));
        }
        this.dispatch_glColor3hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glColor3hv);
    }
    
    private native void dispatch_glColor3hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor3hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor3hv = this._pat._addressof_glColor3hv;
        if (addressof_glColor3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor3hv"));
        }
        this.dispatch_glColor3hv1(array, 2 * n, false, addressof_glColor3hv);
    }
    
    @Override
    public void glColor4h(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glColor4h = this._pat._addressof_glColor4h;
        if (addressof_glColor4h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4h"));
        }
        this.dispatch_glColor4h1(n, n2, n3, n4, addressof_glColor4h);
    }
    
    private native void dispatch_glColor4h1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glColor4hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glColor4hv = this._pat._addressof_glColor4hv;
        if (addressof_glColor4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4hv"));
        }
        this.dispatch_glColor4hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glColor4hv);
    }
    
    private native void dispatch_glColor4hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glColor4hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glColor4hv = this._pat._addressof_glColor4hv;
        if (addressof_glColor4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColor4hv"));
        }
        this.dispatch_glColor4hv1(array, 2 * n, false, addressof_glColor4hv);
    }
    
    @Override
    public void glTexCoord1h(final short n) {
        final long addressof_glTexCoord1h = this._pat._addressof_glTexCoord1h;
        if (addressof_glTexCoord1h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1h"));
        }
        this.dispatch_glTexCoord1h1(n, addressof_glTexCoord1h);
    }
    
    private native void dispatch_glTexCoord1h1(final short p0, final long p1);
    
    @Override
    public void glTexCoord1hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord1hv = this._pat._addressof_glTexCoord1hv;
        if (addressof_glTexCoord1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1hv"));
        }
        this.dispatch_glTexCoord1hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord1hv);
    }
    
    private native void dispatch_glTexCoord1hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord1hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord1hv = this._pat._addressof_glTexCoord1hv;
        if (addressof_glTexCoord1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1hv"));
        }
        this.dispatch_glTexCoord1hv1(array, 2 * n, false, addressof_glTexCoord1hv);
    }
    
    @Override
    public void glTexCoord2h(final short n, final short n2) {
        final long addressof_glTexCoord2h = this._pat._addressof_glTexCoord2h;
        if (addressof_glTexCoord2h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2h"));
        }
        this.dispatch_glTexCoord2h1(n, n2, addressof_glTexCoord2h);
    }
    
    private native void dispatch_glTexCoord2h1(final short p0, final short p1, final long p2);
    
    @Override
    public void glTexCoord2hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord2hv = this._pat._addressof_glTexCoord2hv;
        if (addressof_glTexCoord2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2hv"));
        }
        this.dispatch_glTexCoord2hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord2hv);
    }
    
    private native void dispatch_glTexCoord2hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord2hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord2hv = this._pat._addressof_glTexCoord2hv;
        if (addressof_glTexCoord2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2hv"));
        }
        this.dispatch_glTexCoord2hv1(array, 2 * n, false, addressof_glTexCoord2hv);
    }
    
    @Override
    public void glTexCoord3h(final short n, final short n2, final short n3) {
        final long addressof_glTexCoord3h = this._pat._addressof_glTexCoord3h;
        if (addressof_glTexCoord3h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3h"));
        }
        this.dispatch_glTexCoord3h1(n, n2, n3, addressof_glTexCoord3h);
    }
    
    private native void dispatch_glTexCoord3h1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glTexCoord3hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord3hv = this._pat._addressof_glTexCoord3hv;
        if (addressof_glTexCoord3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3hv"));
        }
        this.dispatch_glTexCoord3hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord3hv);
    }
    
    private native void dispatch_glTexCoord3hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord3hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord3hv = this._pat._addressof_glTexCoord3hv;
        if (addressof_glTexCoord3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3hv"));
        }
        this.dispatch_glTexCoord3hv1(array, 2 * n, false, addressof_glTexCoord3hv);
    }
    
    @Override
    public void glTexCoord4h(final short n, final short n2, final short n3, final short n4) {
        final long addressof_glTexCoord4h = this._pat._addressof_glTexCoord4h;
        if (addressof_glTexCoord4h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4h"));
        }
        this.dispatch_glTexCoord4h1(n, n2, n3, n4, addressof_glTexCoord4h);
    }
    
    private native void dispatch_glTexCoord4h1(final short p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glTexCoord4hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glTexCoord4hv = this._pat._addressof_glTexCoord4hv;
        if (addressof_glTexCoord4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4hv"));
        }
        this.dispatch_glTexCoord4hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glTexCoord4hv);
    }
    
    private native void dispatch_glTexCoord4hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glTexCoord4hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glTexCoord4hv = this._pat._addressof_glTexCoord4hv;
        if (addressof_glTexCoord4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4hv"));
        }
        this.dispatch_glTexCoord4hv1(array, 2 * n, false, addressof_glTexCoord4hv);
    }
    
    @Override
    public void glMultiTexCoord1h(final int n, final short n2) {
        final long addressof_glMultiTexCoord1h = this._pat._addressof_glMultiTexCoord1h;
        if (addressof_glMultiTexCoord1h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1h"));
        }
        this.dispatch_glMultiTexCoord1h1(n, n2, addressof_glMultiTexCoord1h);
    }
    
    private native void dispatch_glMultiTexCoord1h1(final int p0, final short p1, final long p2);
    
    @Override
    public void glMultiTexCoord1hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord1hv = this._pat._addressof_glMultiTexCoord1hv;
        if (addressof_glMultiTexCoord1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1hv"));
        }
        this.dispatch_glMultiTexCoord1hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord1hv);
    }
    
    private native void dispatch_glMultiTexCoord1hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord1hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord1hv = this._pat._addressof_glMultiTexCoord1hv;
        if (addressof_glMultiTexCoord1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1hv"));
        }
        this.dispatch_glMultiTexCoord1hv1(n, array, 2 * n2, false, addressof_glMultiTexCoord1hv);
    }
    
    @Override
    public void glMultiTexCoord2h(final int n, final short n2, final short n3) {
        final long addressof_glMultiTexCoord2h = this._pat._addressof_glMultiTexCoord2h;
        if (addressof_glMultiTexCoord2h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2h"));
        }
        this.dispatch_glMultiTexCoord2h1(n, n2, n3, addressof_glMultiTexCoord2h);
    }
    
    private native void dispatch_glMultiTexCoord2h1(final int p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glMultiTexCoord2hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord2hv = this._pat._addressof_glMultiTexCoord2hv;
        if (addressof_glMultiTexCoord2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2hv"));
        }
        this.dispatch_glMultiTexCoord2hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord2hv);
    }
    
    private native void dispatch_glMultiTexCoord2hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord2hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord2hv = this._pat._addressof_glMultiTexCoord2hv;
        if (addressof_glMultiTexCoord2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2hv"));
        }
        this.dispatch_glMultiTexCoord2hv1(n, array, 2 * n2, false, addressof_glMultiTexCoord2hv);
    }
    
    @Override
    public void glMultiTexCoord3h(final int n, final short n2, final short n3, final short n4) {
        final long addressof_glMultiTexCoord3h = this._pat._addressof_glMultiTexCoord3h;
        if (addressof_glMultiTexCoord3h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3h"));
        }
        this.dispatch_glMultiTexCoord3h1(n, n2, n3, n4, addressof_glMultiTexCoord3h);
    }
    
    private native void dispatch_glMultiTexCoord3h1(final int p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glMultiTexCoord3hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord3hv = this._pat._addressof_glMultiTexCoord3hv;
        if (addressof_glMultiTexCoord3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3hv"));
        }
        this.dispatch_glMultiTexCoord3hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord3hv);
    }
    
    private native void dispatch_glMultiTexCoord3hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord3hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord3hv = this._pat._addressof_glMultiTexCoord3hv;
        if (addressof_glMultiTexCoord3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3hv"));
        }
        this.dispatch_glMultiTexCoord3hv1(n, array, 2 * n2, false, addressof_glMultiTexCoord3hv);
    }
    
    @Override
    public void glMultiTexCoord4h(final int n, final short n2, final short n3, final short n4, final short n5) {
        final long addressof_glMultiTexCoord4h = this._pat._addressof_glMultiTexCoord4h;
        if (addressof_glMultiTexCoord4h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4h"));
        }
        this.dispatch_glMultiTexCoord4h1(n, n2, n3, n4, n5, addressof_glMultiTexCoord4h);
    }
    
    private native void dispatch_glMultiTexCoord4h1(final int p0, final short p1, final short p2, final short p3, final short p4, final long p5);
    
    @Override
    public void glMultiTexCoord4hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glMultiTexCoord4hv = this._pat._addressof_glMultiTexCoord4hv;
        if (addressof_glMultiTexCoord4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4hv"));
        }
        this.dispatch_glMultiTexCoord4hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glMultiTexCoord4hv);
    }
    
    private native void dispatch_glMultiTexCoord4hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glMultiTexCoord4hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glMultiTexCoord4hv = this._pat._addressof_glMultiTexCoord4hv;
        if (addressof_glMultiTexCoord4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4hv"));
        }
        this.dispatch_glMultiTexCoord4hv1(n, array, 2 * n2, false, addressof_glMultiTexCoord4hv);
    }
    
    @Override
    public void glFogCoordh(final short n) {
        final long addressof_glFogCoordh = this._pat._addressof_glFogCoordh;
        if (addressof_glFogCoordh == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordh"));
        }
        this.dispatch_glFogCoordh1(n, addressof_glFogCoordh);
    }
    
    private native void dispatch_glFogCoordh1(final short p0, final long p1);
    
    @Override
    public void glFogCoordhv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glFogCoordhv = this._pat._addressof_glFogCoordhv;
        if (addressof_glFogCoordhv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordhv"));
        }
        this.dispatch_glFogCoordhv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glFogCoordhv);
    }
    
    private native void dispatch_glFogCoordhv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glFogCoordhv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"fog_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFogCoordhv = this._pat._addressof_glFogCoordhv;
        if (addressof_glFogCoordhv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordhv"));
        }
        this.dispatch_glFogCoordhv1(array, 2 * n, false, addressof_glFogCoordhv);
    }
    
    @Override
    public void glSecondaryColor3h(final short n, final short n2, final short n3) {
        final long addressof_glSecondaryColor3h = this._pat._addressof_glSecondaryColor3h;
        if (addressof_glSecondaryColor3h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3h"));
        }
        this.dispatch_glSecondaryColor3h1(n, n2, n3, addressof_glSecondaryColor3h);
    }
    
    private native void dispatch_glSecondaryColor3h1(final short p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glSecondaryColor3hv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glSecondaryColor3hv = this._pat._addressof_glSecondaryColor3hv;
        if (addressof_glSecondaryColor3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3hv"));
        }
        this.dispatch_glSecondaryColor3hv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glSecondaryColor3hv);
    }
    
    private native void dispatch_glSecondaryColor3hv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glSecondaryColor3hv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"v_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glSecondaryColor3hv = this._pat._addressof_glSecondaryColor3hv;
        if (addressof_glSecondaryColor3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3hv"));
        }
        this.dispatch_glSecondaryColor3hv1(array, 2 * n, false, addressof_glSecondaryColor3hv);
    }
    
    @Override
    public void glVertexWeighth(final short n) {
        final long addressof_glVertexWeighth = this._pat._addressof_glVertexWeighth;
        if (addressof_glVertexWeighth == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeighth"));
        }
        this.dispatch_glVertexWeighth1(n, addressof_glVertexWeighth);
    }
    
    private native void dispatch_glVertexWeighth1(final short p0, final long p1);
    
    @Override
    public void glVertexWeighthv(final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexWeighthv = this._pat._addressof_glVertexWeighthv;
        if (addressof_glVertexWeighthv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeighthv"));
        }
        this.dispatch_glVertexWeighthv1(direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexWeighthv);
    }
    
    private native void dispatch_glVertexWeighthv1(final Object p0, final int p1, final boolean p2, final long p3);
    
    @Override
    public void glVertexWeighthv(final short[] array, final int n) {
        if (array != null && array.length <= n) {
            throw new GLException("array offset argument \"weight_offset\" (" + n + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexWeighthv = this._pat._addressof_glVertexWeighthv;
        if (addressof_glVertexWeighthv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexWeighthv"));
        }
        this.dispatch_glVertexWeighthv1(array, 2 * n, false, addressof_glVertexWeighthv);
    }
    
    @Override
    public void glVertexAttrib1h(final int n, final short n2) {
        final long addressof_glVertexAttrib1h = this._pat._addressof_glVertexAttrib1h;
        if (addressof_glVertexAttrib1h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1h"));
        }
        this.dispatch_glVertexAttrib1h1(n, n2, addressof_glVertexAttrib1h);
    }
    
    private native void dispatch_glVertexAttrib1h1(final int p0, final short p1, final long p2);
    
    @Override
    public void glVertexAttrib1hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib1hv = this._pat._addressof_glVertexAttrib1hv;
        if (addressof_glVertexAttrib1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1hv"));
        }
        this.dispatch_glVertexAttrib1hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib1hv);
    }
    
    private native void dispatch_glVertexAttrib1hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib1hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib1hv = this._pat._addressof_glVertexAttrib1hv;
        if (addressof_glVertexAttrib1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1hv"));
        }
        this.dispatch_glVertexAttrib1hv1(n, array, 2 * n2, false, addressof_glVertexAttrib1hv);
    }
    
    @Override
    public void glVertexAttrib2h(final int n, final short n2, final short n3) {
        final long addressof_glVertexAttrib2h = this._pat._addressof_glVertexAttrib2h;
        if (addressof_glVertexAttrib2h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2h"));
        }
        this.dispatch_glVertexAttrib2h1(n, n2, n3, addressof_glVertexAttrib2h);
    }
    
    private native void dispatch_glVertexAttrib2h1(final int p0, final short p1, final short p2, final long p3);
    
    @Override
    public void glVertexAttrib2hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib2hv = this._pat._addressof_glVertexAttrib2hv;
        if (addressof_glVertexAttrib2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2hv"));
        }
        this.dispatch_glVertexAttrib2hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib2hv);
    }
    
    private native void dispatch_glVertexAttrib2hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib2hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib2hv = this._pat._addressof_glVertexAttrib2hv;
        if (addressof_glVertexAttrib2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2hv"));
        }
        this.dispatch_glVertexAttrib2hv1(n, array, 2 * n2, false, addressof_glVertexAttrib2hv);
    }
    
    @Override
    public void glVertexAttrib3h(final int n, final short n2, final short n3, final short n4) {
        final long addressof_glVertexAttrib3h = this._pat._addressof_glVertexAttrib3h;
        if (addressof_glVertexAttrib3h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3h"));
        }
        this.dispatch_glVertexAttrib3h1(n, n2, n3, n4, addressof_glVertexAttrib3h);
    }
    
    private native void dispatch_glVertexAttrib3h1(final int p0, final short p1, final short p2, final short p3, final long p4);
    
    @Override
    public void glVertexAttrib3hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib3hv = this._pat._addressof_glVertexAttrib3hv;
        if (addressof_glVertexAttrib3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3hv"));
        }
        this.dispatch_glVertexAttrib3hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib3hv);
    }
    
    private native void dispatch_glVertexAttrib3hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib3hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib3hv = this._pat._addressof_glVertexAttrib3hv;
        if (addressof_glVertexAttrib3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3hv"));
        }
        this.dispatch_glVertexAttrib3hv1(n, array, 2 * n2, false, addressof_glVertexAttrib3hv);
    }
    
    @Override
    public void glVertexAttrib4h(final int n, final short n2, final short n3, final short n4, final short n5) {
        final long addressof_glVertexAttrib4h = this._pat._addressof_glVertexAttrib4h;
        if (addressof_glVertexAttrib4h == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4h"));
        }
        this.dispatch_glVertexAttrib4h1(n, n2, n3, n4, n5, addressof_glVertexAttrib4h);
    }
    
    private native void dispatch_glVertexAttrib4h1(final int p0, final short p1, final short p2, final short p3, final short p4, final long p5);
    
    @Override
    public void glVertexAttrib4hv(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttrib4hv = this._pat._addressof_glVertexAttrib4hv;
        if (addressof_glVertexAttrib4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4hv"));
        }
        this.dispatch_glVertexAttrib4hv1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttrib4hv);
    }
    
    private native void dispatch_glVertexAttrib4hv1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttrib4hv(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttrib4hv = this._pat._addressof_glVertexAttrib4hv;
        if (addressof_glVertexAttrib4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4hv"));
        }
        this.dispatch_glVertexAttrib4hv1(n, array, 2 * n2, false, addressof_glVertexAttrib4hv);
    }
    
    @Override
    public void glVertexAttribs1hv(final int n, final int n2, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribs1hv = this._pat._addressof_glVertexAttribs1hv;
        if (addressof_glVertexAttribs1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs1hv"));
        }
        this.dispatch_glVertexAttribs1hv1(n, n2, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribs1hv);
    }
    
    private native void dispatch_glVertexAttribs1hv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glVertexAttribs1hv(final int n, final int n2, final short[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribs1hv = this._pat._addressof_glVertexAttribs1hv;
        if (addressof_glVertexAttribs1hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs1hv"));
        }
        this.dispatch_glVertexAttribs1hv1(n, n2, array, 2 * n3, false, addressof_glVertexAttribs1hv);
    }
    
    @Override
    public void glVertexAttribs2hv(final int n, final int n2, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribs2hv = this._pat._addressof_glVertexAttribs2hv;
        if (addressof_glVertexAttribs2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs2hv"));
        }
        this.dispatch_glVertexAttribs2hv1(n, n2, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribs2hv);
    }
    
    private native void dispatch_glVertexAttribs2hv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glVertexAttribs2hv(final int n, final int n2, final short[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribs2hv = this._pat._addressof_glVertexAttribs2hv;
        if (addressof_glVertexAttribs2hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs2hv"));
        }
        this.dispatch_glVertexAttribs2hv1(n, n2, array, 2 * n3, false, addressof_glVertexAttribs2hv);
    }
    
    @Override
    public void glVertexAttribs3hv(final int n, final int n2, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribs3hv = this._pat._addressof_glVertexAttribs3hv;
        if (addressof_glVertexAttribs3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs3hv"));
        }
        this.dispatch_glVertexAttribs3hv1(n, n2, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribs3hv);
    }
    
    private native void dispatch_glVertexAttribs3hv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glVertexAttribs3hv(final int n, final int n2, final short[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribs3hv = this._pat._addressof_glVertexAttribs3hv;
        if (addressof_glVertexAttribs3hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs3hv"));
        }
        this.dispatch_glVertexAttribs3hv1(n, n2, array, 2 * n3, false, addressof_glVertexAttribs3hv);
    }
    
    @Override
    public void glVertexAttribs4hv(final int n, final int n2, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribs4hv = this._pat._addressof_glVertexAttribs4hv;
        if (addressof_glVertexAttribs4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs4hv"));
        }
        this.dispatch_glVertexAttribs4hv1(n, n2, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribs4hv);
    }
    
    private native void dispatch_glVertexAttribs4hv1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glVertexAttribs4hv(final int n, final int n2, final short[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"v_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribs4hv = this._pat._addressof_glVertexAttribs4hv;
        if (addressof_glVertexAttribs4hv == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs4hv"));
        }
        this.dispatch_glVertexAttribs4hv1(n, n2, array, 2 * n3, false, addressof_glVertexAttribs4hv);
    }
    
    @Override
    public void glGenOcclusionQueriesNV(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenOcclusionQueriesNV = this._pat._addressof_glGenOcclusionQueriesNV;
        if (addressof_glGenOcclusionQueriesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenOcclusionQueriesNV"));
        }
        this.dispatch_glGenOcclusionQueriesNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenOcclusionQueriesNV);
    }
    
    private native void dispatch_glGenOcclusionQueriesNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenOcclusionQueriesNV(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenOcclusionQueriesNV = this._pat._addressof_glGenOcclusionQueriesNV;
        if (addressof_glGenOcclusionQueriesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenOcclusionQueriesNV"));
        }
        this.dispatch_glGenOcclusionQueriesNV1(n, array, 4 * n2, false, addressof_glGenOcclusionQueriesNV);
    }
    
    @Override
    public void glDeleteOcclusionQueriesNV(final int n, final IntBuffer intBuffer) {
        Buffers.rangeCheck(intBuffer, n);
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteOcclusionQueriesNV = this._pat._addressof_glDeleteOcclusionQueriesNV;
        if (addressof_glDeleteOcclusionQueriesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteOcclusionQueriesNV"));
        }
        this.dispatch_glDeleteOcclusionQueriesNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteOcclusionQueriesNV);
    }
    
    private native void dispatch_glDeleteOcclusionQueriesNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteOcclusionQueriesNV(final int n, final int[] array, final int n2) {
        Buffers.rangeCheck(array, n2, n);
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteOcclusionQueriesNV = this._pat._addressof_glDeleteOcclusionQueriesNV;
        if (addressof_glDeleteOcclusionQueriesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteOcclusionQueriesNV"));
        }
        this.dispatch_glDeleteOcclusionQueriesNV1(n, array, 4 * n2, false, addressof_glDeleteOcclusionQueriesNV);
    }
    
    @Override
    public boolean glIsOcclusionQueryNV(final int n) {
        final long addressof_glIsOcclusionQueryNV = this._pat._addressof_glIsOcclusionQueryNV;
        if (addressof_glIsOcclusionQueryNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsOcclusionQueryNV"));
        }
        return this.dispatch_glIsOcclusionQueryNV1(n, addressof_glIsOcclusionQueryNV);
    }
    
    private native boolean dispatch_glIsOcclusionQueryNV1(final int p0, final long p1);
    
    @Override
    public void glBeginOcclusionQueryNV(final int n) {
        final long addressof_glBeginOcclusionQueryNV = this._pat._addressof_glBeginOcclusionQueryNV;
        if (addressof_glBeginOcclusionQueryNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginOcclusionQueryNV"));
        }
        this.dispatch_glBeginOcclusionQueryNV1(n, addressof_glBeginOcclusionQueryNV);
    }
    
    private native void dispatch_glBeginOcclusionQueryNV1(final int p0, final long p1);
    
    @Override
    public void glEndOcclusionQueryNV() {
        final long addressof_glEndOcclusionQueryNV = this._pat._addressof_glEndOcclusionQueryNV;
        if (addressof_glEndOcclusionQueryNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndOcclusionQueryNV"));
        }
        this.dispatch_glEndOcclusionQueryNV1(addressof_glEndOcclusionQueryNV);
    }
    
    private native void dispatch_glEndOcclusionQueryNV1(final long p0);
    
    @Override
    public void glGetOcclusionQueryivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetOcclusionQueryivNV = this._pat._addressof_glGetOcclusionQueryivNV;
        if (addressof_glGetOcclusionQueryivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryivNV"));
        }
        this.dispatch_glGetOcclusionQueryivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetOcclusionQueryivNV);
    }
    
    private native void dispatch_glGetOcclusionQueryivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetOcclusionQueryivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetOcclusionQueryivNV = this._pat._addressof_glGetOcclusionQueryivNV;
        if (addressof_glGetOcclusionQueryivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryivNV"));
        }
        this.dispatch_glGetOcclusionQueryivNV1(n, n2, array, 4 * n3, false, addressof_glGetOcclusionQueryivNV);
    }
    
    @Override
    public void glGetOcclusionQueryuivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetOcclusionQueryuivNV = this._pat._addressof_glGetOcclusionQueryuivNV;
        if (addressof_glGetOcclusionQueryuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryuivNV"));
        }
        this.dispatch_glGetOcclusionQueryuivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetOcclusionQueryuivNV);
    }
    
    private native void dispatch_glGetOcclusionQueryuivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetOcclusionQueryuivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetOcclusionQueryuivNV = this._pat._addressof_glGetOcclusionQueryuivNV;
        if (addressof_glGetOcclusionQueryuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryuivNV"));
        }
        this.dispatch_glGetOcclusionQueryuivNV1(n, n2, array, 4 * n3, false, addressof_glGetOcclusionQueryuivNV);
    }
    
    @Override
    public void glProgramBufferParametersfvNV(final int n, final int n2, final int n3, final int n4, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glProgramBufferParametersfvNV = this._pat._addressof_glProgramBufferParametersfvNV;
        if (addressof_glProgramBufferParametersfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersfvNV"));
        }
        this.dispatch_glProgramBufferParametersfvNV1(n, n2, n3, n4, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glProgramBufferParametersfvNV);
    }
    
    private native void dispatch_glProgramBufferParametersfvNV1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramBufferParametersfvNV(final int n, final int n2, final int n3, final int n4, final float[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramBufferParametersfvNV = this._pat._addressof_glProgramBufferParametersfvNV;
        if (addressof_glProgramBufferParametersfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersfvNV"));
        }
        this.dispatch_glProgramBufferParametersfvNV1(n, n2, n3, n4, array, 4 * n5, false, addressof_glProgramBufferParametersfvNV);
    }
    
    @Override
    public void glProgramBufferParametersIivNV(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramBufferParametersIivNV = this._pat._addressof_glProgramBufferParametersIivNV;
        if (addressof_glProgramBufferParametersIivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIivNV"));
        }
        this.dispatch_glProgramBufferParametersIivNV1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramBufferParametersIivNV);
    }
    
    private native void dispatch_glProgramBufferParametersIivNV1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramBufferParametersIivNV(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramBufferParametersIivNV = this._pat._addressof_glProgramBufferParametersIivNV;
        if (addressof_glProgramBufferParametersIivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIivNV"));
        }
        this.dispatch_glProgramBufferParametersIivNV1(n, n2, n3, n4, array, 4 * n5, false, addressof_glProgramBufferParametersIivNV);
    }
    
    @Override
    public void glProgramBufferParametersIuivNV(final int n, final int n2, final int n3, final int n4, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glProgramBufferParametersIuivNV = this._pat._addressof_glProgramBufferParametersIuivNV;
        if (addressof_glProgramBufferParametersIuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIuivNV"));
        }
        this.dispatch_glProgramBufferParametersIuivNV1(n, n2, n3, n4, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glProgramBufferParametersIuivNV);
    }
    
    private native void dispatch_glProgramBufferParametersIuivNV1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glProgramBufferParametersIuivNV(final int n, final int n2, final int n3, final int n4, final int[] array, final int n5) {
        if (array != null && array.length <= n5) {
            throw new GLException("array offset argument \"params_offset\" (" + n5 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramBufferParametersIuivNV = this._pat._addressof_glProgramBufferParametersIuivNV;
        if (addressof_glProgramBufferParametersIuivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIuivNV"));
        }
        this.dispatch_glProgramBufferParametersIuivNV1(n, n2, n3, n4, array, 4 * n5, false, addressof_glProgramBufferParametersIuivNV);
    }
    
    @Override
    public void glPixelDataRangeNV(final int n, final int n2, final Buffer buffer) {
        if (!Buffers.isDirect(buffer)) {
            throw new GLException("Argument \"pointer\" is not a direct buffer");
        }
        final long addressof_glPixelDataRangeNV = this._pat._addressof_glPixelDataRangeNV;
        if (addressof_glPixelDataRangeNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPixelDataRangeNV"));
        }
        this.dispatch_glPixelDataRangeNV0(n, n2, buffer, Buffers.getDirectBufferByteOffset(buffer), addressof_glPixelDataRangeNV);
    }
    
    private native void dispatch_glPixelDataRangeNV0(final int p0, final int p1, final Object p2, final int p3, final long p4);
    
    @Override
    public void glFlushPixelDataRangeNV(final int n) {
        final long addressof_glFlushPixelDataRangeNV = this._pat._addressof_glFlushPixelDataRangeNV;
        if (addressof_glFlushPixelDataRangeNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFlushPixelDataRangeNV"));
        }
        this.dispatch_glFlushPixelDataRangeNV1(n, addressof_glFlushPixelDataRangeNV);
    }
    
    private native void dispatch_glFlushPixelDataRangeNV1(final int p0, final long p1);
    
    @Override
    public void glPrimitiveRestartNV() {
        final long addressof_glPrimitiveRestartNV = this._pat._addressof_glPrimitiveRestartNV;
        if (addressof_glPrimitiveRestartNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveRestartNV"));
        }
        this.dispatch_glPrimitiveRestartNV1(addressof_glPrimitiveRestartNV);
    }
    
    private native void dispatch_glPrimitiveRestartNV1(final long p0);
    
    @Override
    public void glPrimitiveRestartIndexNV(final int n) {
        final long addressof_glPrimitiveRestartIndexNV = this._pat._addressof_glPrimitiveRestartIndexNV;
        if (addressof_glPrimitiveRestartIndexNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveRestartIndexNV"));
        }
        this.dispatch_glPrimitiveRestartIndexNV1(n, addressof_glPrimitiveRestartIndexNV);
    }
    
    private native void dispatch_glPrimitiveRestartIndexNV1(final int p0, final long p1);
    
    @Override
    public void glFramebufferSampleLocationsfvNV(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glFramebufferSampleLocationsfvNV = this._pat._addressof_glFramebufferSampleLocationsfvNV;
        if (addressof_glFramebufferSampleLocationsfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvNV"));
        }
        this.dispatch_glFramebufferSampleLocationsfvNV1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glFramebufferSampleLocationsfvNV);
    }
    
    private native void dispatch_glFramebufferSampleLocationsfvNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glFramebufferSampleLocationsfvNV(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"v_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glFramebufferSampleLocationsfvNV = this._pat._addressof_glFramebufferSampleLocationsfvNV;
        if (addressof_glFramebufferSampleLocationsfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvNV"));
        }
        this.dispatch_glFramebufferSampleLocationsfvNV1(n, n2, n3, array, 4 * n4, false, addressof_glFramebufferSampleLocationsfvNV);
    }
    
    @Override
    public void glNamedFramebufferSampleLocationsfvNV(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glNamedFramebufferSampleLocationsfvNV = this._pat._addressof_glNamedFramebufferSampleLocationsfvNV;
        if (addressof_glNamedFramebufferSampleLocationsfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvNV"));
        }
        this.dispatch_glNamedFramebufferSampleLocationsfvNV1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glNamedFramebufferSampleLocationsfvNV);
    }
    
    private native void dispatch_glNamedFramebufferSampleLocationsfvNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glNamedFramebufferSampleLocationsfvNV(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"v_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glNamedFramebufferSampleLocationsfvNV = this._pat._addressof_glNamedFramebufferSampleLocationsfvNV;
        if (addressof_glNamedFramebufferSampleLocationsfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvNV"));
        }
        this.dispatch_glNamedFramebufferSampleLocationsfvNV1(n, n2, n3, array, 4 * n4, false, addressof_glNamedFramebufferSampleLocationsfvNV);
    }
    
    @Override
    public void glResolveDepthValuesNV() {
        final long addressof_glResolveDepthValuesNV = this._pat._addressof_glResolveDepthValuesNV;
        if (addressof_glResolveDepthValuesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glResolveDepthValuesNV"));
        }
        this.dispatch_glResolveDepthValuesNV1(addressof_glResolveDepthValuesNV);
    }
    
    private native void dispatch_glResolveDepthValuesNV1(final long p0);
    
    @Override
    public void glMakeBufferResidentNV(final int n, final int n2) {
        final long addressof_glMakeBufferResidentNV = this._pat._addressof_glMakeBufferResidentNV;
        if (addressof_glMakeBufferResidentNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeBufferResidentNV"));
        }
        this.dispatch_glMakeBufferResidentNV1(n, n2, addressof_glMakeBufferResidentNV);
    }
    
    private native void dispatch_glMakeBufferResidentNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glMakeBufferNonResidentNV(final int n) {
        final long addressof_glMakeBufferNonResidentNV = this._pat._addressof_glMakeBufferNonResidentNV;
        if (addressof_glMakeBufferNonResidentNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeBufferNonResidentNV"));
        }
        this.dispatch_glMakeBufferNonResidentNV1(n, addressof_glMakeBufferNonResidentNV);
    }
    
    private native void dispatch_glMakeBufferNonResidentNV1(final int p0, final long p1);
    
    @Override
    public boolean glIsBufferResidentNV(final int n) {
        final long addressof_glIsBufferResidentNV = this._pat._addressof_glIsBufferResidentNV;
        if (addressof_glIsBufferResidentNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsBufferResidentNV"));
        }
        return this.dispatch_glIsBufferResidentNV1(n, addressof_glIsBufferResidentNV);
    }
    
    private native boolean dispatch_glIsBufferResidentNV1(final int p0, final long p1);
    
    @Override
    public void glMakeNamedBufferResidentNV(final int n, final int n2) {
        final long addressof_glMakeNamedBufferResidentNV = this._pat._addressof_glMakeNamedBufferResidentNV;
        if (addressof_glMakeNamedBufferResidentNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeNamedBufferResidentNV"));
        }
        this.dispatch_glMakeNamedBufferResidentNV1(n, n2, addressof_glMakeNamedBufferResidentNV);
    }
    
    private native void dispatch_glMakeNamedBufferResidentNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glMakeNamedBufferNonResidentNV(final int n) {
        final long addressof_glMakeNamedBufferNonResidentNV = this._pat._addressof_glMakeNamedBufferNonResidentNV;
        if (addressof_glMakeNamedBufferNonResidentNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glMakeNamedBufferNonResidentNV"));
        }
        this.dispatch_glMakeNamedBufferNonResidentNV1(n, addressof_glMakeNamedBufferNonResidentNV);
    }
    
    private native void dispatch_glMakeNamedBufferNonResidentNV1(final int p0, final long p1);
    
    @Override
    public boolean glIsNamedBufferResidentNV(final int n) {
        final long addressof_glIsNamedBufferResidentNV = this._pat._addressof_glIsNamedBufferResidentNV;
        if (addressof_glIsNamedBufferResidentNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsNamedBufferResidentNV"));
        }
        return this.dispatch_glIsNamedBufferResidentNV1(n, addressof_glIsNamedBufferResidentNV);
    }
    
    private native boolean dispatch_glIsNamedBufferResidentNV1(final int p0, final long p1);
    
    @Override
    public void glGetBufferParameterui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetBufferParameterui64vNV = this._pat._addressof_glGetBufferParameterui64vNV;
        if (addressof_glGetBufferParameterui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameterui64vNV"));
        }
        this.dispatch_glGetBufferParameterui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetBufferParameterui64vNV);
    }
    
    private native void dispatch_glGetBufferParameterui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetBufferParameterui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetBufferParameterui64vNV = this._pat._addressof_glGetBufferParameterui64vNV;
        if (addressof_glGetBufferParameterui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameterui64vNV"));
        }
        this.dispatch_glGetBufferParameterui64vNV1(n, n2, array, 8 * n3, false, addressof_glGetBufferParameterui64vNV);
    }
    
    @Override
    public void glGetNamedBufferParameterui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetNamedBufferParameterui64vNV = this._pat._addressof_glGetNamedBufferParameterui64vNV;
        if (addressof_glGetNamedBufferParameterui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterui64vNV"));
        }
        this.dispatch_glGetNamedBufferParameterui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetNamedBufferParameterui64vNV);
    }
    
    private native void dispatch_glGetNamedBufferParameterui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetNamedBufferParameterui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetNamedBufferParameterui64vNV = this._pat._addressof_glGetNamedBufferParameterui64vNV;
        if (addressof_glGetNamedBufferParameterui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterui64vNV"));
        }
        this.dispatch_glGetNamedBufferParameterui64vNV1(n, n2, array, 8 * n3, false, addressof_glGetNamedBufferParameterui64vNV);
    }
    
    @Override
    public void glGetIntegerui64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetIntegerui64vNV = this._pat._addressof_glGetIntegerui64vNV;
        if (addressof_glGetIntegerui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64vNV"));
        }
        this.dispatch_glGetIntegerui64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetIntegerui64vNV);
    }
    
    private native void dispatch_glGetIntegerui64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGetIntegerui64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"result_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetIntegerui64vNV = this._pat._addressof_glGetIntegerui64vNV;
        if (addressof_glGetIntegerui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64vNV"));
        }
        this.dispatch_glGetIntegerui64vNV1(n, array, 8 * n2, false, addressof_glGetIntegerui64vNV);
    }
    
    @Override
    public void glUniformui64NV(final int n, final long n2) {
        final long addressof_glUniformui64NV = this._pat._addressof_glUniformui64NV;
        if (addressof_glUniformui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformui64NV"));
        }
        this.dispatch_glUniformui64NV1(n, n2, addressof_glUniformui64NV);
    }
    
    private native void dispatch_glUniformui64NV1(final int p0, final long p1, final long p2);
    
    @Override
    public void glUniformui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glUniformui64vNV = this._pat._addressof_glUniformui64vNV;
        if (addressof_glUniformui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformui64vNV"));
        }
        this.dispatch_glUniformui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glUniformui64vNV);
    }
    
    private native void dispatch_glUniformui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glUniformui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"value_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glUniformui64vNV = this._pat._addressof_glUniformui64vNV;
        if (addressof_glUniformui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glUniformui64vNV"));
        }
        this.dispatch_glUniformui64vNV1(n, n2, array, 8 * n3, false, addressof_glUniformui64vNV);
    }
    
    @Override
    public void glProgramUniformui64NV(final int n, final int n2, final long n3) {
        final long addressof_glProgramUniformui64NV = this._pat._addressof_glProgramUniformui64NV;
        if (addressof_glProgramUniformui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformui64NV"));
        }
        this.dispatch_glProgramUniformui64NV1(n, n2, n3, addressof_glProgramUniformui64NV);
    }
    
    private native void dispatch_glProgramUniformui64NV1(final int p0, final int p1, final long p2, final long p3);
    
    @Override
    public void glProgramUniformui64vNV(final int n, final int n2, final int n3, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glProgramUniformui64vNV = this._pat._addressof_glProgramUniformui64vNV;
        if (addressof_glProgramUniformui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformui64vNV"));
        }
        this.dispatch_glProgramUniformui64vNV1(n, n2, n3, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glProgramUniformui64vNV);
    }
    
    private native void dispatch_glProgramUniformui64vNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glProgramUniformui64vNV(final int n, final int n2, final int n3, final long[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"value_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glProgramUniformui64vNV = this._pat._addressof_glProgramUniformui64vNV;
        if (addressof_glProgramUniformui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformui64vNV"));
        }
        this.dispatch_glProgramUniformui64vNV1(n, n2, n3, array, 8 * n4, false, addressof_glProgramUniformui64vNV);
    }
    
    @Override
    public void glTextureBarrierNV() {
        final long addressof_glTextureBarrierNV = this._pat._addressof_glTextureBarrierNV;
        if (addressof_glTextureBarrierNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureBarrierNV"));
        }
        this.dispatch_glTextureBarrierNV1(addressof_glTextureBarrierNV);
    }
    
    private native void dispatch_glTextureBarrierNV1(final long p0);
    
    @Override
    public void glTexImage2DMultisampleCoverageNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final boolean b) {
        final long addressof_glTexImage2DMultisampleCoverageNV = this._pat._addressof_glTexImage2DMultisampleCoverageNV;
        if (addressof_glTexImage2DMultisampleCoverageNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage2DMultisampleCoverageNV"));
        }
        this.dispatch_glTexImage2DMultisampleCoverageNV1(n, n2, n3, n4, n5, n6, b, addressof_glTexImage2DMultisampleCoverageNV);
    }
    
    private native void dispatch_glTexImage2DMultisampleCoverageNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glTexImage3DMultisampleCoverageNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final boolean b) {
        final long addressof_glTexImage3DMultisampleCoverageNV = this._pat._addressof_glTexImage3DMultisampleCoverageNV;
        if (addressof_glTexImage3DMultisampleCoverageNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexImage3DMultisampleCoverageNV"));
        }
        this.dispatch_glTexImage3DMultisampleCoverageNV1(n, n2, n3, n4, n5, n6, n7, b, addressof_glTexImage3DMultisampleCoverageNV);
    }
    
    private native void dispatch_glTexImage3DMultisampleCoverageNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glTextureImage2DMultisampleNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final boolean b) {
        final long addressof_glTextureImage2DMultisampleNV = this._pat._addressof_glTextureImage2DMultisampleNV;
        if (addressof_glTextureImage2DMultisampleNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DMultisampleNV"));
        }
        this.dispatch_glTextureImage2DMultisampleNV1(n, n2, n3, n4, n5, n6, b, addressof_glTextureImage2DMultisampleNV);
    }
    
    private native void dispatch_glTextureImage2DMultisampleNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glTextureImage3DMultisampleNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final boolean b) {
        final long addressof_glTextureImage3DMultisampleNV = this._pat._addressof_glTextureImage3DMultisampleNV;
        if (addressof_glTextureImage3DMultisampleNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DMultisampleNV"));
        }
        this.dispatch_glTextureImage3DMultisampleNV1(n, n2, n3, n4, n5, n6, n7, b, addressof_glTextureImage3DMultisampleNV);
    }
    
    private native void dispatch_glTextureImage3DMultisampleNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glTextureImage2DMultisampleCoverageNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final boolean b) {
        final long addressof_glTextureImage2DMultisampleCoverageNV = this._pat._addressof_glTextureImage2DMultisampleCoverageNV;
        if (addressof_glTextureImage2DMultisampleCoverageNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DMultisampleCoverageNV"));
        }
        this.dispatch_glTextureImage2DMultisampleCoverageNV1(n, n2, n3, n4, n5, n6, n7, b, addressof_glTextureImage2DMultisampleCoverageNV);
    }
    
    private native void dispatch_glTextureImage2DMultisampleCoverageNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public void glTextureImage3DMultisampleCoverageNV(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final boolean b) {
        final long addressof_glTextureImage3DMultisampleCoverageNV = this._pat._addressof_glTextureImage3DMultisampleCoverageNV;
        if (addressof_glTextureImage3DMultisampleCoverageNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DMultisampleCoverageNV"));
        }
        this.dispatch_glTextureImage3DMultisampleCoverageNV1(n, n2, n3, n4, n5, n6, n7, n8, b, addressof_glTextureImage3DMultisampleCoverageNV);
    }
    
    private native void dispatch_glTextureImage3DMultisampleCoverageNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final int p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glBindTransformFeedbackNV(final int n, final int n2) {
        final long addressof_glBindTransformFeedbackNV = this._pat._addressof_glBindTransformFeedbackNV;
        if (addressof_glBindTransformFeedbackNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindTransformFeedbackNV"));
        }
        this.dispatch_glBindTransformFeedbackNV1(n, n2, addressof_glBindTransformFeedbackNV);
    }
    
    private native void dispatch_glBindTransformFeedbackNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glDeleteTransformFeedbacksNV(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glDeleteTransformFeedbacksNV = this._pat._addressof_glDeleteTransformFeedbacksNV;
        if (addressof_glDeleteTransformFeedbacksNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacksNV"));
        }
        this.dispatch_glDeleteTransformFeedbacksNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glDeleteTransformFeedbacksNV);
    }
    
    private native void dispatch_glDeleteTransformFeedbacksNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glDeleteTransformFeedbacksNV(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glDeleteTransformFeedbacksNV = this._pat._addressof_glDeleteTransformFeedbacksNV;
        if (addressof_glDeleteTransformFeedbacksNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacksNV"));
        }
        this.dispatch_glDeleteTransformFeedbacksNV1(n, array, 4 * n2, false, addressof_glDeleteTransformFeedbacksNV);
    }
    
    @Override
    public void glGenTransformFeedbacksNV(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGenTransformFeedbacksNV = this._pat._addressof_glGenTransformFeedbacksNV;
        if (addressof_glGenTransformFeedbacksNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacksNV"));
        }
        this.dispatch_glGenTransformFeedbacksNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGenTransformFeedbacksNV);
    }
    
    private native void dispatch_glGenTransformFeedbacksNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glGenTransformFeedbacksNV(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"ids_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGenTransformFeedbacksNV = this._pat._addressof_glGenTransformFeedbacksNV;
        if (addressof_glGenTransformFeedbacksNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacksNV"));
        }
        this.dispatch_glGenTransformFeedbacksNV1(n, array, 4 * n2, false, addressof_glGenTransformFeedbacksNV);
    }
    
    @Override
    public boolean glIsTransformFeedbackNV(final int n) {
        final long addressof_glIsTransformFeedbackNV = this._pat._addressof_glIsTransformFeedbackNV;
        if (addressof_glIsTransformFeedbackNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIsTransformFeedbackNV"));
        }
        return this.dispatch_glIsTransformFeedbackNV1(n, addressof_glIsTransformFeedbackNV);
    }
    
    private native boolean dispatch_glIsTransformFeedbackNV1(final int p0, final long p1);
    
    @Override
    public void glPauseTransformFeedbackNV() {
        final long addressof_glPauseTransformFeedbackNV = this._pat._addressof_glPauseTransformFeedbackNV;
        if (addressof_glPauseTransformFeedbackNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glPauseTransformFeedbackNV"));
        }
        this.dispatch_glPauseTransformFeedbackNV1(addressof_glPauseTransformFeedbackNV);
    }
    
    private native void dispatch_glPauseTransformFeedbackNV1(final long p0);
    
    @Override
    public void glResumeTransformFeedbackNV() {
        final long addressof_glResumeTransformFeedbackNV = this._pat._addressof_glResumeTransformFeedbackNV;
        if (addressof_glResumeTransformFeedbackNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glResumeTransformFeedbackNV"));
        }
        this.dispatch_glResumeTransformFeedbackNV1(addressof_glResumeTransformFeedbackNV);
    }
    
    private native void dispatch_glResumeTransformFeedbackNV1(final long p0);
    
    @Override
    public void glDrawTransformFeedbackNV(final int n, final int n2) {
        final long addressof_glDrawTransformFeedbackNV = this._pat._addressof_glDrawTransformFeedbackNV;
        if (addressof_glDrawTransformFeedbackNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackNV"));
        }
        this.dispatch_glDrawTransformFeedbackNV1(n, n2, addressof_glDrawTransformFeedbackNV);
    }
    
    private native void dispatch_glDrawTransformFeedbackNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVDPAUInitNV(final Buffer buffer, final Buffer buffer2) {
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(buffer2);
        final long addressof_glVDPAUInitNV = this._pat._addressof_glVDPAUInitNV;
        if (addressof_glVDPAUInitNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUInitNV"));
        }
        this.dispatch_glVDPAUInitNV1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, direct2 ? buffer2 : Buffers.getArray(buffer2), direct2 ? Buffers.getDirectBufferByteOffset(buffer2) : Buffers.getIndirectBufferByteOffset(buffer2), direct2, addressof_glVDPAUInitNV);
    }
    
    private native void dispatch_glVDPAUInitNV1(final Object p0, final int p1, final boolean p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVDPAUFiniNV() {
        final long addressof_glVDPAUFiniNV = this._pat._addressof_glVDPAUFiniNV;
        if (addressof_glVDPAUFiniNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUFiniNV"));
        }
        this.dispatch_glVDPAUFiniNV1(addressof_glVDPAUFiniNV);
    }
    
    private native void dispatch_glVDPAUFiniNV1(final long p0);
    
    @Override
    public long glVDPAURegisterVideoSurfaceNV(final Buffer buffer, final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final long addressof_glVDPAURegisterVideoSurfaceNV = this._pat._addressof_glVDPAURegisterVideoSurfaceNV;
        if (addressof_glVDPAURegisterVideoSurfaceNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterVideoSurfaceNV"));
        }
        return this.dispatch_glVDPAURegisterVideoSurfaceNV1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, n2, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, addressof_glVDPAURegisterVideoSurfaceNV);
    }
    
    private native long dispatch_glVDPAURegisterVideoSurfaceNV1(final Object p0, final int p1, final boolean p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public long glVDPAURegisterVideoSurfaceNV(final Buffer buffer, final int n, final int n2, final int[] array, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"textureNames_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVDPAURegisterVideoSurfaceNV = this._pat._addressof_glVDPAURegisterVideoSurfaceNV;
        if (addressof_glVDPAURegisterVideoSurfaceNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterVideoSurfaceNV"));
        }
        return this.dispatch_glVDPAURegisterVideoSurfaceNV1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, n2, array, 4 * n3, false, addressof_glVDPAURegisterVideoSurfaceNV);
    }
    
    @Override
    public long glVDPAURegisterOutputSurfaceNV(final Buffer buffer, final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final boolean direct2 = Buffers.isDirect(intBuffer);
        final long addressof_glVDPAURegisterOutputSurfaceNV = this._pat._addressof_glVDPAURegisterOutputSurfaceNV;
        if (addressof_glVDPAURegisterOutputSurfaceNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterOutputSurfaceNV"));
        }
        return this.dispatch_glVDPAURegisterOutputSurfaceNV1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, n2, direct2 ? intBuffer : Buffers.getArray(intBuffer), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct2, addressof_glVDPAURegisterOutputSurfaceNV);
    }
    
    private native long dispatch_glVDPAURegisterOutputSurfaceNV1(final Object p0, final int p1, final boolean p2, final int p3, final int p4, final Object p5, final int p6, final boolean p7, final long p8);
    
    @Override
    public long glVDPAURegisterOutputSurfaceNV(final Buffer buffer, final int n, final int n2, final int[] array, final int n3) {
        final boolean direct = Buffers.isDirect(buffer);
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"textureNames_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVDPAURegisterOutputSurfaceNV = this._pat._addressof_glVDPAURegisterOutputSurfaceNV;
        if (addressof_glVDPAURegisterOutputSurfaceNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterOutputSurfaceNV"));
        }
        return this.dispatch_glVDPAURegisterOutputSurfaceNV1(direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, n, n2, array, 4 * n3, false, addressof_glVDPAURegisterOutputSurfaceNV);
    }
    
    @Override
    public boolean glVDPAUIsSurfaceNV(final long n) {
        final long addressof_glVDPAUIsSurfaceNV = this._pat._addressof_glVDPAUIsSurfaceNV;
        if (addressof_glVDPAUIsSurfaceNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUIsSurfaceNV"));
        }
        return this.dispatch_glVDPAUIsSurfaceNV1(n, addressof_glVDPAUIsSurfaceNV);
    }
    
    private native boolean dispatch_glVDPAUIsSurfaceNV1(final long p0, final long p1);
    
    @Override
    public void glVDPAUUnregisterSurfaceNV(final long n) {
        final long addressof_glVDPAUUnregisterSurfaceNV = this._pat._addressof_glVDPAUUnregisterSurfaceNV;
        if (addressof_glVDPAUUnregisterSurfaceNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUUnregisterSurfaceNV"));
        }
        this.dispatch_glVDPAUUnregisterSurfaceNV1(n, addressof_glVDPAUUnregisterSurfaceNV);
    }
    
    private native void dispatch_glVDPAUUnregisterSurfaceNV1(final long p0, final long p1);
    
    @Override
    public void glVDPAUGetSurfaceivNV(final long n, final int n2, final int n3, final IntBuffer intBuffer, final IntBuffer intBuffer2) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(intBuffer2);
        final long addressof_glVDPAUGetSurfaceivNV = this._pat._addressof_glVDPAUGetSurfaceivNV;
        if (addressof_glVDPAUGetSurfaceivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUGetSurfaceivNV"));
        }
        this.dispatch_glVDPAUGetSurfaceivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? intBuffer2 : Buffers.getArray(intBuffer2), direct2 ? Buffers.getDirectBufferByteOffset(intBuffer2) : Buffers.getIndirectBufferByteOffset(intBuffer2), direct2, addressof_glVDPAUGetSurfaceivNV);
    }
    
    private native void dispatch_glVDPAUGetSurfaceivNV1(final long p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final Object p6, final int p7, final boolean p8, final long p9);
    
    @Override
    public void glVDPAUGetSurfaceivNV(final long n, final int n2, final int n3, final int[] array, final int n4, final int[] array2, final int n5) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"length_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n5) {
            throw new GLException("array offset argument \"values_offset\" (" + n5 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glVDPAUGetSurfaceivNV = this._pat._addressof_glVDPAUGetSurfaceivNV;
        if (addressof_glVDPAUGetSurfaceivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUGetSurfaceivNV"));
        }
        this.dispatch_glVDPAUGetSurfaceivNV1(n, n2, n3, array, 4 * n4, false, array2, 4 * n5, false, addressof_glVDPAUGetSurfaceivNV);
    }
    
    @Override
    public void glVDPAUSurfaceAccessNV(final long n, final int n2) {
        final long addressof_glVDPAUSurfaceAccessNV = this._pat._addressof_glVDPAUSurfaceAccessNV;
        if (addressof_glVDPAUSurfaceAccessNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUSurfaceAccessNV"));
        }
        this.dispatch_glVDPAUSurfaceAccessNV1(n, n2, addressof_glVDPAUSurfaceAccessNV);
    }
    
    private native void dispatch_glVDPAUSurfaceAccessNV1(final long p0, final int p1, final long p2);
    
    @Override
    public void glVDPAUMapSurfacesNV(final int n, final PointerBuffer pointerBuffer) {
        if (!Buffers.isDirect(pointerBuffer)) {
            throw new GLException("Argument \"surfaces\" is not a direct buffer");
        }
        final long addressof_glVDPAUMapSurfacesNV = this._pat._addressof_glVDPAUMapSurfacesNV;
        if (addressof_glVDPAUMapSurfacesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUMapSurfacesNV"));
        }
        this.dispatch_glVDPAUMapSurfacesNV0(n, (pointerBuffer != null) ? pointerBuffer.getBuffer() : null, Buffers.getDirectBufferByteOffset(pointerBuffer), addressof_glVDPAUMapSurfacesNV);
    }
    
    private native void dispatch_glVDPAUMapSurfacesNV0(final int p0, final Object p1, final int p2, final long p3);
    
    @Override
    public void glVDPAUUnmapSurfacesNV(final int n, final PointerBuffer pointerBuffer) {
        if (!Buffers.isDirect(pointerBuffer)) {
            throw new GLException("Argument \"surfaces\" is not a direct buffer");
        }
        final long addressof_glVDPAUUnmapSurfacesNV = this._pat._addressof_glVDPAUUnmapSurfacesNV;
        if (addressof_glVDPAUUnmapSurfacesNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVDPAUUnmapSurfacesNV"));
        }
        this.dispatch_glVDPAUUnmapSurfacesNV0(n, (pointerBuffer != null) ? pointerBuffer.getBuffer() : null, Buffers.getDirectBufferByteOffset(pointerBuffer), addressof_glVDPAUUnmapSurfacesNV);
    }
    
    private native void dispatch_glVDPAUUnmapSurfacesNV0(final int p0, final Object p1, final int p2, final long p3);
    
    @Override
    public void glVertexAttribL1i64NV(final int n, final long n2) {
        final long addressof_glVertexAttribL1i64NV = this._pat._addressof_glVertexAttribL1i64NV;
        if (addressof_glVertexAttribL1i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1i64NV"));
        }
        this.dispatch_glVertexAttribL1i64NV1(n, n2, addressof_glVertexAttribL1i64NV);
    }
    
    private native void dispatch_glVertexAttribL1i64NV1(final int p0, final long p1, final long p2);
    
    @Override
    public void glVertexAttribL2i64NV(final int n, final long n2, final long n3) {
        final long addressof_glVertexAttribL2i64NV = this._pat._addressof_glVertexAttribL2i64NV;
        if (addressof_glVertexAttribL2i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2i64NV"));
        }
        this.dispatch_glVertexAttribL2i64NV1(n, n2, n3, addressof_glVertexAttribL2i64NV);
    }
    
    private native void dispatch_glVertexAttribL2i64NV1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glVertexAttribL3i64NV(final int n, final long n2, final long n3, final long n4) {
        final long addressof_glVertexAttribL3i64NV = this._pat._addressof_glVertexAttribL3i64NV;
        if (addressof_glVertexAttribL3i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3i64NV"));
        }
        this.dispatch_glVertexAttribL3i64NV1(n, n2, n3, n4, addressof_glVertexAttribL3i64NV);
    }
    
    private native void dispatch_glVertexAttribL3i64NV1(final int p0, final long p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glVertexAttribL4i64NV(final int n, final long n2, final long n3, final long n4, final long n5) {
        final long addressof_glVertexAttribL4i64NV = this._pat._addressof_glVertexAttribL4i64NV;
        if (addressof_glVertexAttribL4i64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4i64NV"));
        }
        this.dispatch_glVertexAttribL4i64NV1(n, n2, n3, n4, n5, addressof_glVertexAttribL4i64NV);
    }
    
    private native void dispatch_glVertexAttribL4i64NV1(final int p0, final long p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glVertexAttribL1i64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL1i64vNV = this._pat._addressof_glVertexAttribL1i64vNV;
        if (addressof_glVertexAttribL1i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1i64vNV"));
        }
        this.dispatch_glVertexAttribL1i64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL1i64vNV);
    }
    
    private native void dispatch_glVertexAttribL1i64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL1i64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL1i64vNV = this._pat._addressof_glVertexAttribL1i64vNV;
        if (addressof_glVertexAttribL1i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1i64vNV"));
        }
        this.dispatch_glVertexAttribL1i64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL1i64vNV);
    }
    
    @Override
    public void glVertexAttribL2i64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL2i64vNV = this._pat._addressof_glVertexAttribL2i64vNV;
        if (addressof_glVertexAttribL2i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2i64vNV"));
        }
        this.dispatch_glVertexAttribL2i64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL2i64vNV);
    }
    
    private native void dispatch_glVertexAttribL2i64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL2i64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL2i64vNV = this._pat._addressof_glVertexAttribL2i64vNV;
        if (addressof_glVertexAttribL2i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2i64vNV"));
        }
        this.dispatch_glVertexAttribL2i64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL2i64vNV);
    }
    
    @Override
    public void glVertexAttribL3i64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL3i64vNV = this._pat._addressof_glVertexAttribL3i64vNV;
        if (addressof_glVertexAttribL3i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3i64vNV"));
        }
        this.dispatch_glVertexAttribL3i64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL3i64vNV);
    }
    
    private native void dispatch_glVertexAttribL3i64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL3i64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL3i64vNV = this._pat._addressof_glVertexAttribL3i64vNV;
        if (addressof_glVertexAttribL3i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3i64vNV"));
        }
        this.dispatch_glVertexAttribL3i64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL3i64vNV);
    }
    
    @Override
    public void glVertexAttribL4i64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL4i64vNV = this._pat._addressof_glVertexAttribL4i64vNV;
        if (addressof_glVertexAttribL4i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4i64vNV"));
        }
        this.dispatch_glVertexAttribL4i64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL4i64vNV);
    }
    
    private native void dispatch_glVertexAttribL4i64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL4i64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL4i64vNV = this._pat._addressof_glVertexAttribL4i64vNV;
        if (addressof_glVertexAttribL4i64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4i64vNV"));
        }
        this.dispatch_glVertexAttribL4i64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL4i64vNV);
    }
    
    @Override
    public void glVertexAttribL1ui64NV(final int n, final long n2) {
        final long addressof_glVertexAttribL1ui64NV = this._pat._addressof_glVertexAttribL1ui64NV;
        if (addressof_glVertexAttribL1ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64NV"));
        }
        this.dispatch_glVertexAttribL1ui64NV1(n, n2, addressof_glVertexAttribL1ui64NV);
    }
    
    private native void dispatch_glVertexAttribL1ui64NV1(final int p0, final long p1, final long p2);
    
    @Override
    public void glVertexAttribL2ui64NV(final int n, final long n2, final long n3) {
        final long addressof_glVertexAttribL2ui64NV = this._pat._addressof_glVertexAttribL2ui64NV;
        if (addressof_glVertexAttribL2ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2ui64NV"));
        }
        this.dispatch_glVertexAttribL2ui64NV1(n, n2, n3, addressof_glVertexAttribL2ui64NV);
    }
    
    private native void dispatch_glVertexAttribL2ui64NV1(final int p0, final long p1, final long p2, final long p3);
    
    @Override
    public void glVertexAttribL3ui64NV(final int n, final long n2, final long n3, final long n4) {
        final long addressof_glVertexAttribL3ui64NV = this._pat._addressof_glVertexAttribL3ui64NV;
        if (addressof_glVertexAttribL3ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3ui64NV"));
        }
        this.dispatch_glVertexAttribL3ui64NV1(n, n2, n3, n4, addressof_glVertexAttribL3ui64NV);
    }
    
    private native void dispatch_glVertexAttribL3ui64NV1(final int p0, final long p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glVertexAttribL4ui64NV(final int n, final long n2, final long n3, final long n4, final long n5) {
        final long addressof_glVertexAttribL4ui64NV = this._pat._addressof_glVertexAttribL4ui64NV;
        if (addressof_glVertexAttribL4ui64NV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4ui64NV"));
        }
        this.dispatch_glVertexAttribL4ui64NV1(n, n2, n3, n4, n5, addressof_glVertexAttribL4ui64NV);
    }
    
    private native void dispatch_glVertexAttribL4ui64NV1(final int p0, final long p1, final long p2, final long p3, final long p4, final long p5);
    
    @Override
    public void glVertexAttribL1ui64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL1ui64vNV = this._pat._addressof_glVertexAttribL1ui64vNV;
        if (addressof_glVertexAttribL1ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vNV"));
        }
        this.dispatch_glVertexAttribL1ui64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL1ui64vNV);
    }
    
    private native void dispatch_glVertexAttribL1ui64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL1ui64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL1ui64vNV = this._pat._addressof_glVertexAttribL1ui64vNV;
        if (addressof_glVertexAttribL1ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vNV"));
        }
        this.dispatch_glVertexAttribL1ui64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL1ui64vNV);
    }
    
    @Override
    public void glVertexAttribL2ui64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL2ui64vNV = this._pat._addressof_glVertexAttribL2ui64vNV;
        if (addressof_glVertexAttribL2ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2ui64vNV"));
        }
        this.dispatch_glVertexAttribL2ui64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL2ui64vNV);
    }
    
    private native void dispatch_glVertexAttribL2ui64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL2ui64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL2ui64vNV = this._pat._addressof_glVertexAttribL2ui64vNV;
        if (addressof_glVertexAttribL2ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2ui64vNV"));
        }
        this.dispatch_glVertexAttribL2ui64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL2ui64vNV);
    }
    
    @Override
    public void glVertexAttribL3ui64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL3ui64vNV = this._pat._addressof_glVertexAttribL3ui64vNV;
        if (addressof_glVertexAttribL3ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3ui64vNV"));
        }
        this.dispatch_glVertexAttribL3ui64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL3ui64vNV);
    }
    
    private native void dispatch_glVertexAttribL3ui64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL3ui64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL3ui64vNV = this._pat._addressof_glVertexAttribL3ui64vNV;
        if (addressof_glVertexAttribL3ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3ui64vNV"));
        }
        this.dispatch_glVertexAttribL3ui64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL3ui64vNV);
    }
    
    @Override
    public void glVertexAttribL4ui64vNV(final int n, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glVertexAttribL4ui64vNV = this._pat._addressof_glVertexAttribL4ui64vNV;
        if (addressof_glVertexAttribL4ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4ui64vNV"));
        }
        this.dispatch_glVertexAttribL4ui64vNV1(n, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glVertexAttribL4ui64vNV);
    }
    
    private native void dispatch_glVertexAttribL4ui64vNV1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribL4ui64vNV(final int n, final long[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribL4ui64vNV = this._pat._addressof_glVertexAttribL4ui64vNV;
        if (addressof_glVertexAttribL4ui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4ui64vNV"));
        }
        this.dispatch_glVertexAttribL4ui64vNV1(n, array, 8 * n2, false, addressof_glVertexAttribL4ui64vNV);
    }
    
    @Override
    public void glGetVertexAttribLi64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetVertexAttribLi64vNV = this._pat._addressof_glGetVertexAttribLi64vNV;
        if (addressof_glGetVertexAttribLi64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLi64vNV"));
        }
        this.dispatch_glGetVertexAttribLi64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetVertexAttribLi64vNV);
    }
    
    private native void dispatch_glGetVertexAttribLi64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribLi64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribLi64vNV = this._pat._addressof_glGetVertexAttribLi64vNV;
        if (addressof_glGetVertexAttribLi64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLi64vNV"));
        }
        this.dispatch_glGetVertexAttribLi64vNV1(n, n2, array, 8 * n3, false, addressof_glGetVertexAttribLi64vNV);
    }
    
    @Override
    public void glGetVertexAttribLui64vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetVertexAttribLui64vNV = this._pat._addressof_glGetVertexAttribLui64vNV;
        if (addressof_glGetVertexAttribLui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vNV"));
        }
        this.dispatch_glGetVertexAttribLui64vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetVertexAttribLui64vNV);
    }
    
    private native void dispatch_glGetVertexAttribLui64vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribLui64vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribLui64vNV = this._pat._addressof_glGetVertexAttribLui64vNV;
        if (addressof_glGetVertexAttribLui64vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vNV"));
        }
        this.dispatch_glGetVertexAttribLui64vNV1(n, n2, array, 8 * n3, false, addressof_glGetVertexAttribLui64vNV);
    }
    
    @Override
    public void glVertexAttribLFormatNV(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribLFormatNV = this._pat._addressof_glVertexAttribLFormatNV;
        if (addressof_glVertexAttribLFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLFormatNV"));
        }
        this.dispatch_glVertexAttribLFormatNV1(n, n2, n3, n4, addressof_glVertexAttribLFormatNV);
    }
    
    private native void dispatch_glVertexAttribLFormatNV1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glBufferAddressRangeNV(final int n, final int n2, final long n3, final long n4) {
        final long addressof_glBufferAddressRangeNV = this._pat._addressof_glBufferAddressRangeNV;
        if (addressof_glBufferAddressRangeNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBufferAddressRangeNV"));
        }
        this.dispatch_glBufferAddressRangeNV1(n, n2, n3, n4, addressof_glBufferAddressRangeNV);
    }
    
    private native void dispatch_glBufferAddressRangeNV1(final int p0, final int p1, final long p2, final long p3, final long p4);
    
    @Override
    public void glVertexFormatNV(final int n, final int n2, final int n3) {
        final long addressof_glVertexFormatNV = this._pat._addressof_glVertexFormatNV;
        if (addressof_glVertexFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexFormatNV"));
        }
        this.dispatch_glVertexFormatNV1(n, n2, n3, addressof_glVertexFormatNV);
    }
    
    private native void dispatch_glVertexFormatNV1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glNormalFormatNV(final int n, final int n2) {
        final long addressof_glNormalFormatNV = this._pat._addressof_glNormalFormatNV;
        if (addressof_glNormalFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glNormalFormatNV"));
        }
        this.dispatch_glNormalFormatNV1(n, n2, addressof_glNormalFormatNV);
    }
    
    private native void dispatch_glNormalFormatNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glColorFormatNV(final int n, final int n2, final int n3) {
        final long addressof_glColorFormatNV = this._pat._addressof_glColorFormatNV;
        if (addressof_glColorFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glColorFormatNV"));
        }
        this.dispatch_glColorFormatNV1(n, n2, n3, addressof_glColorFormatNV);
    }
    
    private native void dispatch_glColorFormatNV1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glIndexFormatNV(final int n, final int n2) {
        final long addressof_glIndexFormatNV = this._pat._addressof_glIndexFormatNV;
        if (addressof_glIndexFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glIndexFormatNV"));
        }
        this.dispatch_glIndexFormatNV1(n, n2, addressof_glIndexFormatNV);
    }
    
    private native void dispatch_glIndexFormatNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glTexCoordFormatNV(final int n, final int n2, final int n3) {
        final long addressof_glTexCoordFormatNV = this._pat._addressof_glTexCoordFormatNV;
        if (addressof_glTexCoordFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glTexCoordFormatNV"));
        }
        this.dispatch_glTexCoordFormatNV1(n, n2, n3, addressof_glTexCoordFormatNV);
    }
    
    private native void dispatch_glTexCoordFormatNV1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glEdgeFlagFormatNV(final int n) {
        final long addressof_glEdgeFlagFormatNV = this._pat._addressof_glEdgeFlagFormatNV;
        if (addressof_glEdgeFlagFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagFormatNV"));
        }
        this.dispatch_glEdgeFlagFormatNV1(n, addressof_glEdgeFlagFormatNV);
    }
    
    private native void dispatch_glEdgeFlagFormatNV1(final int p0, final long p1);
    
    @Override
    public void glSecondaryColorFormatNV(final int n, final int n2, final int n3) {
        final long addressof_glSecondaryColorFormatNV = this._pat._addressof_glSecondaryColorFormatNV;
        if (addressof_glSecondaryColorFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorFormatNV"));
        }
        this.dispatch_glSecondaryColorFormatNV1(n, n2, n3, addressof_glSecondaryColorFormatNV);
    }
    
    private native void dispatch_glSecondaryColorFormatNV1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glFogCoordFormatNV(final int n, final int n2) {
        final long addressof_glFogCoordFormatNV = this._pat._addressof_glFogCoordFormatNV;
        if (addressof_glFogCoordFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFogCoordFormatNV"));
        }
        this.dispatch_glFogCoordFormatNV1(n, n2, addressof_glFogCoordFormatNV);
    }
    
    private native void dispatch_glFogCoordFormatNV1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexAttribFormatNV(final int n, final int n2, final int n3, final boolean b, final int n4) {
        final long addressof_glVertexAttribFormatNV = this._pat._addressof_glVertexAttribFormatNV;
        if (addressof_glVertexAttribFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribFormatNV"));
        }
        this.dispatch_glVertexAttribFormatNV1(n, n2, n3, b, n4, addressof_glVertexAttribFormatNV);
    }
    
    private native void dispatch_glVertexAttribFormatNV1(final int p0, final int p1, final int p2, final boolean p3, final int p4, final long p5);
    
    @Override
    public void glVertexAttribIFormatNV(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribIFormatNV = this._pat._addressof_glVertexAttribIFormatNV;
        if (addressof_glVertexAttribIFormatNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIFormatNV"));
        }
        this.dispatch_glVertexAttribIFormatNV1(n, n2, n3, n4, addressof_glVertexAttribIFormatNV);
    }
    
    private native void dispatch_glVertexAttribIFormatNV1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glGetIntegerui64i_vNV(final int n, final int n2, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(longBuffer);
        final long addressof_glGetIntegerui64i_vNV = this._pat._addressof_glGetIntegerui64i_vNV;
        if (addressof_glGetIntegerui64i_vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64i_vNV"));
        }
        this.dispatch_glGetIntegerui64i_vNV1(n, n2, direct ? longBuffer : Buffers.getArray(longBuffer), direct ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct, addressof_glGetIntegerui64i_vNV);
    }
    
    private native void dispatch_glGetIntegerui64i_vNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetIntegerui64i_vNV(final int n, final int n2, final long[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"result_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetIntegerui64i_vNV = this._pat._addressof_glGetIntegerui64i_vNV;
        if (addressof_glGetIntegerui64i_vNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64i_vNV"));
        }
        this.dispatch_glGetIntegerui64i_vNV1(n, n2, array, 8 * n3, false, addressof_glGetIntegerui64i_vNV);
    }
    
    @Override
    public void glVertexAttribI1iEXT(final int n, final int n2) {
        final long addressof_glVertexAttribI1iEXT = this._pat._addressof_glVertexAttribI1iEXT;
        if (addressof_glVertexAttribI1iEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1iEXT"));
        }
        this.dispatch_glVertexAttribI1iEXT1(n, n2, addressof_glVertexAttribI1iEXT);
    }
    
    private native void dispatch_glVertexAttribI1iEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexAttribI2iEXT(final int n, final int n2, final int n3) {
        final long addressof_glVertexAttribI2iEXT = this._pat._addressof_glVertexAttribI2iEXT;
        if (addressof_glVertexAttribI2iEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2iEXT"));
        }
        this.dispatch_glVertexAttribI2iEXT1(n, n2, n3, addressof_glVertexAttribI2iEXT);
    }
    
    private native void dispatch_glVertexAttribI2iEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexAttribI3iEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribI3iEXT = this._pat._addressof_glVertexAttribI3iEXT;
        if (addressof_glVertexAttribI3iEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3iEXT"));
        }
        this.dispatch_glVertexAttribI3iEXT1(n, n2, n3, n4, addressof_glVertexAttribI3iEXT);
    }
    
    private native void dispatch_glVertexAttribI3iEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribI4iEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexAttribI4iEXT = this._pat._addressof_glVertexAttribI4iEXT;
        if (addressof_glVertexAttribI4iEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iEXT"));
        }
        this.dispatch_glVertexAttribI4iEXT1(n, n2, n3, n4, n5, addressof_glVertexAttribI4iEXT);
    }
    
    private native void dispatch_glVertexAttribI4iEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexAttribI1uiEXT(final int n, final int n2) {
        final long addressof_glVertexAttribI1uiEXT = this._pat._addressof_glVertexAttribI1uiEXT;
        if (addressof_glVertexAttribI1uiEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uiEXT"));
        }
        this.dispatch_glVertexAttribI1uiEXT1(n, n2, addressof_glVertexAttribI1uiEXT);
    }
    
    private native void dispatch_glVertexAttribI1uiEXT1(final int p0, final int p1, final long p2);
    
    @Override
    public void glVertexAttribI2uiEXT(final int n, final int n2, final int n3) {
        final long addressof_glVertexAttribI2uiEXT = this._pat._addressof_glVertexAttribI2uiEXT;
        if (addressof_glVertexAttribI2uiEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uiEXT"));
        }
        this.dispatch_glVertexAttribI2uiEXT1(n, n2, n3, addressof_glVertexAttribI2uiEXT);
    }
    
    private native void dispatch_glVertexAttribI2uiEXT1(final int p0, final int p1, final int p2, final long p3);
    
    @Override
    public void glVertexAttribI3uiEXT(final int n, final int n2, final int n3, final int n4) {
        final long addressof_glVertexAttribI3uiEXT = this._pat._addressof_glVertexAttribI3uiEXT;
        if (addressof_glVertexAttribI3uiEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uiEXT"));
        }
        this.dispatch_glVertexAttribI3uiEXT1(n, n2, n3, n4, addressof_glVertexAttribI3uiEXT);
    }
    
    private native void dispatch_glVertexAttribI3uiEXT1(final int p0, final int p1, final int p2, final int p3, final long p4);
    
    @Override
    public void glVertexAttribI4uiEXT(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glVertexAttribI4uiEXT = this._pat._addressof_glVertexAttribI4uiEXT;
        if (addressof_glVertexAttribI4uiEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiEXT"));
        }
        this.dispatch_glVertexAttribI4uiEXT1(n, n2, n3, n4, n5, addressof_glVertexAttribI4uiEXT);
    }
    
    private native void dispatch_glVertexAttribI4uiEXT1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glVertexAttribI1ivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI1ivEXT = this._pat._addressof_glVertexAttribI1ivEXT;
        if (addressof_glVertexAttribI1ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1ivEXT"));
        }
        this.dispatch_glVertexAttribI1ivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI1ivEXT);
    }
    
    private native void dispatch_glVertexAttribI1ivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI1ivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI1ivEXT = this._pat._addressof_glVertexAttribI1ivEXT;
        if (addressof_glVertexAttribI1ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1ivEXT"));
        }
        this.dispatch_glVertexAttribI1ivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI1ivEXT);
    }
    
    @Override
    public void glVertexAttribI2ivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI2ivEXT = this._pat._addressof_glVertexAttribI2ivEXT;
        if (addressof_glVertexAttribI2ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2ivEXT"));
        }
        this.dispatch_glVertexAttribI2ivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI2ivEXT);
    }
    
    private native void dispatch_glVertexAttribI2ivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI2ivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI2ivEXT = this._pat._addressof_glVertexAttribI2ivEXT;
        if (addressof_glVertexAttribI2ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2ivEXT"));
        }
        this.dispatch_glVertexAttribI2ivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI2ivEXT);
    }
    
    @Override
    public void glVertexAttribI3ivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI3ivEXT = this._pat._addressof_glVertexAttribI3ivEXT;
        if (addressof_glVertexAttribI3ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3ivEXT"));
        }
        this.dispatch_glVertexAttribI3ivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI3ivEXT);
    }
    
    private native void dispatch_glVertexAttribI3ivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI3ivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI3ivEXT = this._pat._addressof_glVertexAttribI3ivEXT;
        if (addressof_glVertexAttribI3ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3ivEXT"));
        }
        this.dispatch_glVertexAttribI3ivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI3ivEXT);
    }
    
    @Override
    public void glVertexAttribI4ivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI4ivEXT = this._pat._addressof_glVertexAttribI4ivEXT;
        if (addressof_glVertexAttribI4ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ivEXT"));
        }
        this.dispatch_glVertexAttribI4ivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI4ivEXT);
    }
    
    private native void dispatch_glVertexAttribI4ivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4ivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4ivEXT = this._pat._addressof_glVertexAttribI4ivEXT;
        if (addressof_glVertexAttribI4ivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ivEXT"));
        }
        this.dispatch_glVertexAttribI4ivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI4ivEXT);
    }
    
    @Override
    public void glVertexAttribI1uivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI1uivEXT = this._pat._addressof_glVertexAttribI1uivEXT;
        if (addressof_glVertexAttribI1uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uivEXT"));
        }
        this.dispatch_glVertexAttribI1uivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI1uivEXT);
    }
    
    private native void dispatch_glVertexAttribI1uivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI1uivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI1uivEXT = this._pat._addressof_glVertexAttribI1uivEXT;
        if (addressof_glVertexAttribI1uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uivEXT"));
        }
        this.dispatch_glVertexAttribI1uivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI1uivEXT);
    }
    
    @Override
    public void glVertexAttribI2uivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI2uivEXT = this._pat._addressof_glVertexAttribI2uivEXT;
        if (addressof_glVertexAttribI2uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uivEXT"));
        }
        this.dispatch_glVertexAttribI2uivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI2uivEXT);
    }
    
    private native void dispatch_glVertexAttribI2uivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI2uivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI2uivEXT = this._pat._addressof_glVertexAttribI2uivEXT;
        if (addressof_glVertexAttribI2uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uivEXT"));
        }
        this.dispatch_glVertexAttribI2uivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI2uivEXT);
    }
    
    @Override
    public void glVertexAttribI3uivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI3uivEXT = this._pat._addressof_glVertexAttribI3uivEXT;
        if (addressof_glVertexAttribI3uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uivEXT"));
        }
        this.dispatch_glVertexAttribI3uivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI3uivEXT);
    }
    
    private native void dispatch_glVertexAttribI3uivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI3uivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI3uivEXT = this._pat._addressof_glVertexAttribI3uivEXT;
        if (addressof_glVertexAttribI3uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uivEXT"));
        }
        this.dispatch_glVertexAttribI3uivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI3uivEXT);
    }
    
    @Override
    public void glVertexAttribI4uivEXT(final int n, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVertexAttribI4uivEXT = this._pat._addressof_glVertexAttribI4uivEXT;
        if (addressof_glVertexAttribI4uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uivEXT"));
        }
        this.dispatch_glVertexAttribI4uivEXT1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVertexAttribI4uivEXT);
    }
    
    private native void dispatch_glVertexAttribI4uivEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4uivEXT(final int n, final int[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4uivEXT = this._pat._addressof_glVertexAttribI4uivEXT;
        if (addressof_glVertexAttribI4uivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uivEXT"));
        }
        this.dispatch_glVertexAttribI4uivEXT1(n, array, 4 * n2, false, addressof_glVertexAttribI4uivEXT);
    }
    
    @Override
    public void glVertexAttribI4bvEXT(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttribI4bvEXT = this._pat._addressof_glVertexAttribI4bvEXT;
        if (addressof_glVertexAttribI4bvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bvEXT"));
        }
        this.dispatch_glVertexAttribI4bvEXT1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttribI4bvEXT);
    }
    
    private native void dispatch_glVertexAttribI4bvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4bvEXT(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4bvEXT = this._pat._addressof_glVertexAttribI4bvEXT;
        if (addressof_glVertexAttribI4bvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bvEXT"));
        }
        this.dispatch_glVertexAttribI4bvEXT1(n, array, n2, false, addressof_glVertexAttribI4bvEXT);
    }
    
    @Override
    public void glVertexAttribI4svEXT(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribI4svEXT = this._pat._addressof_glVertexAttribI4svEXT;
        if (addressof_glVertexAttribI4svEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4svEXT"));
        }
        this.dispatch_glVertexAttribI4svEXT1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribI4svEXT);
    }
    
    private native void dispatch_glVertexAttribI4svEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4svEXT(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4svEXT = this._pat._addressof_glVertexAttribI4svEXT;
        if (addressof_glVertexAttribI4svEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4svEXT"));
        }
        this.dispatch_glVertexAttribI4svEXT1(n, array, 2 * n2, false, addressof_glVertexAttribI4svEXT);
    }
    
    @Override
    public void glVertexAttribI4ubvEXT(final int n, final ByteBuffer byteBuffer) {
        final boolean direct = Buffers.isDirect(byteBuffer);
        final long addressof_glVertexAttribI4ubvEXT = this._pat._addressof_glVertexAttribI4ubvEXT;
        if (addressof_glVertexAttribI4ubvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubvEXT"));
        }
        this.dispatch_glVertexAttribI4ubvEXT1(n, direct ? byteBuffer : Buffers.getArray(byteBuffer), direct ? Buffers.getDirectBufferByteOffset(byteBuffer) : Buffers.getIndirectBufferByteOffset(byteBuffer), direct, addressof_glVertexAttribI4ubvEXT);
    }
    
    private native void dispatch_glVertexAttribI4ubvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4ubvEXT(final int n, final byte[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4ubvEXT = this._pat._addressof_glVertexAttribI4ubvEXT;
        if (addressof_glVertexAttribI4ubvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubvEXT"));
        }
        this.dispatch_glVertexAttribI4ubvEXT1(n, array, n2, false, addressof_glVertexAttribI4ubvEXT);
    }
    
    @Override
    public void glVertexAttribI4usvEXT(final int n, final ShortBuffer shortBuffer) {
        final boolean direct = Buffers.isDirect(shortBuffer);
        final long addressof_glVertexAttribI4usvEXT = this._pat._addressof_glVertexAttribI4usvEXT;
        if (addressof_glVertexAttribI4usvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usvEXT"));
        }
        this.dispatch_glVertexAttribI4usvEXT1(n, direct ? shortBuffer : Buffers.getArray(shortBuffer), direct ? Buffers.getDirectBufferByteOffset(shortBuffer) : Buffers.getIndirectBufferByteOffset(shortBuffer), direct, addressof_glVertexAttribI4usvEXT);
    }
    
    private native void dispatch_glVertexAttribI4usvEXT1(final int p0, final Object p1, final int p2, final boolean p3, final long p4);
    
    @Override
    public void glVertexAttribI4usvEXT(final int n, final short[] array, final int n2) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"v_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVertexAttribI4usvEXT = this._pat._addressof_glVertexAttribI4usvEXT;
        if (addressof_glVertexAttribI4usvEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usvEXT"));
        }
        this.dispatch_glVertexAttribI4usvEXT1(n, array, 2 * n2, false, addressof_glVertexAttribI4usvEXT);
    }
    
    @Override
    public void glVertexAttribIPointerEXT(final int n, final int n2, final int n3, final int n4, final Buffer buffer) {
        final boolean direct = Buffers.isDirect(buffer);
        final long addressof_glVertexAttribIPointerEXT = this._pat._addressof_glVertexAttribIPointerEXT;
        if (addressof_glVertexAttribIPointerEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointerEXT"));
        }
        this.dispatch_glVertexAttribIPointerEXT1(n, n2, n3, n4, direct ? buffer : Buffers.getArray(buffer), direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), direct, addressof_glVertexAttribIPointerEXT);
    }
    
    private native void dispatch_glVertexAttribIPointerEXT1(final int p0, final int p1, final int p2, final int p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public void glGetVertexAttribIivEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexAttribIivEXT = this._pat._addressof_glGetVertexAttribIivEXT;
        if (addressof_glGetVertexAttribIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIivEXT"));
        }
        this.dispatch_glGetVertexAttribIivEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexAttribIivEXT);
    }
    
    private native void dispatch_glGetVertexAttribIivEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribIivEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribIivEXT = this._pat._addressof_glGetVertexAttribIivEXT;
        if (addressof_glGetVertexAttribIivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIivEXT"));
        }
        this.dispatch_glGetVertexAttribIivEXT1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribIivEXT);
    }
    
    @Override
    public void glGetVertexAttribIuivEXT(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVertexAttribIuivEXT = this._pat._addressof_glGetVertexAttribIuivEXT;
        if (addressof_glGetVertexAttribIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuivEXT"));
        }
        this.dispatch_glGetVertexAttribIuivEXT1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVertexAttribIuivEXT);
    }
    
    private native void dispatch_glGetVertexAttribIuivEXT1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVertexAttribIuivEXT(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVertexAttribIuivEXT = this._pat._addressof_glGetVertexAttribIuivEXT;
        if (addressof_glGetVertexAttribIuivEXT == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuivEXT"));
        }
        this.dispatch_glGetVertexAttribIuivEXT1(n, n2, array, 4 * n3, false, addressof_glGetVertexAttribIuivEXT);
    }
    
    @Override
    public void glBeginVideoCaptureNV(final int n) {
        final long addressof_glBeginVideoCaptureNV = this._pat._addressof_glBeginVideoCaptureNV;
        if (addressof_glBeginVideoCaptureNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBeginVideoCaptureNV"));
        }
        this.dispatch_glBeginVideoCaptureNV1(n, addressof_glBeginVideoCaptureNV);
    }
    
    private native void dispatch_glBeginVideoCaptureNV1(final int p0, final long p1);
    
    @Override
    public void glBindVideoCaptureStreamBufferNV(final int n, final int n2, final int n3, final long n4) {
        final long addressof_glBindVideoCaptureStreamBufferNV = this._pat._addressof_glBindVideoCaptureStreamBufferNV;
        if (addressof_glBindVideoCaptureStreamBufferNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindVideoCaptureStreamBufferNV"));
        }
        this.dispatch_glBindVideoCaptureStreamBufferNV1(n, n2, n3, n4, addressof_glBindVideoCaptureStreamBufferNV);
    }
    
    private native void dispatch_glBindVideoCaptureStreamBufferNV1(final int p0, final int p1, final int p2, final long p3, final long p4);
    
    @Override
    public void glBindVideoCaptureStreamTextureNV(final int n, final int n2, final int n3, final int n4, final int n5) {
        final long addressof_glBindVideoCaptureStreamTextureNV = this._pat._addressof_glBindVideoCaptureStreamTextureNV;
        if (addressof_glBindVideoCaptureStreamTextureNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glBindVideoCaptureStreamTextureNV"));
        }
        this.dispatch_glBindVideoCaptureStreamTextureNV1(n, n2, n3, n4, n5, addressof_glBindVideoCaptureStreamTextureNV);
    }
    
    private native void dispatch_glBindVideoCaptureStreamTextureNV1(final int p0, final int p1, final int p2, final int p3, final int p4, final long p5);
    
    @Override
    public void glEndVideoCaptureNV(final int n) {
        final long addressof_glEndVideoCaptureNV = this._pat._addressof_glEndVideoCaptureNV;
        if (addressof_glEndVideoCaptureNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glEndVideoCaptureNV"));
        }
        this.dispatch_glEndVideoCaptureNV1(n, addressof_glEndVideoCaptureNV);
    }
    
    private native void dispatch_glEndVideoCaptureNV1(final int p0, final long p1);
    
    @Override
    public void glGetVideoCaptureivNV(final int n, final int n2, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVideoCaptureivNV = this._pat._addressof_glGetVideoCaptureivNV;
        if (addressof_glGetVideoCaptureivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureivNV"));
        }
        this.dispatch_glGetVideoCaptureivNV1(n, n2, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVideoCaptureivNV);
    }
    
    private native void dispatch_glGetVideoCaptureivNV1(final int p0, final int p1, final Object p2, final int p3, final boolean p4, final long p5);
    
    @Override
    public void glGetVideoCaptureivNV(final int n, final int n2, final int[] array, final int n3) {
        if (array != null && array.length <= n3) {
            throw new GLException("array offset argument \"params_offset\" (" + n3 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVideoCaptureivNV = this._pat._addressof_glGetVideoCaptureivNV;
        if (addressof_glGetVideoCaptureivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureivNV"));
        }
        this.dispatch_glGetVideoCaptureivNV1(n, n2, array, 4 * n3, false, addressof_glGetVideoCaptureivNV);
    }
    
    @Override
    public void glGetVideoCaptureStreamivNV(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glGetVideoCaptureStreamivNV = this._pat._addressof_glGetVideoCaptureStreamivNV;
        if (addressof_glGetVideoCaptureStreamivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamivNV"));
        }
        this.dispatch_glGetVideoCaptureStreamivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glGetVideoCaptureStreamivNV);
    }
    
    private native void dispatch_glGetVideoCaptureStreamivNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetVideoCaptureStreamivNV(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVideoCaptureStreamivNV = this._pat._addressof_glGetVideoCaptureStreamivNV;
        if (addressof_glGetVideoCaptureStreamivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamivNV"));
        }
        this.dispatch_glGetVideoCaptureStreamivNV1(n, n2, n3, array, 4 * n4, false, addressof_glGetVideoCaptureStreamivNV);
    }
    
    @Override
    public void glGetVideoCaptureStreamfvNV(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glGetVideoCaptureStreamfvNV = this._pat._addressof_glGetVideoCaptureStreamfvNV;
        if (addressof_glGetVideoCaptureStreamfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamfvNV"));
        }
        this.dispatch_glGetVideoCaptureStreamfvNV1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glGetVideoCaptureStreamfvNV);
    }
    
    private native void dispatch_glGetVideoCaptureStreamfvNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetVideoCaptureStreamfvNV(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVideoCaptureStreamfvNV = this._pat._addressof_glGetVideoCaptureStreamfvNV;
        if (addressof_glGetVideoCaptureStreamfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamfvNV"));
        }
        this.dispatch_glGetVideoCaptureStreamfvNV1(n, n2, n3, array, 4 * n4, false, addressof_glGetVideoCaptureStreamfvNV);
    }
    
    @Override
    public void glGetVideoCaptureStreamdvNV(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glGetVideoCaptureStreamdvNV = this._pat._addressof_glGetVideoCaptureStreamdvNV;
        if (addressof_glGetVideoCaptureStreamdvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamdvNV"));
        }
        this.dispatch_glGetVideoCaptureStreamdvNV1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glGetVideoCaptureStreamdvNV);
    }
    
    private native void dispatch_glGetVideoCaptureStreamdvNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glGetVideoCaptureStreamdvNV(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glGetVideoCaptureStreamdvNV = this._pat._addressof_glGetVideoCaptureStreamdvNV;
        if (addressof_glGetVideoCaptureStreamdvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamdvNV"));
        }
        this.dispatch_glGetVideoCaptureStreamdvNV1(n, n2, n3, array, 8 * n4, false, addressof_glGetVideoCaptureStreamdvNV);
    }
    
    @Override
    public int glVideoCaptureNV(final int n, final IntBuffer intBuffer, final LongBuffer longBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final boolean direct2 = Buffers.isDirect(longBuffer);
        final long addressof_glVideoCaptureNV = this._pat._addressof_glVideoCaptureNV;
        if (addressof_glVideoCaptureNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureNV"));
        }
        return this.dispatch_glVideoCaptureNV1(n, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, direct2 ? longBuffer : Buffers.getArray(longBuffer), direct2 ? Buffers.getDirectBufferByteOffset(longBuffer) : Buffers.getIndirectBufferByteOffset(longBuffer), direct2, addressof_glVideoCaptureNV);
    }
    
    private native int dispatch_glVideoCaptureNV1(final int p0, final Object p1, final int p2, final boolean p3, final Object p4, final int p5, final boolean p6, final long p7);
    
    @Override
    public int glVideoCaptureNV(final int n, final int[] array, final int n2, final long[] array2, final int n3) {
        if (array != null && array.length <= n2) {
            throw new GLException("array offset argument \"sequence_num_offset\" (" + n2 + ") equals or exceeds array length (" + array.length + ")");
        }
        if (array2 != null && array2.length <= n3) {
            throw new GLException("array offset argument \"capture_time_offset\" (" + n3 + ") equals or exceeds array length (" + array2.length + ")");
        }
        final long addressof_glVideoCaptureNV = this._pat._addressof_glVideoCaptureNV;
        if (addressof_glVideoCaptureNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureNV"));
        }
        return this.dispatch_glVideoCaptureNV1(n, array, 4 * n2, false, array2, 8 * n3, false, addressof_glVideoCaptureNV);
    }
    
    @Override
    public void glVideoCaptureStreamParameterivNV(final int n, final int n2, final int n3, final IntBuffer intBuffer) {
        final boolean direct = Buffers.isDirect(intBuffer);
        final long addressof_glVideoCaptureStreamParameterivNV = this._pat._addressof_glVideoCaptureStreamParameterivNV;
        if (addressof_glVideoCaptureStreamParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterivNV"));
        }
        this.dispatch_glVideoCaptureStreamParameterivNV1(n, n2, n3, direct ? intBuffer : Buffers.getArray(intBuffer), direct ? Buffers.getDirectBufferByteOffset(intBuffer) : Buffers.getIndirectBufferByteOffset(intBuffer), direct, addressof_glVideoCaptureStreamParameterivNV);
    }
    
    private native void dispatch_glVideoCaptureStreamParameterivNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVideoCaptureStreamParameterivNV(final int n, final int n2, final int n3, final int[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVideoCaptureStreamParameterivNV = this._pat._addressof_glVideoCaptureStreamParameterivNV;
        if (addressof_glVideoCaptureStreamParameterivNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterivNV"));
        }
        this.dispatch_glVideoCaptureStreamParameterivNV1(n, n2, n3, array, 4 * n4, false, addressof_glVideoCaptureStreamParameterivNV);
    }
    
    @Override
    public void glVideoCaptureStreamParameterfvNV(final int n, final int n2, final int n3, final FloatBuffer floatBuffer) {
        final boolean direct = Buffers.isDirect(floatBuffer);
        final long addressof_glVideoCaptureStreamParameterfvNV = this._pat._addressof_glVideoCaptureStreamParameterfvNV;
        if (addressof_glVideoCaptureStreamParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterfvNV"));
        }
        this.dispatch_glVideoCaptureStreamParameterfvNV1(n, n2, n3, direct ? floatBuffer : Buffers.getArray(floatBuffer), direct ? Buffers.getDirectBufferByteOffset(floatBuffer) : Buffers.getIndirectBufferByteOffset(floatBuffer), direct, addressof_glVideoCaptureStreamParameterfvNV);
    }
    
    private native void dispatch_glVideoCaptureStreamParameterfvNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVideoCaptureStreamParameterfvNV(final int n, final int n2, final int n3, final float[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVideoCaptureStreamParameterfvNV = this._pat._addressof_glVideoCaptureStreamParameterfvNV;
        if (addressof_glVideoCaptureStreamParameterfvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterfvNV"));
        }
        this.dispatch_glVideoCaptureStreamParameterfvNV1(n, n2, n3, array, 4 * n4, false, addressof_glVideoCaptureStreamParameterfvNV);
    }
    
    @Override
    public void glVideoCaptureStreamParameterdvNV(final int n, final int n2, final int n3, final DoubleBuffer doubleBuffer) {
        final boolean direct = Buffers.isDirect(doubleBuffer);
        final long addressof_glVideoCaptureStreamParameterdvNV = this._pat._addressof_glVideoCaptureStreamParameterdvNV;
        if (addressof_glVideoCaptureStreamParameterdvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterdvNV"));
        }
        this.dispatch_glVideoCaptureStreamParameterdvNV1(n, n2, n3, direct ? doubleBuffer : Buffers.getArray(doubleBuffer), direct ? Buffers.getDirectBufferByteOffset(doubleBuffer) : Buffers.getIndirectBufferByteOffset(doubleBuffer), direct, addressof_glVideoCaptureStreamParameterdvNV);
    }
    
    private native void dispatch_glVideoCaptureStreamParameterdvNV1(final int p0, final int p1, final int p2, final Object p3, final int p4, final boolean p5, final long p6);
    
    @Override
    public void glVideoCaptureStreamParameterdvNV(final int n, final int n2, final int n3, final double[] array, final int n4) {
        if (array != null && array.length <= n4) {
            throw new GLException("array offset argument \"params_offset\" (" + n4 + ") equals or exceeds array length (" + array.length + ")");
        }
        final long addressof_glVideoCaptureStreamParameterdvNV = this._pat._addressof_glVideoCaptureStreamParameterdvNV;
        if (addressof_glVideoCaptureStreamParameterdvNV == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterdvNV"));
        }
        this.dispatch_glVideoCaptureStreamParameterdvNV1(n, n2, n3, array, 8 * n4, false, addressof_glVideoCaptureStreamParameterdvNV);
    }
    
    @Override
    public void glFramebufferTextureMultiviewOVR(final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {
        final long addressof_glFramebufferTextureMultiviewOVR = this._pat._addressof_glFramebufferTextureMultiviewOVR;
        if (addressof_glFramebufferTextureMultiviewOVR == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureMultiviewOVR"));
        }
        this.dispatch_glFramebufferTextureMultiviewOVR1(n, n2, n3, n4, n5, n6, addressof_glFramebufferTextureMultiviewOVR);
    }
    
    private native void dispatch_glFramebufferTextureMultiviewOVR1(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5, final long p6);
    
    @Override
    public void glHintPGI(final int n, final int n2) {
        final long addressof_glHintPGI = this._pat._addressof_glHintPGI;
        if (addressof_glHintPGI == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glHintPGI"));
        }
        this.dispatch_glHintPGI1(n, n2, addressof_glHintPGI);
    }
    
    private native void dispatch_glHintPGI1(final int p0, final int p1, final long p2);
    
    @Override
    public void glFinishTextureSUNX() {
        final long addressof_glFinishTextureSUNX = this._pat._addressof_glFinishTextureSUNX;
        if (addressof_glFinishTextureSUNX == 0L) {
            throw new GLException(String.format("Method \"%s\" not available", "glFinishTextureSUNX"));
        }
        this.dispatch_glFinishTextureSUNX1(addressof_glFinishTextureSUNX);
    }
    
    private native void dispatch_glFinishTextureSUNX1(final long p0);
    
    @Override
    public GLProfile getGLProfile() {
        return this.glProfile;
    }
    
    @Override
    public final int getBoundBuffer(final int n) {
        return this.bufferStateTracker.getBoundBufferObject(n, this);
    }
    
    @Override
    public final GLBufferStorage getBufferStorage(final int n) {
        return this.bufferObjectTracker.getBufferStorage(n);
    }
    
    @Override
    public final boolean isVBOArrayBound() {
        return this.checkArrayVBOBound(false);
    }
    
    @Override
    public final boolean isVBOElementArrayBound() {
        return this.checkElementVBOBound(false);
    }
    
    @Override
    public final GL getDownstreamGL() throws GLException {
        return null;
    }
    
    @Override
    public final GL getRootGL() throws GLException {
        return this;
    }
    
    @Override
    public final boolean isGL() {
        return true;
    }
    
    @Override
    public final GL getGL() throws GLException {
        return this;
    }
    
    @Override
    public final boolean isFunctionAvailable(final String s) {
        return this._context.isFunctionAvailable(s);
    }
    
    @Override
    public final boolean isExtensionAvailable(final String s) {
        return this._context.isExtensionAvailable(s);
    }
    
    @Override
    public final Object getExtension(final String s) {
        return null;
    }
    
    @Override
    public final boolean hasBasicFBOSupport() {
        return this._context.hasBasicFBOSupport();
    }
    
    @Override
    public final boolean hasFullFBOSupport() {
        return this._context.hasFullFBOSupport();
    }
    
    @Override
    public final int getMaxRenderbufferSamples() {
        return this._context.getMaxRenderbufferSamples();
    }
    
    @Override
    public final boolean isTextureFormatBGRA8888Available() {
        return this._context.isTextureFormatBGRA8888Available();
    }
    
    @Override
    public final GLContext getContext() {
        return this._context;
    }
    
    @Override
    public final void setSwapInterval(final int swapInterval) {
        this._context.setSwapInterval(swapInterval);
    }
    
    @Override
    public final int getSwapInterval() {
        return this._context.getSwapInterval();
    }
    
    @Override
    public final Object getPlatformGLExtensions() {
        return this._context.getPlatformGLExtensions();
    }
    
    @Override
    public final int getBoundFramebuffer(final int n) {
        return this._context.getBoundFramebuffer(n);
    }
    
    @Override
    public final int getDefaultDrawFramebuffer() {
        return this._context.getDefaultDrawFramebuffer();
    }
    
    @Override
    public final int getDefaultReadFramebuffer() {
        return this._context.getDefaultReadFramebuffer();
    }
    
    @Override
    public final int getDefaultReadBuffer() {
        return this._context.getDefaultReadBuffer();
    }
    
    @Override
    public final void glBufferData(final int n, final long n2, final Buffer buffer, final int n3) {
        this.bufferObjectTracker.createBufferStorage(this.bufferStateTracker, this, n, n2, buffer, n3, 0, this.glBufferDataDispatch);
    }
    
    @Override
    public boolean glUnmapBuffer(final int n) {
        return this.bufferObjectTracker.unmapBuffer(this.bufferStateTracker, this, n, this.glUnmapBufferDispatch);
    }
    
    @Override
    public final ByteBuffer glMapBuffer(final int n, final int n2) {
        return this.mapBuffer(n, n2).getMappedBuffer();
    }
    
    @Override
    public final GLBufferStorage mapBuffer(final int n, final int n2) {
        return this.bufferObjectTracker.mapBuffer(this.bufferStateTracker, this, n, n2, this.glMapBufferDispatch);
    }
    
    @Override
    public final ByteBuffer glMapBufferRange(final int n, final long n2, final long n3, final int n4) {
        return this.mapBufferRange(n, n2, n3, n4).getMappedBuffer();
    }
    
    @Override
    public final GLBufferStorage mapBufferRange(final int n, final long n2, final long n3, final int n4) {
        return this.bufferObjectTracker.mapBuffer(this.bufferStateTracker, this, n, n2, n3, n4, this.glMapBufferRangeDispatch);
    }
    
    private native ByteBuffer newDirectByteBuffer(final long p0, final long p1);
    
    public GL4bcImpl(final GLProfile glProfile, final GLContextImpl context) {
        this.glBufferDataDispatch = new GLBufferObjectTracker.CreateStorageDispatch() {
            @Override
            public final void create(final int n, final long n2, final Buffer buffer, final int n3) {
                GL4bcImpl.this.glBufferDataDelegate(n, n2, buffer, n3);
            }
        };
        this.glUnmapBufferDispatch = new GLBufferObjectTracker.UnmapBufferDispatch() {
            @Override
            public final boolean unmap(final int n) {
                return GL4bcImpl.this.glUnmapBufferDelegate(n);
            }
        };
        this.glMapBufferDispatch = new GLBufferObjectTracker.MapBufferAllDispatch() {
            @Override
            public final ByteBuffer allocNioByteBuffer(final long n, final long n2) {
                return GL4bcImpl.this.newDirectByteBuffer(n, n2);
            }
            
            @Override
            public final long mapBuffer(final int n, final int n2) {
                return GL4bcImpl.this.glMapBufferDelegate(n, n2);
            }
        };
        this.glMapBufferRangeDispatch = new GLBufferObjectTracker.MapBufferRangeDispatch() {
            @Override
            public final ByteBuffer allocNioByteBuffer(final long n, final long n2) {
                return GL4bcImpl.this.newDirectByteBuffer(n, n2);
            }
            
            @Override
            public final long mapBuffer(final int n, final long n2, final long n3, final int n4) {
                return GL4bcImpl.this.glMapBufferRangeDelegate(n, n2, n3, n4);
            }
        };
        this.imageSizeTemp = new int[1];
        this.glNamedBufferDataDispatch = new GLBufferObjectTracker.CreateStorageDispatch() {
            @Override
            public final void create(final int n, final long n2, final Buffer buffer, final int n3) {
                GL4bcImpl.this.glNamedBufferDataDelegate(n, n2, buffer, n3);
            }
        };
        this.glNamedBufferDataEXTDispatch = new GLBufferObjectTracker.CreateStorageDispatch() {
            @Override
            public final void create(final int n, final long n2, final Buffer buffer, final int n3) {
                GL4bcImpl.this.glNamedBufferDataEXTDelegate(n, n2, buffer, n3);
            }
        };
        this.glBufferStorageDispatch = new GLBufferObjectTracker.CreateStorageDispatch() {
            @Override
            public final void create(final int n, final long n2, final Buffer buffer, final int n3) {
                GL4bcImpl.this.glBufferStorageDelegate(n, n2, buffer, n3);
            }
        };
        this.glNamedBufferStorageDispatch = new GLBufferObjectTracker.CreateStorageDispatch() {
            @Override
            public final void create(final int n, final long n2, final Buffer buffer, final int n3) {
                GL4bcImpl.this.glNamedBufferStorageDelegate(n, n2, buffer, n3);
            }
        };
        this.glNamedBufferStorageEXTDispatch = new GLBufferObjectTracker.CreateStorageDispatch() {
            @Override
            public final void create(final int n, final long n2, final Buffer buffer, final int n3) {
                GL4bcImpl.this.glNamedBufferStorageEXTDelegate(n, n2, buffer, n3);
            }
        };
        this.glUnmapNamedBufferDispatch = new GLBufferObjectTracker.UnmapBufferDispatch() {
            @Override
            public final boolean unmap(final int n) {
                return GL4bcImpl.this.glUnmapNamedBufferDelegate(n);
            }
        };
        this.glMapNamedBufferDispatch = new GLBufferObjectTracker.MapBufferAllDispatch() {
            @Override
            public final ByteBuffer allocNioByteBuffer(final long n, final long n2) {
                return GL4bcImpl.this.newDirectByteBuffer(n, n2);
            }
            
            @Override
            public final long mapBuffer(final int n, final int n2) {
                return GL4bcImpl.this.glMapNamedBufferDelegate(n, n2);
            }
        };
        this.glMapNamedBufferEXTDispatch = new GLBufferObjectTracker.MapBufferAllDispatch() {
            @Override
            public final ByteBuffer allocNioByteBuffer(final long n, final long n2) {
                return GL4bcImpl.this.newDirectByteBuffer(n, n2);
            }
            
            @Override
            public final long mapBuffer(final int n, final int n2) {
                return GL4bcImpl.this.glMapNamedBufferEXTDelegate(n, n2);
            }
        };
        this.glMapNamedBufferRangeDispatch = new GLBufferObjectTracker.MapBufferRangeDispatch() {
            @Override
            public final ByteBuffer allocNioByteBuffer(final long n, final long n2) {
                return GL4bcImpl.this.newDirectByteBuffer(n, n2);
            }
            
            @Override
            public final long mapBuffer(final int n, final long n2, final long n3, final int n4) {
                return GL4bcImpl.this.glMapNamedBufferRangeDelegate(n, n2, n3, n4);
            }
        };
        this.glMapNamedBufferRangeEXTDispatch = new GLBufferObjectTracker.MapBufferRangeDispatch() {
            @Override
            public final ByteBuffer allocNioByteBuffer(final long n, final long n2) {
                return GL4bcImpl.this.newDirectByteBuffer(n, n2);
            }
            
            @Override
            public final long mapBuffer(final int n, final long n2, final long n3, final int n4) {
                return GL4bcImpl.this.glMapNamedBufferRangeEXTDelegate(n, n2, n3, n4);
            }
        };
        this._context = context;
        this._pat = (GL4bcProcAddressTable)this._context.getGLProcAddressTable();
        this.bufferObjectTracker = context.getBufferObjectTracker();
        this.bufferStateTracker = context.getBufferStateTracker();
        this.glStateTracker = context.getGLStateTracker();
        this.glProfile = glProfile;
    }
    
    public final void finalizeInit() {
        this.haveARBPixelBufferObject = this.isExtensionAvailable("GL_ARB_pixel_buffer_object");
        this.haveEXTPixelBufferObject = this.isExtensionAvailable("GL_EXT_pixel_buffer_object");
        this.haveGL15 = this.isExtensionAvailable("GL_VERSION_1_5");
        this.haveGL21 = this.isExtensionAvailable("GL_VERSION_2_1");
        this.haveARBVertexBufferObject = this.isExtensionAvailable("GL_ARB_vertex_buffer_object");
        this.haveARBVertexArrayObject = (this._context.getGLVersionNumber().compareTo(GLContext.Version3_0) >= 0 || this.isExtensionAvailable("GL_ARB_vertex_array_object"));
    }
    
    private final int imageSizeInBytes(final int n, final int n2, final int n3, final int n4, final int n5, final boolean b) {
        return GLBuffers.sizeof(this, this.imageSizeTemp, n, n2, n3, n4, n5, b);
    }
    
    @Override
    public final boolean isGL4bc() {
        return this._context.isGL4bc();
    }
    
    @Override
    public final boolean isGL4() {
        return this._context.isGL4();
    }
    
    @Override
    public final boolean isGL3bc() {
        return this._context.isGL3bc();
    }
    
    @Override
    public final boolean isGL3() {
        return this._context.isGL3();
    }
    
    @Override
    public final boolean isGL2() {
        return this._context.isGL2();
    }
    
    @Override
    public final boolean isGL2ES1() {
        return this._context.isGL2ES1();
    }
    
    @Override
    public final boolean isGL2ES2() {
        return this._context.isGL2ES2();
    }
    
    @Override
    public final boolean isGL2ES3() {
        return this._context.isGL2ES3();
    }
    
    @Override
    public final boolean isGL3ES3() {
        return this._context.isGL3ES3();
    }
    
    @Override
    public final boolean isGL4ES3() {
        return this._context.isGL4ES3();
    }
    
    @Override
    public final boolean isGL4core() {
        return this._context.isGL4core();
    }
    
    @Override
    public final boolean isGL3core() {
        return this._context.isGL3core();
    }
    
    @Override
    public final boolean isGLcore() {
        return this._context.isGLcore();
    }
    
    @Override
    public final boolean isGLES2Compatible() {
        return this._context.isGLES2Compatible();
    }
    
    @Override
    public final boolean isGLES3Compatible() {
        return this._context.isGLES3Compatible();
    }
    
    @Override
    public final boolean isGLES31Compatible() {
        return this._context.isGLES31Compatible();
    }
    
    @Override
    public final boolean isGLES32Compatible() {
        return this._context.isGLES32Compatible();
    }
    
    @Override
    public final boolean isGL2GL3() {
        return this._context.isGL2GL3();
    }
    
    @Override
    public final boolean hasGLSL() {
        return this._context.hasGLSL();
    }
    
    @Override
    public final GL4bc getGL4bc() throws GLException {
        if (!this.isGL4bc()) {
            throw new GLException("Not a GL4bc implementation");
        }
        return this;
    }
    
    @Override
    public final GL4 getGL4() throws GLException {
        if (!this.isGL4()) {
            throw new GLException("Not a GL4 implementation");
        }
        return this;
    }
    
    @Override
    public final GL3bc getGL3bc() throws GLException {
        if (!this.isGL3bc()) {
            throw new GLException("Not a GL3bc implementation");
        }
        return this;
    }
    
    @Override
    public final GL3 getGL3() throws GLException {
        if (!this.isGL3()) {
            throw new GLException("Not a GL3 implementation");
        }
        return this;
    }
    
    @Override
    public final GL2 getGL2() throws GLException {
        if (!this.isGL2()) {
            throw new GLException("Not a GL2 implementation");
        }
        return this;
    }
    
    @Override
    public final GL2ES1 getGL2ES1() throws GLException {
        if (!this.isGL2ES1()) {
            throw new GLException("Not a GL2ES1 implementation");
        }
        return this;
    }
    
    @Override
    public final GL2ES2 getGL2ES2() throws GLException {
        if (!this.isGL2ES2()) {
            throw new GLException("Not a GL2ES2 implementation");
        }
        return this;
    }
    
    @Override
    public final GL2ES3 getGL2ES3() throws GLException {
        if (!this.isGL2ES3()) {
            throw new GLException("Not a GL2ES3 implementation");
        }
        return this;
    }
    
    @Override
    public final GL3ES3 getGL3ES3() throws GLException {
        if (!this.isGL3ES3()) {
            throw new GLException("Not a GL3ES3 implementation");
        }
        return this;
    }
    
    @Override
    public final GL4ES3 getGL4ES3() throws GLException {
        if (!this.isGL4ES3()) {
            throw new GLException("Not a GL4ES3 implementation");
        }
        return this;
    }
    
    @Override
    public final GL2GL3 getGL2GL3() throws GLException {
        if (!this.isGL2GL3()) {
            throw new GLException("Not a GL2GL3 implementation");
        }
        return this;
    }
    
    @Override
    public final boolean isGLES1() {
        return false;
    }
    
    @Override
    public final boolean isGLES2() {
        return false;
    }
    
    @Override
    public final boolean isGLES3() {
        return false;
    }
    
    @Override
    public final boolean isGLES() {
        return false;
    }
    
    @Override
    public final GLES1 getGLES1() throws GLException {
        throw new GLException("Not a GLES1 implementation");
    }
    
    @Override
    public final GLES2 getGLES2() throws GLException {
        throw new GLException("Not a GLES2 implementation");
    }
    
    @Override
    public final GLES3 getGLES3() throws GLException {
        throw new GLException("Not a GLES3 implementation");
    }
    
    @Override
    public final boolean isNPOTTextureAvailable() {
        return this._context.isNPOTTextureAvailable();
    }
    
    private final boolean checkBufferObject(final boolean b, final boolean b2, final boolean b3, final int n, final String s, final boolean b4) {
        if (this.inBeginEndPair) {
            throw new GLException("May not call this between glBegin and glEnd");
        }
        if (!b) {
            if (!b3) {
                return true;
            }
            if (b4) {
                throw new GLException("Required extensions not available to call this function");
            }
            return false;
        }
        else {
            final int boundBufferObject = this.bufferStateTracker.getBoundBufferObject(n, this);
            if (b3) {
                if (boundBufferObject != 0) {
                    return true;
                }
                if (b2) {
                    final int boundBufferObject2 = this.bufferStateTracker.getBoundBufferObject(34229, this);
                    if (boundBufferObject2 && this._context.getDefaultVAO() != boundBufferObject2) {
                        return true;
                    }
                }
                if (b4) {
                    throw new GLException(s + " must be bound to call this method");
                }
                return false;
            }
            else {
                if (boundBufferObject == 0) {
                    return true;
                }
                if (b4) {
                    throw new GLException(s + " must be unbound to call this method");
                }
                return false;
            }
        }
    }
    
    private final void validateCPUSourcedAvail() {
        if (!this._context.isCPUDataSourcingAvail()) {
            throw new GLException("CPU data sourcing n/a w/ " + this._context);
        }
    }
    
    private final boolean checkArrayVBOUnbound(final boolean b) {
        if (b) {
            this.validateCPUSourcedAvail();
        }
        return this.checkBufferObject(this.haveGL15 || this.haveARBVertexBufferObject, this.haveARBVertexArrayObject, false, 34962, "array vertex_buffer_object", b);
    }
    
    private final boolean checkArrayVBOBound(final boolean b) {
        return this.checkBufferObject(this.haveGL15 || this.haveARBVertexBufferObject, this.haveARBVertexArrayObject, true, 34962, "array vertex_buffer_object", b);
    }
    
    private final boolean checkElementVBOUnbound(final boolean b) {
        if (b) {
            this.validateCPUSourcedAvail();
        }
        return this.checkBufferObject(this.haveGL15 || this.haveARBVertexBufferObject, this.haveARBVertexArrayObject, false, 34963, "element vertex_buffer_object", b);
    }
    
    private final boolean checkElementVBOBound(final boolean b) {
        return this.checkBufferObject(this.haveGL15 || this.haveARBVertexBufferObject, this.haveARBVertexArrayObject, true, 34963, "element vertex_buffer_object", b);
    }
    
    private final boolean checkIndirectVBOUnbound(final boolean b) {
        if (b) {
            this.validateCPUSourcedAvail();
        }
        return this.checkBufferObject(this.haveGL15 || this.haveARBVertexBufferObject, this.haveARBVertexArrayObject, false, 36671, "indirect vertex_buffer_object", b);
    }
    
    private final boolean checkIndirectVBOBound(final boolean b) {
        return this.checkBufferObject(this.haveGL15 || this.haveARBVertexBufferObject, this.haveARBVertexArrayObject, true, 36671, "indirect vertex_buffer_object", b);
    }
    
    private final boolean checkUnpackPBOUnbound(final boolean b) {
        return this.checkBufferObject(this.haveGL21 || this.haveARBPixelBufferObject || this.haveEXTPixelBufferObject, false, false, 35052, "unpack pixel_buffer_object", b);
    }
    
    private final boolean checkUnpackPBOBound(final boolean b) {
        return this.checkBufferObject(this.haveGL21 || this.haveARBPixelBufferObject || this.haveEXTPixelBufferObject, false, true, 35052, "unpack pixel_buffer_object", b);
    }
    
    private final boolean checkPackPBOUnbound(final boolean b) {
        return this.checkBufferObject(this.haveGL21 || this.haveARBPixelBufferObject || this.haveEXTPixelBufferObject, false, false, 35051, "pack pixel_buffer_object", b);
    }
    
    private final boolean checkPackPBOBound(final boolean b) {
        return this.checkBufferObject(this.haveGL21 || this.haveARBPixelBufferObject || this.haveEXTPixelBufferObject, false, true, 35051, "pack pixel_buffer_object", b);
    }
    
    @Override
    public final boolean isPBOPackBound() {
        return this.checkPackPBOBound(false);
    }
    
    @Override
    public final boolean isPBOUnpackBound() {
        return this.checkUnpackPBOBound(false);
    }
    
    @Override
    public final void glVertexPointer(final GLArrayData glArrayData) {
        if (glArrayData.getComponentCount() == 0) {
            return;
        }
        if (glArrayData.isVBO()) {
            this.glVertexPointer(glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getVBOOffset());
        }
        else {
            this.glVertexPointer(glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getBuffer());
        }
    }
    
    @Override
    public final void glColorPointer(final GLArrayData glArrayData) {
        if (glArrayData.getComponentCount() == 0) {
            return;
        }
        if (glArrayData.isVBO()) {
            this.glColorPointer(glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getVBOOffset());
        }
        else {
            this.glColorPointer(glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getBuffer());
        }
    }
    
    @Override
    public final void glNormalPointer(final GLArrayData glArrayData) {
        if (glArrayData.getComponentCount() == 0) {
            return;
        }
        if (glArrayData.getComponentCount() != 3) {
            throw new GLException("Only 3 components per normal allowed");
        }
        if (glArrayData.isVBO()) {
            this.glNormalPointer(glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getVBOOffset());
        }
        else {
            this.glNormalPointer(glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getBuffer());
        }
    }
    
    @Override
    public final void glTexCoordPointer(final GLArrayData glArrayData) {
        if (glArrayData.getComponentCount() == 0) {
            return;
        }
        if (glArrayData.isVBO()) {
            this.glTexCoordPointer(glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getVBOOffset());
        }
        else {
            this.glTexCoordPointer(glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getStride(), glArrayData.getBuffer());
        }
    }
    
    @Override
    public final void glNamedBufferData(final int n, final long n2, final Buffer buffer, final int n3) {
        this.bufferObjectTracker.createBufferStorage(this, n, n2, buffer, n3, 0, this.glNamedBufferDataDispatch);
    }
    
    @Override
    public final void glNamedBufferDataEXT(final int n, final long n2, final Buffer buffer, final int n3) {
        this.bufferObjectTracker.createBufferStorage(this, n, n2, buffer, n3, 0, this.glNamedBufferDataEXTDispatch);
    }
    
    @Override
    public final void glBufferStorage(final int n, final long n2, final Buffer buffer, final int n3) {
        this.bufferObjectTracker.createBufferStorage(this.bufferStateTracker, this, n, n2, buffer, 0, n3, this.glBufferStorageDispatch);
    }
    
    @Override
    public final void glNamedBufferStorage(final int n, final long n2, final Buffer buffer, final int n3) {
        this.bufferObjectTracker.createBufferStorage(this, n, n2, buffer, 0, n3, this.glNamedBufferStorageDispatch);
    }
    
    @Override
    public final void glNamedBufferStorageEXT(final int n, final long n2, final Buffer buffer, final int n3) {
        this.bufferObjectTracker.createBufferStorage(this, n, n2, buffer, 0, n3, this.glNamedBufferStorageEXTDispatch);
    }
    
    @Override
    public boolean glUnmapNamedBuffer(final int n) {
        return this.bufferObjectTracker.unmapBuffer(n, this.glUnmapNamedBufferDispatch);
    }
    
    @Override
    public final ByteBuffer glMapNamedBuffer(final int n, final int n2) {
        return this.mapNamedBuffer(n, n2).getMappedBuffer();
    }
    
    @Override
    public final GLBufferStorage mapNamedBuffer(final int n, final int n2) {
        return this.bufferObjectTracker.mapBuffer(n, n2, this.glMapNamedBufferDispatch);
    }
    
    @Override
    public final ByteBuffer glMapNamedBufferEXT(final int n, final int n2) {
        return this.mapNamedBufferEXT(n, n2).getMappedBuffer();
    }
    
    @Override
    public final GLBufferStorage mapNamedBufferEXT(final int n, final int n2) {
        return this.bufferObjectTracker.mapBuffer(n, n2, this.glMapNamedBufferEXTDispatch);
    }
    
    @Override
    public final ByteBuffer glMapNamedBufferRange(final int n, final long n2, final long n3, final int n4) {
        return this.mapNamedBufferRange(n, n2, n3, n4).getMappedBuffer();
    }
    
    @Override
    public final GLBufferStorage mapNamedBufferRange(final int n, final long n2, final long n3, final int n4) {
        return this.bufferObjectTracker.mapBuffer(n, n2, n3, n4, this.glMapNamedBufferRangeDispatch);
    }
    
    @Override
    public final ByteBuffer glMapNamedBufferRangeEXT(final int n, final long n2, final long n3, final int n4) {
        return this.mapNamedBufferRangeEXT(n, n2, n3, n4).getMappedBuffer();
    }
    
    @Override
    public final GLBufferStorage mapNamedBufferRangeEXT(final int n, final long n2, final long n3, final int n4) {
        return this.bufferObjectTracker.mapBuffer(n, n2, n3, n4, this.glMapNamedBufferRangeEXTDispatch);
    }
    
    @Override
    public final void glVertexAttribPointer(final GLArrayData glArrayData) {
        if (glArrayData.getComponentCount() == 0) {
            return;
        }
        if (glArrayData.isVBO()) {
            this.glVertexAttribPointer(glArrayData.getLocation(), glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getNormalized(), glArrayData.getStride(), glArrayData.getVBOOffset());
        }
        else {
            this.glVertexAttribPointer(glArrayData.getLocation(), glArrayData.getComponentCount(), glArrayData.getComponentType(), glArrayData.getNormalized(), glArrayData.getStride(), glArrayData.getBuffer());
        }
    }
    
    @Override
    public final void glUniform(final GLUniformData glUniformData) {
        int n = 0;
        if (glUniformData.isBuffer()) {
            final Buffer buffer = glUniformData.getBuffer();
            if (glUniformData.isMatrix()) {
                if (buffer instanceof FloatBuffer) {
                    switch (glUniformData.columns()) {
                        case 2: {
                            this.glUniformMatrix2fv(glUniformData.getLocation(), glUniformData.count(), false, (FloatBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 3: {
                            this.glUniformMatrix3fv(glUniformData.getLocation(), glUniformData.count(), false, (FloatBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 4: {
                            this.glUniformMatrix4fv(glUniformData.getLocation(), glUniformData.count(), false, (FloatBuffer)buffer);
                            n = 1;
                            break;
                        }
                    }
                }
                if (n == 0) {
                    throw new GLException("glUniformMatrix only available for 2fv, 3fv and 4fv");
                }
            }
            else {
                if (buffer instanceof IntBuffer) {
                    switch (glUniformData.components()) {
                        case 1: {
                            this.glUniform1iv(glUniformData.getLocation(), glUniformData.count(), (IntBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 2: {
                            this.glUniform2iv(glUniformData.getLocation(), glUniformData.count(), (IntBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 3: {
                            this.glUniform3iv(glUniformData.getLocation(), glUniformData.count(), (IntBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 4: {
                            this.glUniform4iv(glUniformData.getLocation(), glUniformData.count(), (IntBuffer)buffer);
                            n = 1;
                            break;
                        }
                    }
                }
                else if (buffer instanceof FloatBuffer) {
                    switch (glUniformData.components()) {
                        case 1: {
                            this.glUniform1fv(glUniformData.getLocation(), glUniformData.count(), (FloatBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 2: {
                            this.glUniform2fv(glUniformData.getLocation(), glUniformData.count(), (FloatBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 3: {
                            this.glUniform3fv(glUniformData.getLocation(), glUniformData.count(), (FloatBuffer)buffer);
                            n = 1;
                            break;
                        }
                        case 4: {
                            this.glUniform4fv(glUniformData.getLocation(), glUniformData.count(), (FloatBuffer)buffer);
                            n = 1;
                            break;
                        }
                    }
                }
                if (n == 0) {
                    throw new GLException("glUniform vector only available for 1[if]v 2[if]v, 3[if]v and 4[if]v");
                }
            }
        }
        else {
            final Object object = glUniformData.getObject();
            if (object instanceof Integer) {
                this.glUniform1i(glUniformData.getLocation(), (int)object);
                n = 1;
            }
            else if (object instanceof Float) {
                this.glUniform1f(glUniformData.getLocation(), (float)object);
                n = 1;
            }
            if (n == 0) {
                throw new GLException("glUniform atom only available for 1i and 1f");
            }
        }
    }
}
